/* tslint:disable */
/* eslint-disable */
/**
 * Plex-API
 * An Open API Spec for interacting with Plex.tv and Plex Servers
 *
 * The version of the OpenAPI document: 0.0.3
 * Contact: Lukeslakemail@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface GetButlerTasks200Response
 */
export interface GetButlerTasks200Response {
    /**
     * 
     * @type {GetButlerTasks200ResponseButlerTasks}
     * @memberof GetButlerTasks200Response
     */
    'ButlerTasks'?: GetButlerTasks200ResponseButlerTasks;
}
/**
 * 
 * @export
 * @interface GetButlerTasks200ResponseButlerTasks
 */
export interface GetButlerTasks200ResponseButlerTasks {
    /**
     * 
     * @type {any}
     * @memberof GetButlerTasks200ResponseButlerTasks
     */
    'ButlerTask'?: any;
}
/**
 * 
 * @export
 * @interface GetHomeData200Response
 */
export interface GetHomeData200Response {
    /**
     * 
     * @type {any}
     * @memberof GetHomeData200Response
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetHomeData200Response
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetHomeData200Response
     */
    'guestUserID'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetHomeData200Response
     */
    'guestUserUUID'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetHomeData200Response
     */
    'guestEnabled'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetHomeData200Response
     */
    'subscription'?: any;
}
/**
 * 
 * @export
 * @interface GetMyPlexAccount200Response
 */
export interface GetMyPlexAccount200Response {
    /**
     * 
     * @type {GetMyPlexAccount200ResponseMyPlex}
     * @memberof GetMyPlexAccount200Response
     */
    'MyPlex'?: GetMyPlexAccount200ResponseMyPlex;
}
/**
 * 
 * @export
 * @interface GetMyPlexAccount200ResponseMyPlex
 */
export interface GetMyPlexAccount200ResponseMyPlex {
    /**
     * 
     * @type {any}
     * @memberof GetMyPlexAccount200ResponseMyPlex
     */
    'authToken'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetMyPlexAccount200ResponseMyPlex
     */
    'username'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetMyPlexAccount200ResponseMyPlex
     */
    'mappingState'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetMyPlexAccount200ResponseMyPlex
     */
    'mappingError'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetMyPlexAccount200ResponseMyPlex
     */
    'signInState'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetMyPlexAccount200ResponseMyPlex
     */
    'publicAddress'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetMyPlexAccount200ResponseMyPlex
     */
    'publicPort'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetMyPlexAccount200ResponseMyPlex
     */
    'privateAddress'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetMyPlexAccount200ResponseMyPlex
     */
    'privatePort'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetMyPlexAccount200ResponseMyPlex
     */
    'subscriptionFeatures'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetMyPlexAccount200ResponseMyPlex
     */
    'subscriptionActive'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetMyPlexAccount200ResponseMyPlex
     */
    'subscriptionState'?: any;
}
/**
 * 
 * @export
 * @interface GetOnDeck200Response
 */
export interface GetOnDeck200Response {
    /**
     * 
     * @type {GetOnDeck200ResponseMediaContainer}
     * @memberof GetOnDeck200Response
     */
    'MediaContainer'?: GetOnDeck200ResponseMediaContainer;
}
/**
 * 
 * @export
 * @interface GetOnDeck200ResponseMediaContainer
 */
export interface GetOnDeck200ResponseMediaContainer {
    /**
     * 
     * @type {any}
     * @memberof GetOnDeck200ResponseMediaContainer
     */
    'size'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetOnDeck200ResponseMediaContainer
     */
    'allowSync'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetOnDeck200ResponseMediaContainer
     */
    'identifier'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetOnDeck200ResponseMediaContainer
     */
    'mediaTagPrefix'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetOnDeck200ResponseMediaContainer
     */
    'mediaTagVersion'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetOnDeck200ResponseMediaContainer
     */
    'mixedParents'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetOnDeck200ResponseMediaContainer
     */
    'Metadata'?: any;
}
/**
 * 
 * @export
 * @interface GetPin200Response
 */
export interface GetPin200Response {
    /**
     * PinID for use with authentication
     * @type {any}
     * @memberof GetPin200Response
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200Response
     */
    'code'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200Response
     */
    'product'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200Response
     */
    'trusted'?: any;
    /**
     * a link to a QR code hosted on plex.tv  The QR code redirects to the relevant `plex.tv/link` authentication page Which then prompts the user for the 4 Digit Link Pin 
     * @type {any}
     * @memberof GetPin200Response
     */
    'qr'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200Response
     */
    'clientIdentifier'?: any;
    /**
     * 
     * @type {GetPin200ResponseLocation}
     * @memberof GetPin200Response
     */
    'location'?: GetPin200ResponseLocation;
    /**
     * 
     * @type {any}
     * @memberof GetPin200Response
     */
    'expiresIn'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200Response
     */
    'createdAt'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200Response
     */
    'expiresAt'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200Response
     */
    'authToken'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200Response
     */
    'newRegistration'?: any;
}
/**
 * 
 * @export
 * @interface GetPin200ResponseLocation
 */
export interface GetPin200ResponseLocation {
    /**
     * 
     * @type {any}
     * @memberof GetPin200ResponseLocation
     */
    'code'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200ResponseLocation
     */
    'european_union_member'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200ResponseLocation
     */
    'continent_code'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200ResponseLocation
     */
    'country'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200ResponseLocation
     */
    'city'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200ResponseLocation
     */
    'time_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200ResponseLocation
     */
    'postal_code'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200ResponseLocation
     */
    'in_privacy_restricted_country'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200ResponseLocation
     */
    'subdivisions'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetPin200ResponseLocation
     */
    'coordinates'?: any;
}
/**
 * 
 * @export
 * @interface GetPin400Response
 */
export interface GetPin400Response {
    /**
     * 
     * @type {any}
     * @memberof GetPin400Response
     */
    'errors'?: any;
}
/**
 * 
 * @export
 * @interface GetRecentlyAdded200Response
 */
export interface GetRecentlyAdded200Response {
    /**
     * 
     * @type {GetRecentlyAdded200ResponseMediaContainer}
     * @memberof GetRecentlyAdded200Response
     */
    'MediaContainer'?: GetRecentlyAdded200ResponseMediaContainer;
}
/**
 * 
 * @export
 * @interface GetRecentlyAdded200ResponseMediaContainer
 */
export interface GetRecentlyAdded200ResponseMediaContainer {
    /**
     * 
     * @type {any}
     * @memberof GetRecentlyAdded200ResponseMediaContainer
     */
    'size'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetRecentlyAdded200ResponseMediaContainer
     */
    'allowSync'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetRecentlyAdded200ResponseMediaContainer
     */
    'identifier'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetRecentlyAdded200ResponseMediaContainer
     */
    'mediaTagPrefix'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetRecentlyAdded200ResponseMediaContainer
     */
    'mediaTagVersion'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetRecentlyAdded200ResponseMediaContainer
     */
    'mixedParents'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetRecentlyAdded200ResponseMediaContainer
     */
    'Metadata'?: any;
}
/**
 * 
 * @export
 * @interface GetSearchResults200Response
 */
export interface GetSearchResults200Response {
    /**
     * 
     * @type {GetSearchResults200ResponseMediaContainer}
     * @memberof GetSearchResults200Response
     */
    'MediaContainer'?: GetSearchResults200ResponseMediaContainer;
}
/**
 * 
 * @export
 * @interface GetSearchResults200ResponseMediaContainer
 */
export interface GetSearchResults200ResponseMediaContainer {
    /**
     * 
     * @type {any}
     * @memberof GetSearchResults200ResponseMediaContainer
     */
    'size'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetSearchResults200ResponseMediaContainer
     */
    'identifier'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetSearchResults200ResponseMediaContainer
     */
    'mediaTagPrefix'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetSearchResults200ResponseMediaContainer
     */
    'mediaTagVersion'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetSearchResults200ResponseMediaContainer
     */
    'Metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetSearchResults200ResponseMediaContainer
     */
    'Provider'?: any;
}
/**
 * 
 * @export
 * @interface GetServerActivities200Response
 */
export interface GetServerActivities200Response {
    /**
     * 
     * @type {GetServerActivities200ResponseMediaContainer}
     * @memberof GetServerActivities200Response
     */
    'MediaContainer'?: GetServerActivities200ResponseMediaContainer;
}
/**
 * 
 * @export
 * @interface GetServerActivities200ResponseMediaContainer
 */
export interface GetServerActivities200ResponseMediaContainer {
    /**
     * 
     * @type {any}
     * @memberof GetServerActivities200ResponseMediaContainer
     */
    'size'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerActivities200ResponseMediaContainer
     */
    'Activity'?: any;
}
/**
 * 
 * @export
 * @interface GetServerCapabilities200Response
 */
export interface GetServerCapabilities200Response {
    /**
     * 
     * @type {GetServerCapabilities200ResponseMediaContainer}
     * @memberof GetServerCapabilities200Response
     */
    'MediaContainer'?: GetServerCapabilities200ResponseMediaContainer;
}
/**
 * 
 * @export
 * @interface GetServerCapabilities200ResponseMediaContainer
 */
export interface GetServerCapabilities200ResponseMediaContainer {
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'size'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'allowCameraUpload'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'allowChannelAccess'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'allowMediaDeletion'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'allowSharing'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'allowSync'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'allowTuners'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'backgroundProcessing'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'certificate'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'companionProxy'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'countryCode'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'diagnostics'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'eventStream'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'friendlyName'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'hubSearch'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'itemClusters'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'livetv'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'machineIdentifier'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'mediaProviders'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'multiuser'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'musicAnalysis'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'myPlex'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'myPlexMappingState'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'myPlexSigninState'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'myPlexSubscription'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'myPlexUsername'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'offlineTranscode'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'ownerFeatures'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'photoAutoTag'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'platform'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'platformVersion'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'pluginHost'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'pushNotifications'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'readOnlyLibraries'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'streamingBrainABRVersion'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'streamingBrainVersion'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'sync'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'transcoderActiveVideoSessions'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'transcoderAudio'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'transcoderLyrics'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'transcoderPhoto'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'transcoderSubtitles'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'transcoderVideo'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'transcoderVideoBitrates'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'transcoderVideoQualities'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'transcoderVideoResolutions'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'updatedAt'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'updater'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'version'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'voiceSearch'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities200ResponseMediaContainer
     */
    'Directory'?: any;
}
/**
 * 
 * @export
 * @interface GetServerCapabilities401Response
 */
export interface GetServerCapabilities401Response {
    /**
     * 
     * @type {any}
     * @memberof GetServerCapabilities401Response
     */
    'errors'?: any;
}
/**
 * 
 * @export
 * @interface GetServerIdentity200Response
 */
export interface GetServerIdentity200Response {
    /**
     * 
     * @type {GetServerIdentity200ResponseMediaContainer}
     * @memberof GetServerIdentity200Response
     */
    'MediaContainer'?: GetServerIdentity200ResponseMediaContainer;
}
/**
 * 
 * @export
 * @interface GetServerIdentity200ResponseMediaContainer
 */
export interface GetServerIdentity200ResponseMediaContainer {
    /**
     * 
     * @type {any}
     * @memberof GetServerIdentity200ResponseMediaContainer
     */
    'size'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerIdentity200ResponseMediaContainer
     */
    'claimed'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerIdentity200ResponseMediaContainer
     */
    'machineIdentifier'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerIdentity200ResponseMediaContainer
     */
    'version'?: any;
}
/**
 * 
 * @export
 * @interface GetServerList200Response
 */
export interface GetServerList200Response {
    /**
     * 
     * @type {GetServerList200ResponseMediaContainer}
     * @memberof GetServerList200Response
     */
    'MediaContainer'?: GetServerList200ResponseMediaContainer;
}
/**
 * 
 * @export
 * @interface GetServerList200ResponseMediaContainer
 */
export interface GetServerList200ResponseMediaContainer {
    /**
     * 
     * @type {any}
     * @memberof GetServerList200ResponseMediaContainer
     */
    'size'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetServerList200ResponseMediaContainer
     */
    'Server'?: any;
}
/**
 * 
 * @export
 * @interface GetTranscodeSessions200Response
 */
export interface GetTranscodeSessions200Response {
    /**
     * 
     * @type {GetTranscodeSessions200ResponseMediaContainer}
     * @memberof GetTranscodeSessions200Response
     */
    'MediaContainer'?: GetTranscodeSessions200ResponseMediaContainer;
}
/**
 * 
 * @export
 * @interface GetTranscodeSessions200ResponseMediaContainer
 */
export interface GetTranscodeSessions200ResponseMediaContainer {
    /**
     * 
     * @type {any}
     * @memberof GetTranscodeSessions200ResponseMediaContainer
     */
    'size'?: any;
    /**
     * 
     * @type {any}
     * @memberof GetTranscodeSessions200ResponseMediaContainer
     */
    'TranscodeSession'?: any;
}

/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
export const ActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel Server Activities
         * @summary Cancel Server Activities
         * @param {any} activityUUID The UUID of the activity to cancel.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelServerActivities: async (activityUUID: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityUUID' is not null or undefined
            assertParamExists('cancelServerActivities', 'activityUUID', activityUUID)
            const localVarPath = `/activities/{activityUUID}`
                .replace(`{${"activityUUID"}}`, encodeURIComponent(String(activityUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get Server Activities
         * @summary Get Server Activities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerActivities: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel Server Activities
         * @summary Cancel Server Activities
         * @param {any} activityUUID The UUID of the activity to cancel.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelServerActivities(activityUUID: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelServerActivities(activityUUID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Server Activities
         * @summary Get Server Activities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServerActivities(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServerActivities200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerActivities(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivitiesApiFp(configuration)
    return {
        /**
         * Cancel Server Activities
         * @summary Cancel Server Activities
         * @param {any} activityUUID The UUID of the activity to cancel.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelServerActivities(activityUUID: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.cancelServerActivities(activityUUID, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get Server Activities
         * @summary Get Server Activities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerActivities(axiosOptions?: any): AxiosPromise<GetServerActivities200Response> {
            return localVarFp.getServerActivities(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelServerActivities operation in ActivitiesApi.
 * @export
 * @interface ActivitiesApiCancelServerActivitiesRequest
 */
export interface ActivitiesApiCancelServerActivitiesRequest {
    /**
     * The UUID of the activity to cancel.
     * @type {any}
     * @memberof ActivitiesApiCancelServerActivities
     */
    readonly activityUUID: any
}

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * Cancel Server Activities
     * @summary Cancel Server Activities
     * @param {ActivitiesApiCancelServerActivitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public cancelServerActivities(requestParameters: ActivitiesApiCancelServerActivitiesRequest, axiosOptions?: AxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).cancelServerActivities(requestParameters.activityUUID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server Activities
     * @summary Get Server Activities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getServerActivities(axiosOptions?: AxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).getServerActivities(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a Pin from Plex.tv for authentication flows
         * @summary Get a Pin
         * @param {any} [strong] Determines the kind of code returned by the API call Strong codes are used for Pin authentication flows Non-Strong codes are used for &#x60;Plex.tv/link&#x60; 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPin: async (strong?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            if (strong !== undefined) {
                localVarQueryParameter['strong'] = strong;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an Access Token from Plex.tv after the Pin has already been authenticated
         * @summary Get Access Token
         * @param {any} pinID The PinID to retrieve an access token for
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (pinID: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pinID' is not null or undefined
            assertParamExists('getToken', 'pinID', pinID)
            const localVarPath = `/pins/{pinID}`
                .replace(`{${"pinID"}}`, encodeURIComponent(String(pinID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a Pin from Plex.tv for authentication flows
         * @summary Get a Pin
         * @param {any} [strong] Determines the kind of code returned by the API call Strong codes are used for Pin authentication flows Non-Strong codes are used for &#x60;Plex.tv/link&#x60; 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPin(strong?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPin(strong, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an Access Token from Plex.tv after the Pin has already been authenticated
         * @summary Get Access Token
         * @param {any} pinID The PinID to retrieve an access token for
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(pinID: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(pinID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Retrieve a Pin from Plex.tv for authentication flows
         * @summary Get a Pin
         * @param {any} [strong] Determines the kind of code returned by the API call Strong codes are used for Pin authentication flows Non-Strong codes are used for &#x60;Plex.tv/link&#x60; 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPin(strong?: any, axiosOptions?: any): AxiosPromise<GetPin200Response> {
            return localVarFp.getPin(strong, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an Access Token from Plex.tv after the Pin has already been authenticated
         * @summary Get Access Token
         * @param {any} pinID The PinID to retrieve an access token for
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getToken(pinID: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getToken(pinID, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPin operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiGetPinRequest
 */
export interface AuthenticationApiGetPinRequest {
    /**
     * Determines the kind of code returned by the API call Strong codes are used for Pin authentication flows Non-Strong codes are used for &#x60;Plex.tv/link&#x60; 
     * @type {any}
     * @memberof AuthenticationApiGetPin
     */
    readonly strong?: any
}

/**
 * Request parameters for getToken operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiGetTokenRequest
 */
export interface AuthenticationApiGetTokenRequest {
    /**
     * The PinID to retrieve an access token for
     * @type {any}
     * @memberof AuthenticationApiGetToken
     */
    readonly pinID: any
}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Retrieve a Pin from Plex.tv for authentication flows
     * @summary Get a Pin
     * @param {AuthenticationApiGetPinRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getPin(requestParameters: AuthenticationApiGetPinRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getPin(requestParameters.strong, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an Access Token from Plex.tv after the Pin has already been authenticated
     * @summary Get Access Token
     * @param {AuthenticationApiGetTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getToken(requestParameters: AuthenticationApiGetTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getToken(requestParameters.pinID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ButlerApi - axios parameter creator
 * @export
 */
export const ButlerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of butler tasks
         * @summary Get Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getButlerTasks: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/butler`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
         * @summary Start all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAllTasks: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/butler`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
         * @summary Start a single Butler task
         * @param {any} taskName the name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startTask: async (taskName: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskName' is not null or undefined
            assertParamExists('startTask', 'taskName', taskName)
            const localVarPath = `/butler/{taskName}`
                .replace(`{${"taskName"}}`, encodeURIComponent(String(taskName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue. 
         * @summary Stop all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAllTasks: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/butler`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint. 
         * @summary Stop a single Butler task
         * @param {any} taskName The name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopTask: async (taskName: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskName' is not null or undefined
            assertParamExists('stopTask', 'taskName', taskName)
            const localVarPath = `/butler/{taskName}`
                .replace(`{${"taskName"}}`, encodeURIComponent(String(taskName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ButlerApi - functional programming interface
 * @export
 */
export const ButlerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ButlerApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of butler tasks
         * @summary Get Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getButlerTasks(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetButlerTasks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getButlerTasks(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
         * @summary Start all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startAllTasks(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startAllTasks(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
         * @summary Start a single Butler task
         * @param {any} taskName the name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startTask(taskName: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startTask(taskName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue. 
         * @summary Stop all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async stopAllTasks(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopAllTasks(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint. 
         * @summary Stop a single Butler task
         * @param {any} taskName The name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async stopTask(taskName: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopTask(taskName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ButlerApi - factory interface
 * @export
 */
export const ButlerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ButlerApiFp(configuration)
    return {
        /**
         * Returns a list of butler tasks
         * @summary Get Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getButlerTasks(axiosOptions?: any): AxiosPromise<GetButlerTasks200Response> {
            return localVarFp.getButlerTasks(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
         * @summary Start all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAllTasks(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.startAllTasks(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
         * @summary Start a single Butler task
         * @param {any} taskName the name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startTask(taskName: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.startTask(taskName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue. 
         * @summary Stop all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAllTasks(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.stopAllTasks(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint. 
         * @summary Stop a single Butler task
         * @param {any} taskName The name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopTask(taskName: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.stopTask(taskName, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for startTask operation in ButlerApi.
 * @export
 * @interface ButlerApiStartTaskRequest
 */
export interface ButlerApiStartTaskRequest {
    /**
     * the name of the task to be started.
     * @type {any}
     * @memberof ButlerApiStartTask
     */
    readonly taskName: any
}

/**
 * Request parameters for stopTask operation in ButlerApi.
 * @export
 * @interface ButlerApiStopTaskRequest
 */
export interface ButlerApiStopTaskRequest {
    /**
     * The name of the task to be started.
     * @type {any}
     * @memberof ButlerApiStopTask
     */
    readonly taskName: any
}

/**
 * ButlerApi - object-oriented interface
 * @export
 * @class ButlerApi
 * @extends {BaseAPI}
 */
export class ButlerApi extends BaseAPI {
    /**
     * Returns a list of butler tasks
     * @summary Get Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    public getButlerTasks(axiosOptions?: AxiosRequestConfig) {
        return ButlerApiFp(this.configuration).getButlerTasks(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
     * @summary Start all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    public startAllTasks(axiosOptions?: AxiosRequestConfig) {
        return ButlerApiFp(this.configuration).startAllTasks(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
     * @summary Start a single Butler task
     * @param {ButlerApiStartTaskRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    public startTask(requestParameters: ButlerApiStartTaskRequest, axiosOptions?: AxiosRequestConfig) {
        return ButlerApiFp(this.configuration).startTask(requestParameters.taskName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue. 
     * @summary Stop all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    public stopAllTasks(axiosOptions?: AxiosRequestConfig) {
        return ButlerApiFp(this.configuration).stopAllTasks(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint. 
     * @summary Stop a single Butler task
     * @param {ButlerApiStopTaskRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    public stopTask(requestParameters: ButlerApiStopTaskRequest, axiosOptions?: AxiosRequestConfig) {
        return ButlerApiFp(this.configuration).stopTask(requestParameters.taskName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Available Clients
         * @summary Get Available Clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableClients: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get Devices
         * @summary Get Devices
         * @param {any} [includeHttps] Include Https entries in the results
         * @param {any} [includeRelay] Include Relay addresses in the results
         * @param {any} [includeIPv6] Include IPv6 entries in the results
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (includeHttps?: any, includeRelay?: any, includeIPv6?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (includeHttps !== undefined) {
                localVarQueryParameter['includeHttps'] = includeHttps;
            }

            if (includeRelay !== undefined) {
                localVarQueryParameter['includeRelay'] = includeRelay;
            }

            if (includeIPv6 !== undefined) {
                localVarQueryParameter['includeIPv6'] = includeIPv6;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Available Clients
         * @summary Get Available Clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableClients(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableClients(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Devices
         * @summary Get Devices
         * @param {any} [includeHttps] Include Https entries in the results
         * @param {any} [includeRelay] Include Relay addresses in the results
         * @param {any} [includeIPv6] Include IPv6 entries in the results
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(includeHttps?: any, includeRelay?: any, includeIPv6?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevices(includeHttps, includeRelay, includeIPv6, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * Get Available Clients
         * @summary Get Available Clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableClients(axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.getAvailableClients(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get Devices
         * @summary Get Devices
         * @param {any} [includeHttps] Include Https entries in the results
         * @param {any} [includeRelay] Include Relay addresses in the results
         * @param {any} [includeIPv6] Include IPv6 entries in the results
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(includeHttps?: any, includeRelay?: any, includeIPv6?: any, axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.getDevices(includeHttps, includeRelay, includeIPv6, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDevices operation in DevicesApi.
 * @export
 * @interface DevicesApiGetDevicesRequest
 */
export interface DevicesApiGetDevicesRequest {
    /**
     * Include Https entries in the results
     * @type {any}
     * @memberof DevicesApiGetDevices
     */
    readonly includeHttps?: any

    /**
     * Include Relay addresses in the results
     * @type {any}
     * @memberof DevicesApiGetDevices
     */
    readonly includeRelay?: any

    /**
     * Include IPv6 entries in the results
     * @type {any}
     * @memberof DevicesApiGetDevices
     */
    readonly includeIPv6?: any
}

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * Get Available Clients
     * @summary Get Available Clients
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getAvailableClients(axiosOptions?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getAvailableClients(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Devices
     * @summary Get Devices
     * @param {DevicesApiGetDevicesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevices(requestParameters: DevicesApiGetDevicesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevices(requestParameters.includeHttps, requestParameters.includeRelay, requestParameters.includeIPv6, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HashesApi - axios parameter creator
 * @export
 */
export const HashesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This resource returns hash values for local files
         * @summary Get Hash Value
         * @param {any} url This is the path to the local file, must be prefixed by &#x60;file://&#x60;
         * @param {any} [type] Item type
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getFileHash: async (url: any, type?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('getFileHash', 'url', url)
            const localVarPath = `/library/hashes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * HashesApi - functional programming interface
 * @export
 */
export const HashesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HashesApiAxiosParamCreator(configuration)
    return {
        /**
         * This resource returns hash values for local files
         * @summary Get Hash Value
         * @param {any} url This is the path to the local file, must be prefixed by &#x60;file://&#x60;
         * @param {any} [type] Item type
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getFileHash(url: any, type?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileHash(url, type, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HashesApi - factory interface
 * @export
 */
export const HashesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HashesApiFp(configuration)
    return {
        /**
         * This resource returns hash values for local files
         * @summary Get Hash Value
         * @param {any} url This is the path to the local file, must be prefixed by &#x60;file://&#x60;
         * @param {any} [type] Item type
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getFileHash(url: any, type?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getFileHash(url, type, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFileHash operation in HashesApi.
 * @export
 * @interface HashesApiGetFileHashRequest
 */
export interface HashesApiGetFileHashRequest {
    /**
     * This is the path to the local file, must be prefixed by &#x60;file://&#x60;
     * @type {any}
     * @memberof HashesApiGetFileHash
     */
    readonly url: any

    /**
     * Item type
     * @type {any}
     * @memberof HashesApiGetFileHash
     */
    readonly type?: any
}

/**
 * HashesApi - object-oriented interface
 * @export
 * @class HashesApi
 * @extends {BaseAPI}
 */
export class HashesApi extends BaseAPI {
    /**
     * This resource returns hash values for local files
     * @summary Get Hash Value
     * @param {HashesApiGetFileHashRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof HashesApi
     */
    public getFileHash(requestParameters: HashesApiGetFileHashRequest, axiosOptions?: AxiosRequestConfig) {
        return HashesApiFp(this.configuration).getFileHash(requestParameters.url, requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HubsApi - axios parameter creator
 * @export
 */
export const HubsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Global Hubs
         * @param {any} [count] The number of items to return with each hub.
         * @param {any} [onlyTransient] Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalHubs: async (count?: any, onlyTransient?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hubs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (onlyTransient !== undefined) {
                localVarQueryParameter['onlyTransient'] = onlyTransient;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will return a list of library specific hubs 
         * @summary Get library specific hubs
         * @param {any} sectionId the Id of the library to query
         * @param {any} [count] The number of items to return with each hub.
         * @param {any} [onlyTransient] Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryHubs: async (sectionId: any, count?: any, onlyTransient?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('getLibraryHubs', 'sectionId', sectionId)
            const localVarPath = `/hubs/sections/{sectionId}`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (onlyTransient !== undefined) {
                localVarQueryParameter['onlyTransient'] = onlyTransient;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * HubsApi - functional programming interface
 * @export
 */
export const HubsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HubsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Global Hubs
         * @param {any} [count] The number of items to return with each hub.
         * @param {any} [onlyTransient] Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobalHubs(count?: any, onlyTransient?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGlobalHubs(count, onlyTransient, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will return a list of library specific hubs 
         * @summary Get library specific hubs
         * @param {any} sectionId the Id of the library to query
         * @param {any} [count] The number of items to return with each hub.
         * @param {any} [onlyTransient] Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryHubs(sectionId: any, count?: any, onlyTransient?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryHubs(sectionId, count, onlyTransient, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HubsApi - factory interface
 * @export
 */
export const HubsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HubsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Global Hubs
         * @param {any} [count] The number of items to return with each hub.
         * @param {any} [onlyTransient] Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalHubs(count?: any, onlyTransient?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getGlobalHubs(count, onlyTransient, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return a list of library specific hubs 
         * @summary Get library specific hubs
         * @param {any} sectionId the Id of the library to query
         * @param {any} [count] The number of items to return with each hub.
         * @param {any} [onlyTransient] Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryHubs(sectionId: any, count?: any, onlyTransient?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getLibraryHubs(sectionId, count, onlyTransient, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getGlobalHubs operation in HubsApi.
 * @export
 * @interface HubsApiGetGlobalHubsRequest
 */
export interface HubsApiGetGlobalHubsRequest {
    /**
     * The number of items to return with each hub.
     * @type {any}
     * @memberof HubsApiGetGlobalHubs
     */
    readonly count?: any

    /**
     * Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
     * @type {any}
     * @memberof HubsApiGetGlobalHubs
     */
    readonly onlyTransient?: any
}

/**
 * Request parameters for getLibraryHubs operation in HubsApi.
 * @export
 * @interface HubsApiGetLibraryHubsRequest
 */
export interface HubsApiGetLibraryHubsRequest {
    /**
     * the Id of the library to query
     * @type {any}
     * @memberof HubsApiGetLibraryHubs
     */
    readonly sectionId: any

    /**
     * The number of items to return with each hub.
     * @type {any}
     * @memberof HubsApiGetLibraryHubs
     */
    readonly count?: any

    /**
     * Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
     * @type {any}
     * @memberof HubsApiGetLibraryHubs
     */
    readonly onlyTransient?: any
}

/**
 * HubsApi - object-oriented interface
 * @export
 * @class HubsApi
 * @extends {BaseAPI}
 */
export class HubsApi extends BaseAPI {
    /**
     * 
     * @summary Get Global Hubs
     * @param {HubsApiGetGlobalHubsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof HubsApi
     */
    public getGlobalHubs(requestParameters: HubsApiGetGlobalHubsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return HubsApiFp(this.configuration).getGlobalHubs(requestParameters.count, requestParameters.onlyTransient, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will return a list of library specific hubs 
     * @summary Get library specific hubs
     * @param {HubsApiGetLibraryHubsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof HubsApi
     */
    public getLibraryHubs(requestParameters: HubsApiGetLibraryHubsRequest, axiosOptions?: AxiosRequestConfig) {
        return HubsApiFp(this.configuration).getLibraryHubs(requestParameters.sectionId, requestParameters.count, requestParameters.onlyTransient, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LibraryApi - axios parameter creator
 * @export
 */
export const LibraryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Represents a \"Common\" item. It contains only the common attributes of the items selected by the provided filter 
         * @summary Get Common Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} type item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCommonLibraryItems: async (sectionId: any, type: any, filter?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('getCommonLibraryItems', 'sectionId', sectionId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getCommonLibraryItems', 'type', type)
            const localVarPath = `/library/sections/{sectionId}/common`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will return a list of the latest library items filtered by the filter and type provided 
         * @summary Get Latest Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} type item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLatestLibraryItems: async (sectionId: any, type: any, filter?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('getLatestLibraryItems', 'sectionId', sectionId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getLatestLibraryItems', 'type', type)
            const localVarPath = `/library/sections/{sectionId}/latest`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * A library section (commonly referred to as just a library) is a collection of media.  Libraries are typed, and depending on their type provide either a flat or a hierarchical view of the media.  For example, a music library has an artist > albums > tracks structure, whereas a movie library is flat.  Libraries have features beyond just being a collection of media; for starters, they include information about supported types, filters and sorts.  This allows a client to provide a rich interface around the media (e.g. allow sorting movies by release year). 
         * @summary Get All Libraries
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraries: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/library/sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Returns details for the library. This can be thought of as an interstitial endpoint because it contains information about the library, rather than content itself. These details are:  - A list of `Directory` objects: These used to be used by clients to build a menuing system. There are four flavors of directory found here:   - Primary: (e.g. all, On Deck) These are still used in some clients to provide \"shortcuts\" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.   - Secondary: These are marked with `secondary=\"1\"` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there\'s a completely obsolete entry marked `search=\"1\"` which used to be used to allow clients to build search dialogs on the fly. - A list of `Type` objects: These represent the types of things found in this library, and for each one, a list of `Filter` and `Sort` objects. These can be used to build rich controls around a grid of media to allow filtering and organizing. Note that these filters and sorts are optional, and without them, the client won\'t render any filtering controls. The `Type` object contains:   - `key`: This provides the root endpoint returning the actual media list for the type.   - `type`: This is the metadata type for the type (if a standard Plex type).   - `title`: The title for for the content of this type (e.g. \"Movies\"). - Each `Filter` object contains a description of the filter. Note that it is not an exhaustive list of the full media query language, but an inportant subset useful for top-level API.   - `filter`: This represents the filter name used for the filter, which can be used to construct complex media queries with.   - `filterType`: This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.   - `key`: This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a \"Genre\" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.   - `title`: The title for the filter. - Each `Sort` object contains a description of the sort field.   - `defaultDirection`: Can be either `asc` or `desc`, and specifies the default direction for the sort field (e.g. titles default to alphabetically ascending).   - `descKey` and `key`: Contains the parameters passed to the `sort=...` media query for each direction of the sort.   - `title`: The title of the field. 
         * @summary Get Library Details
         * @param {any} sectionId the Id of the library to query
         * @param {any} [includeDetails] Whether or not to include details for a section (types, filters, and sorts).  Only exists for backwards compatibility, media providers other than the server libraries have it on always. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryDetails: async (sectionId: any, includeDetails?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('getLibraryDetails', 'sectionId', sectionId)
            const localVarPath = `/library/sections/{sectionId}`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (includeDetails !== undefined) {
                localVarQueryParameter['includeDetails'] = includeDetails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will return a list of library items filtered by the filter and type provided 
         * @summary Get Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} [type] item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItems: async (sectionId: any, type?: any, filter?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('getLibraryItems', 'sectionId', sectionId)
            const localVarPath = `/library/sections/{sectionId}/all`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will return the on deck content. 
         * @summary Get On Deck
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOnDeck: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/library/onDeck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will return the recently added content. 
         * @summary Get Recently Added
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyAdded: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/library/recentlyAdded`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint Refreshes the library. 
         * @summary Refresh Library
         * @param {any} sectionId the Id of the library to refresh
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary: async (sectionId: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('refreshLibrary', 'sectionId', sectionId)
            const localVarPath = `/library/sections/{sectionId}/refresh`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryApi - functional programming interface
 * @export
 */
export const LibraryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LibraryApiAxiosParamCreator(configuration)
    return {
        /**
         * Represents a \"Common\" item. It contains only the common attributes of the items selected by the provided filter 
         * @summary Get Common Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} type item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getCommonLibraryItems(sectionId: any, type: any, filter?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommonLibraryItems(sectionId, type, filter, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will return a list of the latest library items filtered by the filter and type provided 
         * @summary Get Latest Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} type item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestLibraryItems(sectionId: any, type: any, filter?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestLibraryItems(sectionId, type, filter, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A library section (commonly referred to as just a library) is a collection of media.  Libraries are typed, and depending on their type provide either a flat or a hierarchical view of the media.  For example, a music library has an artist > albums > tracks structure, whereas a movie library is flat.  Libraries have features beyond just being a collection of media; for starters, they include information about supported types, filters and sorts.  This allows a client to provide a rich interface around the media (e.g. allow sorting movies by release year). 
         * @summary Get All Libraries
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraries(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraries(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns details for the library. This can be thought of as an interstitial endpoint because it contains information about the library, rather than content itself. These details are:  - A list of `Directory` objects: These used to be used by clients to build a menuing system. There are four flavors of directory found here:   - Primary: (e.g. all, On Deck) These are still used in some clients to provide \"shortcuts\" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.   - Secondary: These are marked with `secondary=\"1\"` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there\'s a completely obsolete entry marked `search=\"1\"` which used to be used to allow clients to build search dialogs on the fly. - A list of `Type` objects: These represent the types of things found in this library, and for each one, a list of `Filter` and `Sort` objects. These can be used to build rich controls around a grid of media to allow filtering and organizing. Note that these filters and sorts are optional, and without them, the client won\'t render any filtering controls. The `Type` object contains:   - `key`: This provides the root endpoint returning the actual media list for the type.   - `type`: This is the metadata type for the type (if a standard Plex type).   - `title`: The title for for the content of this type (e.g. \"Movies\"). - Each `Filter` object contains a description of the filter. Note that it is not an exhaustive list of the full media query language, but an inportant subset useful for top-level API.   - `filter`: This represents the filter name used for the filter, which can be used to construct complex media queries with.   - `filterType`: This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.   - `key`: This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a \"Genre\" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.   - `title`: The title for the filter. - Each `Sort` object contains a description of the sort field.   - `defaultDirection`: Can be either `asc` or `desc`, and specifies the default direction for the sort field (e.g. titles default to alphabetically ascending).   - `descKey` and `key`: Contains the parameters passed to the `sort=...` media query for each direction of the sort.   - `title`: The title of the field. 
         * @summary Get Library Details
         * @param {any} sectionId the Id of the library to query
         * @param {any} [includeDetails] Whether or not to include details for a section (types, filters, and sorts).  Only exists for backwards compatibility, media providers other than the server libraries have it on always. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryDetails(sectionId: any, includeDetails?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryDetails(sectionId, includeDetails, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will return a list of library items filtered by the filter and type provided 
         * @summary Get Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} [type] item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryItems(sectionId: any, type?: any, filter?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryItems(sectionId, type, filter, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will return the on deck content. 
         * @summary Get On Deck
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getOnDeck(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOnDeck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOnDeck(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will return the recently added content. 
         * @summary Get Recently Added
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentlyAdded(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecentlyAdded200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentlyAdded(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint Refreshes the library. 
         * @summary Refresh Library
         * @param {any} sectionId the Id of the library to refresh
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async refreshLibrary(sectionId: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshLibrary(sectionId, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LibraryApi - factory interface
 * @export
 */
export const LibraryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LibraryApiFp(configuration)
    return {
        /**
         * Represents a \"Common\" item. It contains only the common attributes of the items selected by the provided filter 
         * @summary Get Common Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} type item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCommonLibraryItems(sectionId: any, type: any, filter?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getCommonLibraryItems(sectionId, type, filter, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return a list of the latest library items filtered by the filter and type provided 
         * @summary Get Latest Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} type item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLatestLibraryItems(sectionId: any, type: any, filter?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getLatestLibraryItems(sectionId, type, filter, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * A library section (commonly referred to as just a library) is a collection of media.  Libraries are typed, and depending on their type provide either a flat or a hierarchical view of the media.  For example, a music library has an artist > albums > tracks structure, whereas a movie library is flat.  Libraries have features beyond just being a collection of media; for starters, they include information about supported types, filters and sorts.  This allows a client to provide a rich interface around the media (e.g. allow sorting movies by release year). 
         * @summary Get All Libraries
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraries(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getLibraries(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Returns details for the library. This can be thought of as an interstitial endpoint because it contains information about the library, rather than content itself. These details are:  - A list of `Directory` objects: These used to be used by clients to build a menuing system. There are four flavors of directory found here:   - Primary: (e.g. all, On Deck) These are still used in some clients to provide \"shortcuts\" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.   - Secondary: These are marked with `secondary=\"1\"` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there\'s a completely obsolete entry marked `search=\"1\"` which used to be used to allow clients to build search dialogs on the fly. - A list of `Type` objects: These represent the types of things found in this library, and for each one, a list of `Filter` and `Sort` objects. These can be used to build rich controls around a grid of media to allow filtering and organizing. Note that these filters and sorts are optional, and without them, the client won\'t render any filtering controls. The `Type` object contains:   - `key`: This provides the root endpoint returning the actual media list for the type.   - `type`: This is the metadata type for the type (if a standard Plex type).   - `title`: The title for for the content of this type (e.g. \"Movies\"). - Each `Filter` object contains a description of the filter. Note that it is not an exhaustive list of the full media query language, but an inportant subset useful for top-level API.   - `filter`: This represents the filter name used for the filter, which can be used to construct complex media queries with.   - `filterType`: This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.   - `key`: This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a \"Genre\" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.   - `title`: The title for the filter. - Each `Sort` object contains a description of the sort field.   - `defaultDirection`: Can be either `asc` or `desc`, and specifies the default direction for the sort field (e.g. titles default to alphabetically ascending).   - `descKey` and `key`: Contains the parameters passed to the `sort=...` media query for each direction of the sort.   - `title`: The title of the field. 
         * @summary Get Library Details
         * @param {any} sectionId the Id of the library to query
         * @param {any} [includeDetails] Whether or not to include details for a section (types, filters, and sorts).  Only exists for backwards compatibility, media providers other than the server libraries have it on always. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryDetails(sectionId: any, includeDetails?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getLibraryDetails(sectionId, includeDetails, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return a list of library items filtered by the filter and type provided 
         * @summary Get Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} [type] item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItems(sectionId: any, type?: any, filter?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getLibraryItems(sectionId, type, filter, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return the on deck content. 
         * @summary Get On Deck
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOnDeck(axiosOptions?: any): AxiosPromise<GetOnDeck200Response> {
            return localVarFp.getOnDeck(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return the recently added content. 
         * @summary Get Recently Added
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getRecentlyAdded(axiosOptions?: any): AxiosPromise<GetRecentlyAdded200Response> {
            return localVarFp.getRecentlyAdded(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint Refreshes the library. 
         * @summary Refresh Library
         * @param {any} sectionId the Id of the library to refresh
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary(sectionId: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.refreshLibrary(sectionId, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCommonLibraryItems operation in LibraryApi.
 * @export
 * @interface LibraryApiGetCommonLibraryItemsRequest
 */
export interface LibraryApiGetCommonLibraryItemsRequest {
    /**
     * the Id of the library to query
     * @type {any}
     * @memberof LibraryApiGetCommonLibraryItems
     */
    readonly sectionId: any

    /**
     * item type
     * @type {any}
     * @memberof LibraryApiGetCommonLibraryItems
     */
    readonly type: any

    /**
     * the filter parameter
     * @type {any}
     * @memberof LibraryApiGetCommonLibraryItems
     */
    readonly filter?: any
}

/**
 * Request parameters for getLatestLibraryItems operation in LibraryApi.
 * @export
 * @interface LibraryApiGetLatestLibraryItemsRequest
 */
export interface LibraryApiGetLatestLibraryItemsRequest {
    /**
     * the Id of the library to query
     * @type {any}
     * @memberof LibraryApiGetLatestLibraryItems
     */
    readonly sectionId: any

    /**
     * item type
     * @type {any}
     * @memberof LibraryApiGetLatestLibraryItems
     */
    readonly type: any

    /**
     * the filter parameter
     * @type {any}
     * @memberof LibraryApiGetLatestLibraryItems
     */
    readonly filter?: any
}

/**
 * Request parameters for getLibraryDetails operation in LibraryApi.
 * @export
 * @interface LibraryApiGetLibraryDetailsRequest
 */
export interface LibraryApiGetLibraryDetailsRequest {
    /**
     * the Id of the library to query
     * @type {any}
     * @memberof LibraryApiGetLibraryDetails
     */
    readonly sectionId: any

    /**
     * Whether or not to include details for a section (types, filters, and sorts).  Only exists for backwards compatibility, media providers other than the server libraries have it on always. 
     * @type {any}
     * @memberof LibraryApiGetLibraryDetails
     */
    readonly includeDetails?: any
}

/**
 * Request parameters for getLibraryItems operation in LibraryApi.
 * @export
 * @interface LibraryApiGetLibraryItemsRequest
 */
export interface LibraryApiGetLibraryItemsRequest {
    /**
     * the Id of the library to query
     * @type {any}
     * @memberof LibraryApiGetLibraryItems
     */
    readonly sectionId: any

    /**
     * item type
     * @type {any}
     * @memberof LibraryApiGetLibraryItems
     */
    readonly type?: any

    /**
     * the filter parameter
     * @type {any}
     * @memberof LibraryApiGetLibraryItems
     */
    readonly filter?: any
}

/**
 * Request parameters for refreshLibrary operation in LibraryApi.
 * @export
 * @interface LibraryApiRefreshLibraryRequest
 */
export interface LibraryApiRefreshLibraryRequest {
    /**
     * the Id of the library to refresh
     * @type {any}
     * @memberof LibraryApiRefreshLibrary
     */
    readonly sectionId: any
}

/**
 * LibraryApi - object-oriented interface
 * @export
 * @class LibraryApi
 * @extends {BaseAPI}
 */
export class LibraryApi extends BaseAPI {
    /**
     * Represents a \"Common\" item. It contains only the common attributes of the items selected by the provided filter 
     * @summary Get Common Library Items
     * @param {LibraryApiGetCommonLibraryItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getCommonLibraryItems(requestParameters: LibraryApiGetCommonLibraryItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getCommonLibraryItems(requestParameters.sectionId, requestParameters.type, requestParameters.filter, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will return a list of the latest library items filtered by the filter and type provided 
     * @summary Get Latest Library Items
     * @param {LibraryApiGetLatestLibraryItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLatestLibraryItems(requestParameters: LibraryApiGetLatestLibraryItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getLatestLibraryItems(requestParameters.sectionId, requestParameters.type, requestParameters.filter, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A library section (commonly referred to as just a library) is a collection of media.  Libraries are typed, and depending on their type provide either a flat or a hierarchical view of the media.  For example, a music library has an artist > albums > tracks structure, whereas a movie library is flat.  Libraries have features beyond just being a collection of media; for starters, they include information about supported types, filters and sorts.  This allows a client to provide a rich interface around the media (e.g. allow sorting movies by release year). 
     * @summary Get All Libraries
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraries(axiosOptions?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getLibraries(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details for the library. This can be thought of as an interstitial endpoint because it contains information about the library, rather than content itself. These details are:  - A list of `Directory` objects: These used to be used by clients to build a menuing system. There are four flavors of directory found here:   - Primary: (e.g. all, On Deck) These are still used in some clients to provide \"shortcuts\" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.   - Secondary: These are marked with `secondary=\"1\"` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there\'s a completely obsolete entry marked `search=\"1\"` which used to be used to allow clients to build search dialogs on the fly. - A list of `Type` objects: These represent the types of things found in this library, and for each one, a list of `Filter` and `Sort` objects. These can be used to build rich controls around a grid of media to allow filtering and organizing. Note that these filters and sorts are optional, and without them, the client won\'t render any filtering controls. The `Type` object contains:   - `key`: This provides the root endpoint returning the actual media list for the type.   - `type`: This is the metadata type for the type (if a standard Plex type).   - `title`: The title for for the content of this type (e.g. \"Movies\"). - Each `Filter` object contains a description of the filter. Note that it is not an exhaustive list of the full media query language, but an inportant subset useful for top-level API.   - `filter`: This represents the filter name used for the filter, which can be used to construct complex media queries with.   - `filterType`: This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.   - `key`: This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a \"Genre\" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.   - `title`: The title for the filter. - Each `Sort` object contains a description of the sort field.   - `defaultDirection`: Can be either `asc` or `desc`, and specifies the default direction for the sort field (e.g. titles default to alphabetically ascending).   - `descKey` and `key`: Contains the parameters passed to the `sort=...` media query for each direction of the sort.   - `title`: The title of the field. 
     * @summary Get Library Details
     * @param {LibraryApiGetLibraryDetailsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraryDetails(requestParameters: LibraryApiGetLibraryDetailsRequest, axiosOptions?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getLibraryDetails(requestParameters.sectionId, requestParameters.includeDetails, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will return a list of library items filtered by the filter and type provided 
     * @summary Get Library Items
     * @param {LibraryApiGetLibraryItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraryItems(requestParameters: LibraryApiGetLibraryItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getLibraryItems(requestParameters.sectionId, requestParameters.type, requestParameters.filter, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will return the on deck content. 
     * @summary Get On Deck
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getOnDeck(axiosOptions?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getOnDeck(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will return the recently added content. 
     * @summary Get Recently Added
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getRecentlyAdded(axiosOptions?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getRecentlyAdded(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint Refreshes the library. 
     * @summary Refresh Library
     * @param {LibraryApiRefreshLibraryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public refreshLibrary(requestParameters: LibraryApiRefreshLibraryRequest, axiosOptions?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).refreshLibrary(requestParameters.sectionId, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LogApi - axios parameter creator
 * @export
 */
export const LogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time. 
         * @summary Enabling Papertrail
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enablePaperTrail: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log/networked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log. 
         * @summary Logging a single line message.
         * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose 
         * @param {any} message The text of the message to write to the log.
         * @param {any} source a string indicating the source of the message.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logLine: async (level: any, message: any, source: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'level' is not null or undefined
            assertParamExists('logLine', 'level', level)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('logLine', 'message', message)
            // verify required parameter 'source' is not null or undefined
            assertParamExists('logLine', 'source', source)
            const localVarPath = `/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above. 
         * @summary Logging a multi-line message
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logMultiLine: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogApi - functional programming interface
 * @export
 */
export const LogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time. 
         * @summary Enabling Papertrail
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async enablePaperTrail(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enablePaperTrail(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log. 
         * @summary Logging a single line message.
         * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose 
         * @param {any} message The text of the message to write to the log.
         * @param {any} source a string indicating the source of the message.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async logLine(level: any, message: any, source: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logLine(level, message, source, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above. 
         * @summary Logging a multi-line message
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async logMultiLine(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logMultiLine(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LogApi - factory interface
 * @export
 */
export const LogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogApiFp(configuration)
    return {
        /**
         * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time. 
         * @summary Enabling Papertrail
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enablePaperTrail(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.enablePaperTrail(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log. 
         * @summary Logging a single line message.
         * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose 
         * @param {any} message The text of the message to write to the log.
         * @param {any} source a string indicating the source of the message.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logLine(level: any, message: any, source: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.logLine(level, message, source, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above. 
         * @summary Logging a multi-line message
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logMultiLine(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.logMultiLine(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for logLine operation in LogApi.
 * @export
 * @interface LogApiLogLineRequest
 */
export interface LogApiLogLineRequest {
    /**
     * An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose 
     * @type {any}
     * @memberof LogApiLogLine
     */
    readonly level: any

    /**
     * The text of the message to write to the log.
     * @type {any}
     * @memberof LogApiLogLine
     */
    readonly message: any

    /**
     * a string indicating the source of the message.
     * @type {any}
     * @memberof LogApiLogLine
     */
    readonly source: any
}

/**
 * LogApi - object-oriented interface
 * @export
 * @class LogApi
 * @extends {BaseAPI}
 */
export class LogApi extends BaseAPI {
    /**
     * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time. 
     * @summary Enabling Papertrail
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public enablePaperTrail(axiosOptions?: AxiosRequestConfig) {
        return LogApiFp(this.configuration).enablePaperTrail(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log. 
     * @summary Logging a single line message.
     * @param {LogApiLogLineRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logLine(requestParameters: LogApiLogLineRequest, axiosOptions?: AxiosRequestConfig) {
        return LogApiFp(this.configuration).logLine(requestParameters.level, requestParameters.message, requestParameters.source, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above. 
     * @summary Logging a multi-line message
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logMultiLine(axiosOptions?: AxiosRequestConfig) {
        return LogApiFp(this.configuration).logMultiLine(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MyPlexApi - axios parameter creator
 * @export
 */
export const MyPlexApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns MyPlex Account Information
         * @summary Get MyPlex Account
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMyPlexAccount: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/myplex/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * MyPlexApi - functional programming interface
 * @export
 */
export const MyPlexApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MyPlexApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns MyPlex Account Information
         * @summary Get MyPlex Account
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getMyPlexAccount(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMyPlexAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyPlexAccount(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MyPlexApi - factory interface
 * @export
 */
export const MyPlexApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MyPlexApiFp(configuration)
    return {
        /**
         * Returns MyPlex Account Information
         * @summary Get MyPlex Account
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getMyPlexAccount(axiosOptions?: any): AxiosPromise<GetMyPlexAccount200Response> {
            return localVarFp.getMyPlexAccount(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MyPlexApi - object-oriented interface
 * @export
 * @class MyPlexApi
 * @extends {BaseAPI}
 */
export class MyPlexApi extends BaseAPI {
    /**
     * Returns MyPlex Account Information
     * @summary Get MyPlex Account
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof MyPlexApi
     */
    public getMyPlexAccount(axiosOptions?: AxiosRequestConfig) {
        return MyPlexApiFp(this.configuration).getMyPlexAccount(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PhotosApi - axios parameter creator
 * @export
 */
export const PhotosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Plex\'s Photo transcoder is used throughout the service to serve images at specified sizes. 
         * @summary Get a Resized Photo
         * @param {any} width The width for the resized photo
         * @param {any} height The height for the resized photo
         * @param {any} opacity The opacity for the resized photo
         * @param {any} blur The width for the resized photo
         * @param {any} minSize images are always scaled proportionally. A value of \&#39;1\&#39; in minSize will make the smaller native dimension the dimension resized against.
         * @param {any} upscale allow images to be resized beyond native dimensions.
         * @param {any} url path to image within Plex
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getResizedPhoto: async (width: any, height: any, opacity: any, blur: any, minSize: any, upscale: any, url: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'width' is not null or undefined
            assertParamExists('getResizedPhoto', 'width', width)
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getResizedPhoto', 'height', height)
            // verify required parameter 'opacity' is not null or undefined
            assertParamExists('getResizedPhoto', 'opacity', opacity)
            // verify required parameter 'blur' is not null or undefined
            assertParamExists('getResizedPhoto', 'blur', blur)
            // verify required parameter 'minSize' is not null or undefined
            assertParamExists('getResizedPhoto', 'minSize', minSize)
            // verify required parameter 'upscale' is not null or undefined
            assertParamExists('getResizedPhoto', 'upscale', upscale)
            // verify required parameter 'url' is not null or undefined
            assertParamExists('getResizedPhoto', 'url', url)
            const localVarPath = `/photo/:/transcode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (opacity !== undefined) {
                localVarQueryParameter['opacity'] = opacity;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (minSize !== undefined) {
                localVarQueryParameter['minSize'] = minSize;
            }

            if (upscale !== undefined) {
                localVarQueryParameter['upscale'] = upscale;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhotosApi - functional programming interface
 * @export
 */
export const PhotosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhotosApiAxiosParamCreator(configuration)
    return {
        /**
         * Plex\'s Photo transcoder is used throughout the service to serve images at specified sizes. 
         * @summary Get a Resized Photo
         * @param {any} width The width for the resized photo
         * @param {any} height The height for the resized photo
         * @param {any} opacity The opacity for the resized photo
         * @param {any} blur The width for the resized photo
         * @param {any} minSize images are always scaled proportionally. A value of \&#39;1\&#39; in minSize will make the smaller native dimension the dimension resized against.
         * @param {any} upscale allow images to be resized beyond native dimensions.
         * @param {any} url path to image within Plex
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getResizedPhoto(width: any, height: any, opacity: any, blur: any, minSize: any, upscale: any, url: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResizedPhoto(width, height, opacity, blur, minSize, upscale, url, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PhotosApi - factory interface
 * @export
 */
export const PhotosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhotosApiFp(configuration)
    return {
        /**
         * Plex\'s Photo transcoder is used throughout the service to serve images at specified sizes. 
         * @summary Get a Resized Photo
         * @param {any} width The width for the resized photo
         * @param {any} height The height for the resized photo
         * @param {any} opacity The opacity for the resized photo
         * @param {any} blur The width for the resized photo
         * @param {any} minSize images are always scaled proportionally. A value of \&#39;1\&#39; in minSize will make the smaller native dimension the dimension resized against.
         * @param {any} upscale allow images to be resized beyond native dimensions.
         * @param {any} url path to image within Plex
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getResizedPhoto(width: any, height: any, opacity: any, blur: any, minSize: any, upscale: any, url: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getResizedPhoto(width, height, opacity, blur, minSize, upscale, url, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getResizedPhoto operation in PhotosApi.
 * @export
 * @interface PhotosApiGetResizedPhotoRequest
 */
export interface PhotosApiGetResizedPhotoRequest {
    /**
     * The width for the resized photo
     * @type {any}
     * @memberof PhotosApiGetResizedPhoto
     */
    readonly width: any

    /**
     * The height for the resized photo
     * @type {any}
     * @memberof PhotosApiGetResizedPhoto
     */
    readonly height: any

    /**
     * The opacity for the resized photo
     * @type {any}
     * @memberof PhotosApiGetResizedPhoto
     */
    readonly opacity: any

    /**
     * The width for the resized photo
     * @type {any}
     * @memberof PhotosApiGetResizedPhoto
     */
    readonly blur: any

    /**
     * images are always scaled proportionally. A value of \&#39;1\&#39; in minSize will make the smaller native dimension the dimension resized against.
     * @type {any}
     * @memberof PhotosApiGetResizedPhoto
     */
    readonly minSize: any

    /**
     * allow images to be resized beyond native dimensions.
     * @type {any}
     * @memberof PhotosApiGetResizedPhoto
     */
    readonly upscale: any

    /**
     * path to image within Plex
     * @type {any}
     * @memberof PhotosApiGetResizedPhoto
     */
    readonly url: any
}

/**
 * PhotosApi - object-oriented interface
 * @export
 * @class PhotosApi
 * @extends {BaseAPI}
 */
export class PhotosApi extends BaseAPI {
    /**
     * Plex\'s Photo transcoder is used throughout the service to serve images at specified sizes. 
     * @summary Get a Resized Photo
     * @param {PhotosApiGetResizedPhotoRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public getResizedPhoto(requestParameters: PhotosApiGetResizedPhotoRequest, axiosOptions?: AxiosRequestConfig) {
        return PhotosApiFp(this.configuration).getResizedPhoto(requestParameters.width, requestParameters.height, requestParameters.opacity, requestParameters.blur, requestParameters.minSize, requestParameters.upscale, requestParameters.url, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlaylistsApi - axios parameter creator
 * @export
 */
export const PlaylistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a generator to a playlist, same parameters as the POST above. With a dumb playlist, this adds the specified items to the playlist.  With a smart playlist, passing a new `uri` parameter replaces the rules for the playlist. Returns the playlist. 
         * @summary Adding to a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {any} uri the content URI for the playlist
         * @param {any} playQueueID the play queue to add to a playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addPlaylistContents: async (playlistID: any, uri: any, playQueueID: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistID' is not null or undefined
            assertParamExists('addPlaylistContents', 'playlistID', playlistID)
            // verify required parameter 'uri' is not null or undefined
            assertParamExists('addPlaylistContents', 'uri', uri)
            // verify required parameter 'playQueueID' is not null or undefined
            assertParamExists('addPlaylistContents', 'playQueueID', playQueueID)
            const localVarPath = `/playlists/{playlistID}/items`
                .replace(`{${"playlistID"}}`, encodeURIComponent(String(playlistID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (uri !== undefined) {
                localVarQueryParameter['uri'] = uri;
            }

            if (playQueueID !== undefined) {
                localVarQueryParameter['playQueueID'] = playQueueID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Clears a playlist, only works with dumb playlists. Returns the playlist. 
         * @summary Delete Playlist Contents
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        clearPlaylistContents: async (playlistID: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistID' is not null or undefined
            assertParamExists('clearPlaylistContents', 'playlistID', playlistID)
            const localVarPath = `/playlists/{playlistID}/items`
                .replace(`{${"playlistID"}}`, encodeURIComponent(String(playlistID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Create a new playlist. By default the playlist is blank. To create a playlist along with a first item, pass: - `uri` - The content URI for what we\'re playing (e.g. `library://...`). - `playQueueID` - To create a playlist from an existing play queue. 
         * @summary Create a Playlist
         * @param {any} title name of the playlist
         * @param {any} type type of playlist to create
         * @param {any} smart whether the playlist is smart or not
         * @param {any} [uri] the content URI for the playlist
         * @param {any} [playQueueID] the play queue to copy to a playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist: async (title: any, type: any, smart: any, uri?: any, playQueueID?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'title' is not null or undefined
            assertParamExists('createPlaylist', 'title', title)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createPlaylist', 'type', type)
            // verify required parameter 'smart' is not null or undefined
            assertParamExists('createPlaylist', 'smart', smart)
            const localVarPath = `/playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (smart !== undefined) {
                localVarQueryParameter['smart'] = smart;
            }

            if (uri !== undefined) {
                localVarQueryParameter['uri'] = uri;
            }

            if (playQueueID !== undefined) {
                localVarQueryParameter['playQueueID'] = playQueueID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will delete a playlist 
         * @summary Deletes a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist: async (playlistID: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistID' is not null or undefined
            assertParamExists('deletePlaylist', 'playlistID', playlistID)
            const localVarPath = `/playlists/{playlistID}`
                .replace(`{${"playlistID"}}`, encodeURIComponent(String(playlistID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets detailed metadata for a playlist. A playlist for many purposes (rating, editing metadata, tagging), can be treated like a regular metadata item: Smart playlist details contain the `content` attribute. This is the content URI for the generator. This can then be parsed by a client to provide smart playlist editing. 
         * @summary Retrieve Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist: async (playlistID: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistID' is not null or undefined
            assertParamExists('getPlaylist', 'playlistID', playlistID)
            const localVarPath = `/playlists/{playlistID}`
                .replace(`{${"playlistID"}}`, encodeURIComponent(String(playlistID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Gets the contents of a playlist. Should be paged by clients via standard mechanisms.  By default leaves are returned (e.g. episodes, movies). In order to return other types you can use the `type` parameter.  For example, you could use this to display a list of recently added albums vis a smart playlist.  Note that for dumb playlists, items have a `playlistItemID` attribute which is used for deleting or moving items. 
         * @summary Retrieve Playlist Contents
         * @param {any} playlistID the ID of the playlist
         * @param {any} type the metadata type of the item to return
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistContents: async (playlistID: any, type: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistID' is not null or undefined
            assertParamExists('getPlaylistContents', 'playlistID', playlistID)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getPlaylistContents', 'type', type)
            const localVarPath = `/playlists/{playlistID}/items`
                .replace(`{${"playlistID"}}`, encodeURIComponent(String(playlistID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Playlists
         * @param {any} [playlistType] limit to a type of playlist.
         * @param {any} [smart] type of playlists to return (default is all).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylists: async (playlistType?: any, smart?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/playlists/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (playlistType !== undefined) {
                localVarQueryParameter['playlistType'] = playlistType;
            }

            if (smart !== undefined) {
                localVarQueryParameter['smart'] = smart;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * From PMS version 1.9.1 clients can also edit playlist metadata using this endpoint as they would via `PUT /library/metadata/{playlistID}` 
         * @summary Update a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylist: async (playlistID: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistID' is not null or undefined
            assertParamExists('updatePlaylist', 'playlistID', playlistID)
            const localVarPath = `/playlists/{playlistID}`
                .replace(`{${"playlistID"}}`, encodeURIComponent(String(playlistID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Imports m3u playlists by passing a path on the server to scan for m3u-formatted playlist files, or a path to a single playlist file. 
         * @summary Upload Playlist
         * @param {any} path absolute path to a directory on the server where m3u files are stored, or the absolute path to a playlist file on the server.  If the &#x60;path&#x60; argument is a directory, that path will be scanned for playlist files to be processed.  Each file in that directory creates a separate playlist, with a name based on the filename of the file that created it.  The GUID of each playlist is based on the filename.  If the &#x60;path&#x60; argument is a file, that file will be used to create a new playlist, with the name based on the filename of the file that created it.  The GUID of each playlist is based on the filename. 
         * @param {any} force force overwriting of duplicate playlists. By default, a playlist file uploaded with the same path will overwrite the existing playlist.  The &#x60;force&#x60; argument is used to disable overwriting. If the &#x60;force&#x60; argument is set to 0, a new playlist will be created suffixed with the date and time that the duplicate was uploaded. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        uploadPlaylist: async (path: any, force: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('uploadPlaylist', 'path', path)
            // verify required parameter 'force' is not null or undefined
            assertParamExists('uploadPlaylist', 'force', force)
            const localVarPath = `/playlists/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistsApi - functional programming interface
 * @export
 */
export const PlaylistsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a generator to a playlist, same parameters as the POST above. With a dumb playlist, this adds the specified items to the playlist.  With a smart playlist, passing a new `uri` parameter replaces the rules for the playlist. Returns the playlist. 
         * @summary Adding to a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {any} uri the content URI for the playlist
         * @param {any} playQueueID the play queue to add to a playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async addPlaylistContents(playlistID: any, uri: any, playQueueID: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPlaylistContents(playlistID, uri, playQueueID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Clears a playlist, only works with dumb playlists. Returns the playlist. 
         * @summary Delete Playlist Contents
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async clearPlaylistContents(playlistID: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearPlaylistContents(playlistID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new playlist. By default the playlist is blank. To create a playlist along with a first item, pass: - `uri` - The content URI for what we\'re playing (e.g. `library://...`). - `playQueueID` - To create a playlist from an existing play queue. 
         * @summary Create a Playlist
         * @param {any} title name of the playlist
         * @param {any} type type of playlist to create
         * @param {any} smart whether the playlist is smart or not
         * @param {any} [uri] the content URI for the playlist
         * @param {any} [playQueueID] the play queue to copy to a playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaylist(title: any, type: any, smart: any, uri?: any, playQueueID?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaylist(title, type, smart, uri, playQueueID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will delete a playlist 
         * @summary Deletes a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaylist(playlistID: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaylist(playlistID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets detailed metadata for a playlist. A playlist for many purposes (rating, editing metadata, tagging), can be treated like a regular metadata item: Smart playlist details contain the `content` attribute. This is the content URI for the generator. This can then be parsed by a client to provide smart playlist editing. 
         * @summary Retrieve Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylist(playlistID: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylist(playlistID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the contents of a playlist. Should be paged by clients via standard mechanisms.  By default leaves are returned (e.g. episodes, movies). In order to return other types you can use the `type` parameter.  For example, you could use this to display a list of recently added albums vis a smart playlist.  Note that for dumb playlists, items have a `playlistItemID` attribute which is used for deleting or moving items. 
         * @summary Retrieve Playlist Contents
         * @param {any} playlistID the ID of the playlist
         * @param {any} type the metadata type of the item to return
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylistContents(playlistID: any, type: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylistContents(playlistID, type, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get All Playlists
         * @param {any} [playlistType] limit to a type of playlist.
         * @param {any} [smart] type of playlists to return (default is all).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylists(playlistType?: any, smart?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylists(playlistType, smart, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * From PMS version 1.9.1 clients can also edit playlist metadata using this endpoint as they would via `PUT /library/metadata/{playlistID}` 
         * @summary Update a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlaylist(playlistID: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlaylist(playlistID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Imports m3u playlists by passing a path on the server to scan for m3u-formatted playlist files, or a path to a single playlist file. 
         * @summary Upload Playlist
         * @param {any} path absolute path to a directory on the server where m3u files are stored, or the absolute path to a playlist file on the server.  If the &#x60;path&#x60; argument is a directory, that path will be scanned for playlist files to be processed.  Each file in that directory creates a separate playlist, with a name based on the filename of the file that created it.  The GUID of each playlist is based on the filename.  If the &#x60;path&#x60; argument is a file, that file will be used to create a new playlist, with the name based on the filename of the file that created it.  The GUID of each playlist is based on the filename. 
         * @param {any} force force overwriting of duplicate playlists. By default, a playlist file uploaded with the same path will overwrite the existing playlist.  The &#x60;force&#x60; argument is used to disable overwriting. If the &#x60;force&#x60; argument is set to 0, a new playlist will be created suffixed with the date and time that the duplicate was uploaded. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPlaylist(path: any, force: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPlaylist(path, force, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlaylistsApi - factory interface
 * @export
 */
export const PlaylistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistsApiFp(configuration)
    return {
        /**
         * Adds a generator to a playlist, same parameters as the POST above. With a dumb playlist, this adds the specified items to the playlist.  With a smart playlist, passing a new `uri` parameter replaces the rules for the playlist. Returns the playlist. 
         * @summary Adding to a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {any} uri the content URI for the playlist
         * @param {any} playQueueID the play queue to add to a playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addPlaylistContents(playlistID: any, uri: any, playQueueID: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.addPlaylistContents(playlistID, uri, playQueueID, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Clears a playlist, only works with dumb playlists. Returns the playlist. 
         * @summary Delete Playlist Contents
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        clearPlaylistContents(playlistID: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.clearPlaylistContents(playlistID, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Create a new playlist. By default the playlist is blank. To create a playlist along with a first item, pass: - `uri` - The content URI for what we\'re playing (e.g. `library://...`). - `playQueueID` - To create a playlist from an existing play queue. 
         * @summary Create a Playlist
         * @param {any} title name of the playlist
         * @param {any} type type of playlist to create
         * @param {any} smart whether the playlist is smart or not
         * @param {any} [uri] the content URI for the playlist
         * @param {any} [playQueueID] the play queue to copy to a playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist(title: any, type: any, smart: any, uri?: any, playQueueID?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.createPlaylist(title, type, smart, uri, playQueueID, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will delete a playlist 
         * @summary Deletes a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist(playlistID: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.deletePlaylist(playlistID, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets detailed metadata for a playlist. A playlist for many purposes (rating, editing metadata, tagging), can be treated like a regular metadata item: Smart playlist details contain the `content` attribute. This is the content URI for the generator. This can then be parsed by a client to provide smart playlist editing. 
         * @summary Retrieve Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist(playlistID: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getPlaylist(playlistID, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Gets the contents of a playlist. Should be paged by clients via standard mechanisms.  By default leaves are returned (e.g. episodes, movies). In order to return other types you can use the `type` parameter.  For example, you could use this to display a list of recently added albums vis a smart playlist.  Note that for dumb playlists, items have a `playlistItemID` attribute which is used for deleting or moving items. 
         * @summary Retrieve Playlist Contents
         * @param {any} playlistID the ID of the playlist
         * @param {any} type the metadata type of the item to return
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistContents(playlistID: any, type: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getPlaylistContents(playlistID, type, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Playlists
         * @param {any} [playlistType] limit to a type of playlist.
         * @param {any} [smart] type of playlists to return (default is all).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylists(playlistType?: any, smart?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getPlaylists(playlistType, smart, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * From PMS version 1.9.1 clients can also edit playlist metadata using this endpoint as they would via `PUT /library/metadata/{playlistID}` 
         * @summary Update a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylist(playlistID: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.updatePlaylist(playlistID, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Imports m3u playlists by passing a path on the server to scan for m3u-formatted playlist files, or a path to a single playlist file. 
         * @summary Upload Playlist
         * @param {any} path absolute path to a directory on the server where m3u files are stored, or the absolute path to a playlist file on the server.  If the &#x60;path&#x60; argument is a directory, that path will be scanned for playlist files to be processed.  Each file in that directory creates a separate playlist, with a name based on the filename of the file that created it.  The GUID of each playlist is based on the filename.  If the &#x60;path&#x60; argument is a file, that file will be used to create a new playlist, with the name based on the filename of the file that created it.  The GUID of each playlist is based on the filename. 
         * @param {any} force force overwriting of duplicate playlists. By default, a playlist file uploaded with the same path will overwrite the existing playlist.  The &#x60;force&#x60; argument is used to disable overwriting. If the &#x60;force&#x60; argument is set to 0, a new playlist will be created suffixed with the date and time that the duplicate was uploaded. 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        uploadPlaylist(path: any, force: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.uploadPlaylist(path, force, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addPlaylistContents operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiAddPlaylistContentsRequest
 */
export interface PlaylistsApiAddPlaylistContentsRequest {
    /**
     * the ID of the playlist
     * @type {any}
     * @memberof PlaylistsApiAddPlaylistContents
     */
    readonly playlistID: any

    /**
     * the content URI for the playlist
     * @type {any}
     * @memberof PlaylistsApiAddPlaylistContents
     */
    readonly uri: any

    /**
     * the play queue to add to a playlist
     * @type {any}
     * @memberof PlaylistsApiAddPlaylistContents
     */
    readonly playQueueID: any
}

/**
 * Request parameters for clearPlaylistContents operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiClearPlaylistContentsRequest
 */
export interface PlaylistsApiClearPlaylistContentsRequest {
    /**
     * the ID of the playlist
     * @type {any}
     * @memberof PlaylistsApiClearPlaylistContents
     */
    readonly playlistID: any
}

/**
 * Request parameters for createPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiCreatePlaylistRequest
 */
export interface PlaylistsApiCreatePlaylistRequest {
    /**
     * name of the playlist
     * @type {any}
     * @memberof PlaylistsApiCreatePlaylist
     */
    readonly title: any

    /**
     * type of playlist to create
     * @type {any}
     * @memberof PlaylistsApiCreatePlaylist
     */
    readonly type: any

    /**
     * whether the playlist is smart or not
     * @type {any}
     * @memberof PlaylistsApiCreatePlaylist
     */
    readonly smart: any

    /**
     * the content URI for the playlist
     * @type {any}
     * @memberof PlaylistsApiCreatePlaylist
     */
    readonly uri?: any

    /**
     * the play queue to copy to a playlist
     * @type {any}
     * @memberof PlaylistsApiCreatePlaylist
     */
    readonly playQueueID?: any
}

/**
 * Request parameters for deletePlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiDeletePlaylistRequest
 */
export interface PlaylistsApiDeletePlaylistRequest {
    /**
     * the ID of the playlist
     * @type {any}
     * @memberof PlaylistsApiDeletePlaylist
     */
    readonly playlistID: any
}

/**
 * Request parameters for getPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiGetPlaylistRequest
 */
export interface PlaylistsApiGetPlaylistRequest {
    /**
     * the ID of the playlist
     * @type {any}
     * @memberof PlaylistsApiGetPlaylist
     */
    readonly playlistID: any
}

/**
 * Request parameters for getPlaylistContents operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiGetPlaylistContentsRequest
 */
export interface PlaylistsApiGetPlaylistContentsRequest {
    /**
     * the ID of the playlist
     * @type {any}
     * @memberof PlaylistsApiGetPlaylistContents
     */
    readonly playlistID: any

    /**
     * the metadata type of the item to return
     * @type {any}
     * @memberof PlaylistsApiGetPlaylistContents
     */
    readonly type: any
}

/**
 * Request parameters for getPlaylists operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiGetPlaylistsRequest
 */
export interface PlaylistsApiGetPlaylistsRequest {
    /**
     * limit to a type of playlist.
     * @type {any}
     * @memberof PlaylistsApiGetPlaylists
     */
    readonly playlistType?: any

    /**
     * type of playlists to return (default is all).
     * @type {any}
     * @memberof PlaylistsApiGetPlaylists
     */
    readonly smart?: any
}

/**
 * Request parameters for updatePlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiUpdatePlaylistRequest
 */
export interface PlaylistsApiUpdatePlaylistRequest {
    /**
     * the ID of the playlist
     * @type {any}
     * @memberof PlaylistsApiUpdatePlaylist
     */
    readonly playlistID: any
}

/**
 * Request parameters for uploadPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiUploadPlaylistRequest
 */
export interface PlaylistsApiUploadPlaylistRequest {
    /**
     * absolute path to a directory on the server where m3u files are stored, or the absolute path to a playlist file on the server.  If the &#x60;path&#x60; argument is a directory, that path will be scanned for playlist files to be processed.  Each file in that directory creates a separate playlist, with a name based on the filename of the file that created it.  The GUID of each playlist is based on the filename.  If the &#x60;path&#x60; argument is a file, that file will be used to create a new playlist, with the name based on the filename of the file that created it.  The GUID of each playlist is based on the filename. 
     * @type {any}
     * @memberof PlaylistsApiUploadPlaylist
     */
    readonly path: any

    /**
     * force overwriting of duplicate playlists. By default, a playlist file uploaded with the same path will overwrite the existing playlist.  The &#x60;force&#x60; argument is used to disable overwriting. If the &#x60;force&#x60; argument is set to 0, a new playlist will be created suffixed with the date and time that the duplicate was uploaded. 
     * @type {any}
     * @memberof PlaylistsApiUploadPlaylist
     */
    readonly force: any
}

/**
 * PlaylistsApi - object-oriented interface
 * @export
 * @class PlaylistsApi
 * @extends {BaseAPI}
 */
export class PlaylistsApi extends BaseAPI {
    /**
     * Adds a generator to a playlist, same parameters as the POST above. With a dumb playlist, this adds the specified items to the playlist.  With a smart playlist, passing a new `uri` parameter replaces the rules for the playlist. Returns the playlist. 
     * @summary Adding to a Playlist
     * @param {PlaylistsApiAddPlaylistContentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public addPlaylistContents(requestParameters: PlaylistsApiAddPlaylistContentsRequest, axiosOptions?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).addPlaylistContents(requestParameters.playlistID, requestParameters.uri, requestParameters.playQueueID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clears a playlist, only works with dumb playlists. Returns the playlist. 
     * @summary Delete Playlist Contents
     * @param {PlaylistsApiClearPlaylistContentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public clearPlaylistContents(requestParameters: PlaylistsApiClearPlaylistContentsRequest, axiosOptions?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).clearPlaylistContents(requestParameters.playlistID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new playlist. By default the playlist is blank. To create a playlist along with a first item, pass: - `uri` - The content URI for what we\'re playing (e.g. `library://...`). - `playQueueID` - To create a playlist from an existing play queue. 
     * @summary Create a Playlist
     * @param {PlaylistsApiCreatePlaylistRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public createPlaylist(requestParameters: PlaylistsApiCreatePlaylistRequest, axiosOptions?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).createPlaylist(requestParameters.title, requestParameters.type, requestParameters.smart, requestParameters.uri, requestParameters.playQueueID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will delete a playlist 
     * @summary Deletes a Playlist
     * @param {PlaylistsApiDeletePlaylistRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public deletePlaylist(requestParameters: PlaylistsApiDeletePlaylistRequest, axiosOptions?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).deletePlaylist(requestParameters.playlistID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets detailed metadata for a playlist. A playlist for many purposes (rating, editing metadata, tagging), can be treated like a regular metadata item: Smart playlist details contain the `content` attribute. This is the content URI for the generator. This can then be parsed by a client to provide smart playlist editing. 
     * @summary Retrieve Playlist
     * @param {PlaylistsApiGetPlaylistRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public getPlaylist(requestParameters: PlaylistsApiGetPlaylistRequest, axiosOptions?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).getPlaylist(requestParameters.playlistID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the contents of a playlist. Should be paged by clients via standard mechanisms.  By default leaves are returned (e.g. episodes, movies). In order to return other types you can use the `type` parameter.  For example, you could use this to display a list of recently added albums vis a smart playlist.  Note that for dumb playlists, items have a `playlistItemID` attribute which is used for deleting or moving items. 
     * @summary Retrieve Playlist Contents
     * @param {PlaylistsApiGetPlaylistContentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public getPlaylistContents(requestParameters: PlaylistsApiGetPlaylistContentsRequest, axiosOptions?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).getPlaylistContents(requestParameters.playlistID, requestParameters.type, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Playlists
     * @param {PlaylistsApiGetPlaylistsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public getPlaylists(requestParameters: PlaylistsApiGetPlaylistsRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).getPlaylists(requestParameters.playlistType, requestParameters.smart, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * From PMS version 1.9.1 clients can also edit playlist metadata using this endpoint as they would via `PUT /library/metadata/{playlistID}` 
     * @summary Update a Playlist
     * @param {PlaylistsApiUpdatePlaylistRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public updatePlaylist(requestParameters: PlaylistsApiUpdatePlaylistRequest, axiosOptions?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).updatePlaylist(requestParameters.playlistID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Imports m3u playlists by passing a path on the server to scan for m3u-formatted playlist files, or a path to a single playlist file. 
     * @summary Upload Playlist
     * @param {PlaylistsApiUploadPlaylistRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public uploadPlaylist(requestParameters: PlaylistsApiUploadPlaylistRequest, axiosOptions?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).uploadPlaylist(requestParameters.path, requestParameters.force, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlexTvApi - axios parameter creator
 * @export
 */
export const PlexTvApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Devices
         * @summary Get Devices
         * @param {any} [includeHttps] Include Https entries in the results
         * @param {any} [includeRelay] Include Relay addresses in the results
         * @param {any} [includeIPv6] Include IPv6 entries in the results
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (includeHttps?: any, includeRelay?: any, includeIPv6?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (includeHttps !== undefined) {
                localVarQueryParameter['includeHttps'] = includeHttps;
            }

            if (includeRelay !== undefined) {
                localVarQueryParameter['includeRelay'] = includeRelay;
            }

            if (includeIPv6 !== undefined) {
                localVarQueryParameter['includeIPv6'] = includeIPv6;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get Home Data
         * @summary Get Home Data
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getHomeData: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/home`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a Pin from Plex.tv for authentication flows
         * @summary Get a Pin
         * @param {any} [strong] Determines the kind of code returned by the API call Strong codes are used for Pin authentication flows Non-Strong codes are used for &#x60;Plex.tv/link&#x60; 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPin: async (strong?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            if (strong !== undefined) {
                localVarQueryParameter['strong'] = strong;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an Access Token from Plex.tv after the Pin has already been authenticated
         * @summary Get Access Token
         * @param {any} pinID The PinID to retrieve an access token for
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (pinID: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pinID' is not null or undefined
            assertParamExists('getToken', 'pinID', pinID)
            const localVarPath = `/pins/{pinID}`
                .replace(`{${"pinID"}}`, encodeURIComponent(String(pinID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get Logged in User
         * @summary Get Logged in User
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUserDetails: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlexTvApi - functional programming interface
 * @export
 */
export const PlexTvApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlexTvApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Devices
         * @summary Get Devices
         * @param {any} [includeHttps] Include Https entries in the results
         * @param {any} [includeRelay] Include Relay addresses in the results
         * @param {any} [includeIPv6] Include IPv6 entries in the results
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(includeHttps?: any, includeRelay?: any, includeIPv6?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevices(includeHttps, includeRelay, includeIPv6, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Home Data
         * @summary Get Home Data
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getHomeData(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHomeData200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHomeData(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a Pin from Plex.tv for authentication flows
         * @summary Get a Pin
         * @param {any} [strong] Determines the kind of code returned by the API call Strong codes are used for Pin authentication flows Non-Strong codes are used for &#x60;Plex.tv/link&#x60; 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getPin(strong?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPin(strong, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an Access Token from Plex.tv after the Pin has already been authenticated
         * @summary Get Access Token
         * @param {any} pinID The PinID to retrieve an access token for
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(pinID: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(pinID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Logged in User
         * @summary Get Logged in User
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDetails(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDetails(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlexTvApi - factory interface
 * @export
 */
export const PlexTvApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlexTvApiFp(configuration)
    return {
        /**
         * Get Devices
         * @summary Get Devices
         * @param {any} [includeHttps] Include Https entries in the results
         * @param {any} [includeRelay] Include Relay addresses in the results
         * @param {any} [includeIPv6] Include IPv6 entries in the results
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(includeHttps?: any, includeRelay?: any, includeIPv6?: any, axiosOptions?: any): AxiosPromise<any> {
            return localVarFp.getDevices(includeHttps, includeRelay, includeIPv6, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get Home Data
         * @summary Get Home Data
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getHomeData(axiosOptions?: any): AxiosPromise<GetHomeData200Response> {
            return localVarFp.getHomeData(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a Pin from Plex.tv for authentication flows
         * @summary Get a Pin
         * @param {any} [strong] Determines the kind of code returned by the API call Strong codes are used for Pin authentication flows Non-Strong codes are used for &#x60;Plex.tv/link&#x60; 
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPin(strong?: any, axiosOptions?: any): AxiosPromise<GetPin200Response> {
            return localVarFp.getPin(strong, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an Access Token from Plex.tv after the Pin has already been authenticated
         * @summary Get Access Token
         * @param {any} pinID The PinID to retrieve an access token for
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getToken(pinID: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getToken(pinID, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get Logged in User
         * @summary Get Logged in User
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUserDetails(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getUserDetails(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDevices operation in PlexTvApi.
 * @export
 * @interface PlexTvApiGetDevicesRequest
 */
export interface PlexTvApiGetDevicesRequest {
    /**
     * Include Https entries in the results
     * @type {any}
     * @memberof PlexTvApiGetDevices
     */
    readonly includeHttps?: any

    /**
     * Include Relay addresses in the results
     * @type {any}
     * @memberof PlexTvApiGetDevices
     */
    readonly includeRelay?: any

    /**
     * Include IPv6 entries in the results
     * @type {any}
     * @memberof PlexTvApiGetDevices
     */
    readonly includeIPv6?: any
}

/**
 * Request parameters for getPin operation in PlexTvApi.
 * @export
 * @interface PlexTvApiGetPinRequest
 */
export interface PlexTvApiGetPinRequest {
    /**
     * Determines the kind of code returned by the API call Strong codes are used for Pin authentication flows Non-Strong codes are used for &#x60;Plex.tv/link&#x60; 
     * @type {any}
     * @memberof PlexTvApiGetPin
     */
    readonly strong?: any
}

/**
 * Request parameters for getToken operation in PlexTvApi.
 * @export
 * @interface PlexTvApiGetTokenRequest
 */
export interface PlexTvApiGetTokenRequest {
    /**
     * The PinID to retrieve an access token for
     * @type {any}
     * @memberof PlexTvApiGetToken
     */
    readonly pinID: any
}

/**
 * PlexTvApi - object-oriented interface
 * @export
 * @class PlexTvApi
 * @extends {BaseAPI}
 */
export class PlexTvApi extends BaseAPI {
    /**
     * Get Devices
     * @summary Get Devices
     * @param {PlexTvApiGetDevicesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlexTvApi
     */
    public getDevices(requestParameters: PlexTvApiGetDevicesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PlexTvApiFp(this.configuration).getDevices(requestParameters.includeHttps, requestParameters.includeRelay, requestParameters.includeIPv6, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Home Data
     * @summary Get Home Data
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlexTvApi
     */
    public getHomeData(axiosOptions?: AxiosRequestConfig) {
        return PlexTvApiFp(this.configuration).getHomeData(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a Pin from Plex.tv for authentication flows
     * @summary Get a Pin
     * @param {PlexTvApiGetPinRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlexTvApi
     */
    public getPin(requestParameters: PlexTvApiGetPinRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return PlexTvApiFp(this.configuration).getPin(requestParameters.strong, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an Access Token from Plex.tv after the Pin has already been authenticated
     * @summary Get Access Token
     * @param {PlexTvApiGetTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlexTvApi
     */
    public getToken(requestParameters: PlexTvApiGetTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return PlexTvApiFp(this.configuration).getToken(requestParameters.pinID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Logged in User
     * @summary Get Logged in User
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlexTvApi
     */
    public getUserDetails(axiosOptions?: AxiosRequestConfig) {
        return PlexTvApiFp(this.configuration).getUserDetails(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will search the database for the string provided.
         * @summary Get Search Results
         * @param {any} query The search query string to use
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSearchResults: async (query: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getSearchResults', 'query', query)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint performs a search across all library sections, or a single section, and returns matches as hubs, split up by type. It performs spell checking, looks for partial matches, and orders the hubs based on quality of results. In addition, based on matches, it will return other related matches (e.g. for a genre match, it may return movies in that genre, or for an actor match, movies with that actor).  In the response\'s items, the following extra attributes are returned to further describe or disambiguate the result:  - `reason`: The reason for the result, if not because of a direct search term match; can be either:   - `section`: There are multiple identical results from different sections.   - `originalTitle`: There was a search term match from the original title field (sometimes those can be very different or in a foreign language).   - `<hub identifier>`: If the reason for the result is due to a result in another hub, the source hub identifier is returned. For example, if the search is for \"dylan\" then Bob Dylan may be returned as an artist result, an a few of his albums returned as album results with a reason code of `artist` (the identifier of that particular hub). Or if the search is for \"arnold\", there might be movie results returned with a reason of `actor` - `reasonTitle`: The string associated with the reason code. For a section reason, it\'ll be the section name; For a hub identifier, it\'ll be a string associated with the match (e.g. `Arnold Schwarzenegger` for movies which were returned because the search was for \"arnold\"). - `reasonID`: The ID of the item associated with the reason for the result. This might be a section ID, a tag ID, an artist ID, or a show ID.  This request is intended to be very fast, and called as the user types. 
         * @summary Perform a search
         * @param {any} query The query term
         * @param {any} [sectionId] This gives context to the search, and can result in re-ordering of search result hubs
         * @param {any} [limit] The number of items to return per hub
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        performSearch: async (query: any, sectionId?: any, limit?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('performSearch', 'query', query)
            const localVarPath = `/hubs/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sectionId !== undefined) {
                localVarQueryParameter['sectionId'] = sectionId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint performs a search specifically tailored towards voice or other imprecise input which may work badly with the substring and spell-checking heuristics used by the `/hubs/search` endpoint.  It uses a [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) heuristic to search titles, and as such is much slower than the other search endpoint.  Whenever possible, clients should limit the search to the appropriate type.  Results, as well as their containing per-type hubs, contain a `distance` attribute which can be used to judge result quality. 
         * @summary Perform a voice search
         * @param {any} query The query term
         * @param {any} [sectionId] This gives context to the search, and can result in re-ordering of search result hubs
         * @param {any} [limit] The number of items to return per hub
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        performVoiceSearch: async (query: any, sectionId?: any, limit?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('performVoiceSearch', 'query', query)
            const localVarPath = `/hubs/search/voice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sectionId !== undefined) {
                localVarQueryParameter['sectionId'] = sectionId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * This will search the database for the string provided.
         * @summary Get Search Results
         * @param {any} query The search query string to use
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchResults(query: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSearchResults200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchResults(query, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint performs a search across all library sections, or a single section, and returns matches as hubs, split up by type. It performs spell checking, looks for partial matches, and orders the hubs based on quality of results. In addition, based on matches, it will return other related matches (e.g. for a genre match, it may return movies in that genre, or for an actor match, movies with that actor).  In the response\'s items, the following extra attributes are returned to further describe or disambiguate the result:  - `reason`: The reason for the result, if not because of a direct search term match; can be either:   - `section`: There are multiple identical results from different sections.   - `originalTitle`: There was a search term match from the original title field (sometimes those can be very different or in a foreign language).   - `<hub identifier>`: If the reason for the result is due to a result in another hub, the source hub identifier is returned. For example, if the search is for \"dylan\" then Bob Dylan may be returned as an artist result, an a few of his albums returned as album results with a reason code of `artist` (the identifier of that particular hub). Or if the search is for \"arnold\", there might be movie results returned with a reason of `actor` - `reasonTitle`: The string associated with the reason code. For a section reason, it\'ll be the section name; For a hub identifier, it\'ll be a string associated with the match (e.g. `Arnold Schwarzenegger` for movies which were returned because the search was for \"arnold\"). - `reasonID`: The ID of the item associated with the reason for the result. This might be a section ID, a tag ID, an artist ID, or a show ID.  This request is intended to be very fast, and called as the user types. 
         * @summary Perform a search
         * @param {any} query The query term
         * @param {any} [sectionId] This gives context to the search, and can result in re-ordering of search result hubs
         * @param {any} [limit] The number of items to return per hub
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async performSearch(query: any, sectionId?: any, limit?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.performSearch(query, sectionId, limit, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint performs a search specifically tailored towards voice or other imprecise input which may work badly with the substring and spell-checking heuristics used by the `/hubs/search` endpoint.  It uses a [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) heuristic to search titles, and as such is much slower than the other search endpoint.  Whenever possible, clients should limit the search to the appropriate type.  Results, as well as their containing per-type hubs, contain a `distance` attribute which can be used to judge result quality. 
         * @summary Perform a voice search
         * @param {any} query The query term
         * @param {any} [sectionId] This gives context to the search, and can result in re-ordering of search result hubs
         * @param {any} [limit] The number of items to return per hub
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async performVoiceSearch(query: any, sectionId?: any, limit?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.performVoiceSearch(query, sectionId, limit, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * This will search the database for the string provided.
         * @summary Get Search Results
         * @param {any} query The search query string to use
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSearchResults(query: any, axiosOptions?: any): AxiosPromise<GetSearchResults200Response> {
            return localVarFp.getSearchResults(query, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint performs a search across all library sections, or a single section, and returns matches as hubs, split up by type. It performs spell checking, looks for partial matches, and orders the hubs based on quality of results. In addition, based on matches, it will return other related matches (e.g. for a genre match, it may return movies in that genre, or for an actor match, movies with that actor).  In the response\'s items, the following extra attributes are returned to further describe or disambiguate the result:  - `reason`: The reason for the result, if not because of a direct search term match; can be either:   - `section`: There are multiple identical results from different sections.   - `originalTitle`: There was a search term match from the original title field (sometimes those can be very different or in a foreign language).   - `<hub identifier>`: If the reason for the result is due to a result in another hub, the source hub identifier is returned. For example, if the search is for \"dylan\" then Bob Dylan may be returned as an artist result, an a few of his albums returned as album results with a reason code of `artist` (the identifier of that particular hub). Or if the search is for \"arnold\", there might be movie results returned with a reason of `actor` - `reasonTitle`: The string associated with the reason code. For a section reason, it\'ll be the section name; For a hub identifier, it\'ll be a string associated with the match (e.g. `Arnold Schwarzenegger` for movies which were returned because the search was for \"arnold\"). - `reasonID`: The ID of the item associated with the reason for the result. This might be a section ID, a tag ID, an artist ID, or a show ID.  This request is intended to be very fast, and called as the user types. 
         * @summary Perform a search
         * @param {any} query The query term
         * @param {any} [sectionId] This gives context to the search, and can result in re-ordering of search result hubs
         * @param {any} [limit] The number of items to return per hub
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        performSearch(query: any, sectionId?: any, limit?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.performSearch(query, sectionId, limit, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint performs a search specifically tailored towards voice or other imprecise input which may work badly with the substring and spell-checking heuristics used by the `/hubs/search` endpoint.  It uses a [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) heuristic to search titles, and as such is much slower than the other search endpoint.  Whenever possible, clients should limit the search to the appropriate type.  Results, as well as their containing per-type hubs, contain a `distance` attribute which can be used to judge result quality. 
         * @summary Perform a voice search
         * @param {any} query The query term
         * @param {any} [sectionId] This gives context to the search, and can result in re-ordering of search result hubs
         * @param {any} [limit] The number of items to return per hub
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        performVoiceSearch(query: any, sectionId?: any, limit?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.performVoiceSearch(query, sectionId, limit, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSearchResults operation in SearchApi.
 * @export
 * @interface SearchApiGetSearchResultsRequest
 */
export interface SearchApiGetSearchResultsRequest {
    /**
     * The search query string to use
     * @type {any}
     * @memberof SearchApiGetSearchResults
     */
    readonly query: any
}

/**
 * Request parameters for performSearch operation in SearchApi.
 * @export
 * @interface SearchApiPerformSearchRequest
 */
export interface SearchApiPerformSearchRequest {
    /**
     * The query term
     * @type {any}
     * @memberof SearchApiPerformSearch
     */
    readonly query: any

    /**
     * This gives context to the search, and can result in re-ordering of search result hubs
     * @type {any}
     * @memberof SearchApiPerformSearch
     */
    readonly sectionId?: any

    /**
     * The number of items to return per hub
     * @type {any}
     * @memberof SearchApiPerformSearch
     */
    readonly limit?: any
}

/**
 * Request parameters for performVoiceSearch operation in SearchApi.
 * @export
 * @interface SearchApiPerformVoiceSearchRequest
 */
export interface SearchApiPerformVoiceSearchRequest {
    /**
     * The query term
     * @type {any}
     * @memberof SearchApiPerformVoiceSearch
     */
    readonly query: any

    /**
     * This gives context to the search, and can result in re-ordering of search result hubs
     * @type {any}
     * @memberof SearchApiPerformVoiceSearch
     */
    readonly sectionId?: any

    /**
     * The number of items to return per hub
     * @type {any}
     * @memberof SearchApiPerformVoiceSearch
     */
    readonly limit?: any
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * This will search the database for the string provided.
     * @summary Get Search Results
     * @param {SearchApiGetSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getSearchResults(requestParameters: SearchApiGetSearchResultsRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).getSearchResults(requestParameters.query, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint performs a search across all library sections, or a single section, and returns matches as hubs, split up by type. It performs spell checking, looks for partial matches, and orders the hubs based on quality of results. In addition, based on matches, it will return other related matches (e.g. for a genre match, it may return movies in that genre, or for an actor match, movies with that actor).  In the response\'s items, the following extra attributes are returned to further describe or disambiguate the result:  - `reason`: The reason for the result, if not because of a direct search term match; can be either:   - `section`: There are multiple identical results from different sections.   - `originalTitle`: There was a search term match from the original title field (sometimes those can be very different or in a foreign language).   - `<hub identifier>`: If the reason for the result is due to a result in another hub, the source hub identifier is returned. For example, if the search is for \"dylan\" then Bob Dylan may be returned as an artist result, an a few of his albums returned as album results with a reason code of `artist` (the identifier of that particular hub). Or if the search is for \"arnold\", there might be movie results returned with a reason of `actor` - `reasonTitle`: The string associated with the reason code. For a section reason, it\'ll be the section name; For a hub identifier, it\'ll be a string associated with the match (e.g. `Arnold Schwarzenegger` for movies which were returned because the search was for \"arnold\"). - `reasonID`: The ID of the item associated with the reason for the result. This might be a section ID, a tag ID, an artist ID, or a show ID.  This request is intended to be very fast, and called as the user types. 
     * @summary Perform a search
     * @param {SearchApiPerformSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public performSearch(requestParameters: SearchApiPerformSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).performSearch(requestParameters.query, requestParameters.sectionId, requestParameters.limit, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint performs a search specifically tailored towards voice or other imprecise input which may work badly with the substring and spell-checking heuristics used by the `/hubs/search` endpoint.  It uses a [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) heuristic to search titles, and as such is much slower than the other search endpoint.  Whenever possible, clients should limit the search to the appropriate type.  Results, as well as their containing per-type hubs, contain a `distance` attribute which can be used to judge result quality. 
     * @summary Perform a voice search
     * @param {SearchApiPerformVoiceSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public performVoiceSearch(requestParameters: SearchApiPerformVoiceSearchRequest, axiosOptions?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).performVoiceSearch(requestParameters.query, requestParameters.sectionId, requestParameters.limit, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4. 
         * @summary Get Source Connection Information
         * @param {any} source The source identifier with an included prefix.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceConnectionInformation: async (source: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getSourceConnectionInformation', 'source', source)
            const localVarPath = `/security/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted. 
         * @summary Get a Transient Token.
         * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
         * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransientToken: async (type: any, scope: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTransientToken', 'type', type)
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('getTransientToken', 'scope', scope)
            const localVarPath = `/security/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration)
    return {
        /**
         * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4. 
         * @summary Get Source Connection Information
         * @param {any} source The source identifier with an included prefix.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceConnectionInformation(source: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceConnectionInformation(source, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted. 
         * @summary Get a Transient Token.
         * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
         * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTransientToken(type: any, scope: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransientToken(type, scope, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityApiFp(configuration)
    return {
        /**
         * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4. 
         * @summary Get Source Connection Information
         * @param {any} source The source identifier with an included prefix.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSourceConnectionInformation(source: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getSourceConnectionInformation(source, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted. 
         * @summary Get a Transient Token.
         * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
         * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransientToken(type: any, scope: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getTransientToken(type, scope, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSourceConnectionInformation operation in SecurityApi.
 * @export
 * @interface SecurityApiGetSourceConnectionInformationRequest
 */
export interface SecurityApiGetSourceConnectionInformationRequest {
    /**
     * The source identifier with an included prefix.
     * @type {any}
     * @memberof SecurityApiGetSourceConnectionInformation
     */
    readonly source: any
}

/**
 * Request parameters for getTransientToken operation in SecurityApi.
 * @export
 * @interface SecurityApiGetTransientTokenRequest
 */
export interface SecurityApiGetTransientTokenRequest {
    /**
     * &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
     * @type {any}
     * @memberof SecurityApiGetTransientToken
     */
    readonly type: any

    /**
     * &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
     * @type {any}
     * @memberof SecurityApiGetTransientToken
     */
    readonly scope: any
}

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4. 
     * @summary Get Source Connection Information
     * @param {SecurityApiGetSourceConnectionInformationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getSourceConnectionInformation(requestParameters: SecurityApiGetSourceConnectionInformationRequest, axiosOptions?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).getSourceConnectionInformation(requestParameters.source, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted. 
     * @summary Get a Transient Token.
     * @param {SecurityApiGetTransientTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getTransientToken(requestParameters: SecurityApiGetTransientTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).getTransientToken(requestParameters.type, requestParameters.scope, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Server Capabilities
         * @summary Server Capabilities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerCapabilities: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get Server Identity
         * @summary Get Server Identity
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerIdentity: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get Server List
         * @summary Get Server List
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerList: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get Server Preferences
         * @summary Get Server Preferences
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerPreferences: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/:/prefs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration)
    return {
        /**
         * Server Capabilities
         * @summary Server Capabilities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServerCapabilities(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServerCapabilities200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerCapabilities(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Server Identity
         * @summary Get Server Identity
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServerIdentity(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServerIdentity200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerIdentity(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Server List
         * @summary Get Server List
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServerList(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServerList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerList(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Server Preferences
         * @summary Get Server Preferences
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getServerPreferences(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerPreferences(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerApiFp(configuration)
    return {
        /**
         * Server Capabilities
         * @summary Server Capabilities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerCapabilities(axiosOptions?: any): AxiosPromise<GetServerCapabilities200Response> {
            return localVarFp.getServerCapabilities(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get Server Identity
         * @summary Get Server Identity
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerIdentity(axiosOptions?: any): AxiosPromise<GetServerIdentity200Response> {
            return localVarFp.getServerIdentity(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get Server List
         * @summary Get Server List
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerList(axiosOptions?: any): AxiosPromise<GetServerList200Response> {
            return localVarFp.getServerList(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get Server Preferences
         * @summary Get Server Preferences
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerPreferences(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getServerPreferences(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * Server Capabilities
     * @summary Server Capabilities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public getServerCapabilities(axiosOptions?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).getServerCapabilities(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server Identity
     * @summary Get Server Identity
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public getServerIdentity(axiosOptions?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).getServerIdentity(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server List
     * @summary Get Server List
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public getServerList(axiosOptions?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).getServerList(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server Preferences
     * @summary Get Server Preferences
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public getServerPreferences(axiosOptions?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).getServerPreferences(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will Retrieve a listing of all history views.
         * @summary Get Session History
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSessionHistory: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status/sessions/history/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This will retrieve the \"Now Playing\" Information of the PMS.
         * @summary Get Active Sessions
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Get Transcode Sessions
         * @summary Get Transcode Sessions
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTranscodeSessions: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transcode/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Stop a Transcode Session
         * @summary Stop a Transcode Session
         * @param {any} sessionKey the Key of the transcode session to stop
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopTranscodeSession: async (sessionKey: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionKey' is not null or undefined
            assertParamExists('stopTranscodeSession', 'sessionKey', sessionKey)
            const localVarPath = `/transcode/sessions/{sessionKey}`
                .replace(`{${"sessionKey"}}`, encodeURIComponent(String(sessionKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * This will Retrieve a listing of all history views.
         * @summary Get Session History
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionHistory(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionHistory(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will retrieve the \"Now Playing\" Information of the PMS.
         * @summary Get Active Sessions
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Transcode Sessions
         * @summary Get Transcode Sessions
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTranscodeSessions(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTranscodeSessions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTranscodeSessions(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Stop a Transcode Session
         * @summary Stop a Transcode Session
         * @param {any} sessionKey the Key of the transcode session to stop
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async stopTranscodeSession(sessionKey: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopTranscodeSession(sessionKey, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * This will Retrieve a listing of all history views.
         * @summary Get Session History
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSessionHistory(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getSessionHistory(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This will retrieve the \"Now Playing\" Information of the PMS.
         * @summary Get Active Sessions
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getSessions(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Get Transcode Sessions
         * @summary Get Transcode Sessions
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTranscodeSessions(axiosOptions?: any): AxiosPromise<GetTranscodeSessions200Response> {
            return localVarFp.getTranscodeSessions(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Stop a Transcode Session
         * @summary Stop a Transcode Session
         * @param {any} sessionKey the Key of the transcode session to stop
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopTranscodeSession(sessionKey: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.stopTranscodeSession(sessionKey, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for stopTranscodeSession operation in SessionsApi.
 * @export
 * @interface SessionsApiStopTranscodeSessionRequest
 */
export interface SessionsApiStopTranscodeSessionRequest {
    /**
     * the Key of the transcode session to stop
     * @type {any}
     * @memberof SessionsApiStopTranscodeSession
     */
    readonly sessionKey: any
}

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * This will Retrieve a listing of all history views.
     * @summary Get Session History
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessionHistory(axiosOptions?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessionHistory(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will retrieve the \"Now Playing\" Information of the PMS.
     * @summary Get Active Sessions
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessions(axiosOptions?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessions(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Transcode Sessions
     * @summary Get Transcode Sessions
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getTranscodeSessions(axiosOptions?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getTranscodeSessions(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop a Transcode Session
     * @summary Stop a Transcode Session
     * @param {SessionsApiStopTranscodeSessionRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public stopTranscodeSession(requestParameters: SessionsApiStopTranscodeSessionRequest, axiosOptions?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).stopTranscodeSession(requestParameters.sessionKey, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdaterApi - axios parameter creator
 * @export
 */
export const UpdaterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed 
         * @summary Apply Updates
         * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
         * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        applyUpdates: async (tonight?: any, skip?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/updater/apply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (tonight !== undefined) {
                localVarQueryParameter['tonight'] = tonight;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Checking for updates
         * @summary Checking for updates
         * @param {any} [download] Indicate that you want to start download any updates found.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        checkForUpdates: async (download?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/updater/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Querying status of updates
         * @summary Querying status of updates
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUpdateStatus: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/updater/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdaterApi - functional programming interface
 * @export
 */
export const UpdaterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdaterApiAxiosParamCreator(configuration)
    return {
        /**
         * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed 
         * @summary Apply Updates
         * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
         * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async applyUpdates(tonight?: any, skip?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyUpdates(tonight, skip, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Checking for updates
         * @summary Checking for updates
         * @param {any} [download] Indicate that you want to start download any updates found.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async checkForUpdates(download?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkForUpdates(download, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Querying status of updates
         * @summary Querying status of updates
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getUpdateStatus(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpdateStatus(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdaterApi - factory interface
 * @export
 */
export const UpdaterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdaterApiFp(configuration)
    return {
        /**
         * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed 
         * @summary Apply Updates
         * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
         * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        applyUpdates(tonight?: any, skip?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.applyUpdates(tonight, skip, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Checking for updates
         * @summary Checking for updates
         * @param {any} [download] Indicate that you want to start download any updates found.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        checkForUpdates(download?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.checkForUpdates(download, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Querying status of updates
         * @summary Querying status of updates
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUpdateStatus(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getUpdateStatus(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for applyUpdates operation in UpdaterApi.
 * @export
 * @interface UpdaterApiApplyUpdatesRequest
 */
export interface UpdaterApiApplyUpdatesRequest {
    /**
     * Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
     * @type {any}
     * @memberof UpdaterApiApplyUpdates
     */
    readonly tonight?: any

    /**
     * Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
     * @type {any}
     * @memberof UpdaterApiApplyUpdates
     */
    readonly skip?: any
}

/**
 * Request parameters for checkForUpdates operation in UpdaterApi.
 * @export
 * @interface UpdaterApiCheckForUpdatesRequest
 */
export interface UpdaterApiCheckForUpdatesRequest {
    /**
     * Indicate that you want to start download any updates found.
     * @type {any}
     * @memberof UpdaterApiCheckForUpdates
     */
    readonly download?: any
}

/**
 * UpdaterApi - object-oriented interface
 * @export
 * @class UpdaterApi
 * @extends {BaseAPI}
 */
export class UpdaterApi extends BaseAPI {
    /**
     * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed 
     * @summary Apply Updates
     * @param {UpdaterApiApplyUpdatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    public applyUpdates(requestParameters: UpdaterApiApplyUpdatesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return UpdaterApiFp(this.configuration).applyUpdates(requestParameters.tonight, requestParameters.skip, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checking for updates
     * @summary Checking for updates
     * @param {UpdaterApiCheckForUpdatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    public checkForUpdates(requestParameters: UpdaterApiCheckForUpdatesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return UpdaterApiFp(this.configuration).checkForUpdates(requestParameters.download, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Querying status of updates
     * @summary Querying status of updates
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    public getUpdateStatus(axiosOptions?: AxiosRequestConfig) {
        return UpdaterApiFp(this.configuration).getUpdateStatus(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Logged in User
         * @summary Get Logged in User
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUserDetails: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientIdentifier required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Client-Identifier", configuration)

            // authentication Device required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device", configuration)

            // authentication DeviceName required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Device-Name", configuration)

            // authentication Platform required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform", configuration)

            // authentication PlatformVersion required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Platform-Version", configuration)

            // authentication Product required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Product", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Token", configuration)

            // authentication Version required
            await setApiKeyToObject(localVarHeaderParameter, "X-Plex-Version", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Logged in User
         * @summary Get Logged in User
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDetails(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDetails(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Get Logged in User
         * @summary Get Logged in User
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getUserDetails(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getUserDetails(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Get Logged in User
     * @summary Get Logged in User
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserDetails(axiosOptions?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserDetails(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


