/**
 * Plex-API
 * An Open API Spec for interacting with Plex.tv and Plex Servers
 *
 * The version of the OpenAPI document: 0.0.3
 * Contact: Lukeslakemail@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Configuration } from './configuration';
import { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { RequestArgs, BaseAPI } from './base';
/**
 *
 * @export
 * @interface ServerActivities200Response
 */
export interface ServerActivities200Response {
    /**
     *
     * @type {ServerActivities200ResponseMediaContainer}
     * @memberof ServerActivities200Response
     */
    'MediaContainer'?: ServerActivities200ResponseMediaContainer;
}
/**
 *
 * @export
 * @interface ServerActivities200ResponseMediaContainer
 */
export interface ServerActivities200ResponseMediaContainer {
    /**
     *
     * @type {any}
     * @memberof ServerActivities200ResponseMediaContainer
     */
    'size'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerActivities200ResponseMediaContainer
     */
    'Activity'?: any;
}
/**
 *
 * @export
 * @interface ServerCapabilities200Response
 */
export interface ServerCapabilities200Response {
    /**
     *
     * @type {ServerCapabilities200ResponseMediaContainer}
     * @memberof ServerCapabilities200Response
     */
    'MediaContainer'?: ServerCapabilities200ResponseMediaContainer;
}
/**
 *
 * @export
 * @interface ServerCapabilities200ResponseMediaContainer
 */
export interface ServerCapabilities200ResponseMediaContainer {
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'size'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'allowCameraUpload'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'allowChannelAccess'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'allowMediaDeletion'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'allowSharing'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'allowSync'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'allowTuners'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'backgroundProcessing'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'certificate'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'companionProxy'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'countryCode'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'diagnostics'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'eventStream'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'friendlyName'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'hubSearch'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'itemClusters'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'livetv'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'machineIdentifier'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'mediaProviders'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'multiuser'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'musicAnalysis'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'myPlex'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'myPlexMappingState'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'myPlexSigninState'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'myPlexSubscription'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'myPlexUsername'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'offlineTranscode'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'ownerFeatures'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'photoAutoTag'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'platform'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'platformVersion'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'pluginHost'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'pushNotifications'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'readOnlyLibraries'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'streamingBrainABRVersion'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'streamingBrainVersion'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'sync'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderActiveVideoSessions'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderAudio'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderLyrics'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderPhoto'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderSubtitles'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderVideo'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderVideoBitrates'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderVideoQualities'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderVideoResolutions'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'updatedAt'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'updater'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'version'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'voiceSearch'?: any;
    /**
     *
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'Directory'?: any;
}
/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
export declare const ActivitiesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Cancel Server Activities
     * @summary Cancel Server Activities
     * @param {any} activityUUID The UUID of the activity to cancel.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    cancelServerActivities: (activityUUID: any, axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Server Activities
     * @summary Server Activities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    serverActivities: (axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export declare const ActivitiesApiFp: (configuration?: Configuration) => {
    /**
     * Cancel Server Activities
     * @summary Cancel Server Activities
     * @param {any} activityUUID The UUID of the activity to cancel.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    cancelServerActivities(activityUUID: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Server Activities
     * @summary Server Activities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    serverActivities(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerActivities200Response>>;
};
/**
 * ActivitiesApi - factory interface
 * @export
 */
export declare const ActivitiesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Cancel Server Activities
     * @summary Cancel Server Activities
     * @param {any} activityUUID The UUID of the activity to cancel.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    cancelServerActivities(activityUUID: any, axiosOptions?: any): AxiosPromise<void>;
    /**
     * Server Activities
     * @summary Server Activities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    serverActivities(axiosOptions?: any): AxiosPromise<ServerActivities200Response>;
};
/**
 * Request parameters for cancelServerActivities operation in ActivitiesApi.
 * @export
 * @interface ActivitiesApiCancelServerActivitiesRequest
 */
export interface ActivitiesApiCancelServerActivitiesRequest {
    /**
     * The UUID of the activity to cancel.
     * @type {any}
     * @memberof ActivitiesApiCancelServerActivities
     */
    readonly activityUUID: any;
}
/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export declare class ActivitiesApi extends BaseAPI {
    /**
     * Cancel Server Activities
     * @summary Cancel Server Activities
     * @param {ActivitiesApiCancelServerActivitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    cancelServerActivities(requestParameters: ActivitiesApiCancelServerActivitiesRequest, axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Server Activities
     * @summary Server Activities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    serverActivities(axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ServerActivities200Response, any>>;
}
/**
 * ButlerApi - axios parameter creator
 * @export
 */
export declare const ButlerApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
     * @summary Start a single Butler task
     * @param {any} taskName the name of the task to be started.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    startAButlerTasks: (taskName: any, axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
     * @summary Start all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    startAllButlerTasks: (axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint.
     * @summary Stop a single Butler task
     * @param {any} taskName The name of the task to be started.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    stopAButlerTasks: (taskName: any, axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue.
     * @summary Stop all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    stopAllButlerTasks: (axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ButlerApi - functional programming interface
 * @export
 */
export declare const ButlerApiFp: (configuration?: Configuration) => {
    /**
     * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
     * @summary Start a single Butler task
     * @param {any} taskName the name of the task to be started.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    startAButlerTasks(taskName: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
     * @summary Start all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    startAllButlerTasks(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint.
     * @summary Stop a single Butler task
     * @param {any} taskName The name of the task to be started.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    stopAButlerTasks(taskName: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue.
     * @summary Stop all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    stopAllButlerTasks(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * ButlerApi - factory interface
 * @export
 */
export declare const ButlerApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
     * @summary Start a single Butler task
     * @param {any} taskName the name of the task to be started.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    startAButlerTasks(taskName: any, axiosOptions?: any): AxiosPromise<void>;
    /**
     * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
     * @summary Start all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    startAllButlerTasks(axiosOptions?: any): AxiosPromise<void>;
    /**
     * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint.
     * @summary Stop a single Butler task
     * @param {any} taskName The name of the task to be started.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    stopAButlerTasks(taskName: any, axiosOptions?: any): AxiosPromise<void>;
    /**
     * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue.
     * @summary Stop all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    stopAllButlerTasks(axiosOptions?: any): AxiosPromise<void>;
};
/**
 * Request parameters for startAButlerTasks operation in ButlerApi.
 * @export
 * @interface ButlerApiStartAButlerTasksRequest
 */
export interface ButlerApiStartAButlerTasksRequest {
    /**
     * the name of the task to be started.
     * @type {any}
     * @memberof ButlerApiStartAButlerTasks
     */
    readonly taskName: any;
}
/**
 * Request parameters for stopAButlerTasks operation in ButlerApi.
 * @export
 * @interface ButlerApiStopAButlerTasksRequest
 */
export interface ButlerApiStopAButlerTasksRequest {
    /**
     * The name of the task to be started.
     * @type {any}
     * @memberof ButlerApiStopAButlerTasks
     */
    readonly taskName: any;
}
/**
 * ButlerApi - object-oriented interface
 * @export
 * @class ButlerApi
 * @extends {BaseAPI}
 */
export declare class ButlerApi extends BaseAPI {
    /**
     * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
     * @summary Start a single Butler task
     * @param {ButlerApiStartAButlerTasksRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    startAButlerTasks(requestParameters: ButlerApiStartAButlerTasksRequest, axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
     * @summary Start all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    startAllButlerTasks(axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint.
     * @summary Stop a single Butler task
     * @param {ButlerApiStopAButlerTasksRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    stopAButlerTasks(requestParameters: ButlerApiStopAButlerTasksRequest, axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue.
     * @summary Stop all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    stopAllButlerTasks(axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * LibraryApi - axios parameter creator
 * @export
 */
export declare const LibraryApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * This endpoint will return a list of libraries
     * @summary Get All Libraries
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    getLibraries: (axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This endpoint will return a list of library items filtered by the filter and type provided
     * @summary Get Library Items
     * @param {any} sectionId the Id of the library to query
     * @param {any} category the category to retrieve from the library
     * @param {any} [type] item type
     * @param {any} [filter] the filter parameter
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    getLibraryItems: (sectionId: any, category: any, type?: any, filter?: any, axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * LibraryApi - functional programming interface
 * @export
 */
export declare const LibraryApiFp: (configuration?: Configuration) => {
    /**
     * This endpoint will return a list of libraries
     * @summary Get All Libraries
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    getLibraries(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * This endpoint will return a list of library items filtered by the filter and type provided
     * @summary Get Library Items
     * @param {any} sectionId the Id of the library to query
     * @param {any} category the category to retrieve from the library
     * @param {any} [type] item type
     * @param {any} [filter] the filter parameter
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    getLibraryItems(sectionId: any, category: any, type?: any, filter?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * LibraryApi - factory interface
 * @export
 */
export declare const LibraryApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * This endpoint will return a list of libraries
     * @summary Get All Libraries
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    getLibraries(axiosOptions?: any): AxiosPromise<void>;
    /**
     * This endpoint will return a list of library items filtered by the filter and type provided
     * @summary Get Library Items
     * @param {any} sectionId the Id of the library to query
     * @param {any} category the category to retrieve from the library
     * @param {any} [type] item type
     * @param {any} [filter] the filter parameter
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    getLibraryItems(sectionId: any, category: any, type?: any, filter?: any, axiosOptions?: any): AxiosPromise<void>;
};
/**
 * Request parameters for getLibraryItems operation in LibraryApi.
 * @export
 * @interface LibraryApiGetLibraryItemsRequest
 */
export interface LibraryApiGetLibraryItemsRequest {
    /**
     * the Id of the library to query
     * @type {any}
     * @memberof LibraryApiGetLibraryItems
     */
    readonly sectionId: any;
    /**
     * the category to retrieve from the library
     * @type {any}
     * @memberof LibraryApiGetLibraryItems
     */
    readonly category: any;
    /**
     * item type
     * @type {any}
     * @memberof LibraryApiGetLibraryItems
     */
    readonly type?: any;
    /**
     * the filter parameter
     * @type {any}
     * @memberof LibraryApiGetLibraryItems
     */
    readonly filter?: any;
}
/**
 * LibraryApi - object-oriented interface
 * @export
 * @class LibraryApi
 * @extends {BaseAPI}
 */
export declare class LibraryApi extends BaseAPI {
    /**
     * This endpoint will return a list of libraries
     * @summary Get All Libraries
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getLibraries(axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * This endpoint will return a list of library items filtered by the filter and type provided
     * @summary Get Library Items
     * @param {LibraryApiGetLibraryItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    getLibraryItems(requestParameters: LibraryApiGetLibraryItemsRequest, axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * LogApi - axios parameter creator
 * @export
 */
export declare const LogApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time.
     * @summary Enabling Papertrail
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    enablePaperTrail: (axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above.
     * @summary Logging a multi-line message
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    logMultipleLines: (axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log.
     * @summary Logging a single line message.
     * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose
     * @param {any} message The text of the message to write to the log.
     * @param {any} source a string indicating the source of the message.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    logaLine: (level: any, message: any, source: any, axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * LogApi - functional programming interface
 * @export
 */
export declare const LogApiFp: (configuration?: Configuration) => {
    /**
     * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time.
     * @summary Enabling Papertrail
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    enablePaperTrail(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above.
     * @summary Logging a multi-line message
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    logMultipleLines(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log.
     * @summary Logging a single line message.
     * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose
     * @param {any} message The text of the message to write to the log.
     * @param {any} source a string indicating the source of the message.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    logaLine(level: any, message: any, source: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * LogApi - factory interface
 * @export
 */
export declare const LogApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time.
     * @summary Enabling Papertrail
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    enablePaperTrail(axiosOptions?: any): AxiosPromise<void>;
    /**
     * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above.
     * @summary Logging a multi-line message
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    logMultipleLines(axiosOptions?: any): AxiosPromise<void>;
    /**
     * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log.
     * @summary Logging a single line message.
     * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose
     * @param {any} message The text of the message to write to the log.
     * @param {any} source a string indicating the source of the message.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    logaLine(level: any, message: any, source: any, axiosOptions?: any): AxiosPromise<void>;
};
/**
 * Request parameters for logaLine operation in LogApi.
 * @export
 * @interface LogApiLogaLineRequest
 */
export interface LogApiLogaLineRequest {
    /**
     * An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose
     * @type {any}
     * @memberof LogApiLogaLine
     */
    readonly level: any;
    /**
     * The text of the message to write to the log.
     * @type {any}
     * @memberof LogApiLogaLine
     */
    readonly message: any;
    /**
     * a string indicating the source of the message.
     * @type {any}
     * @memberof LogApiLogaLine
     */
    readonly source: any;
}
/**
 * LogApi - object-oriented interface
 * @export
 * @class LogApi
 * @extends {BaseAPI}
 */
export declare class LogApi extends BaseAPI {
    /**
     * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time.
     * @summary Enabling Papertrail
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    enablePaperTrail(axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above.
     * @summary Logging a multi-line message
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    logMultipleLines(axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log.
     * @summary Logging a single line message.
     * @param {LogApiLogaLineRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    logaLine(requestParameters: LogApiLogaLineRequest, axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * SecurityApi - axios parameter creator
 * @export
 */
export declare const SecurityApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4.
     * @summary Get Source Connection Information
     * @param {any} source The source identifier with an included prefix.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    getConnectionInformation: (source: any, axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted.
     * @summary Get a Transient Token.
     * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
     * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    getTransientToken: (type: any, scope: any, axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * SecurityApi - functional programming interface
 * @export
 */
export declare const SecurityApiFp: (configuration?: Configuration) => {
    /**
     * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4.
     * @summary Get Source Connection Information
     * @param {any} source The source identifier with an included prefix.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    getConnectionInformation(source: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted.
     * @summary Get a Transient Token.
     * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
     * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    getTransientToken(type: any, scope: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * SecurityApi - factory interface
 * @export
 */
export declare const SecurityApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4.
     * @summary Get Source Connection Information
     * @param {any} source The source identifier with an included prefix.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    getConnectionInformation(source: any, axiosOptions?: any): AxiosPromise<void>;
    /**
     * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted.
     * @summary Get a Transient Token.
     * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
     * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    getTransientToken(type: any, scope: any, axiosOptions?: any): AxiosPromise<void>;
};
/**
 * Request parameters for getConnectionInformation operation in SecurityApi.
 * @export
 * @interface SecurityApiGetConnectionInformationRequest
 */
export interface SecurityApiGetConnectionInformationRequest {
    /**
     * The source identifier with an included prefix.
     * @type {any}
     * @memberof SecurityApiGetConnectionInformation
     */
    readonly source: any;
}
/**
 * Request parameters for getTransientToken operation in SecurityApi.
 * @export
 * @interface SecurityApiGetTransientTokenRequest
 */
export interface SecurityApiGetTransientTokenRequest {
    /**
     * &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
     * @type {any}
     * @memberof SecurityApiGetTransientToken
     */
    readonly type: any;
    /**
     * &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
     * @type {any}
     * @memberof SecurityApiGetTransientToken
     */
    readonly scope: any;
}
/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export declare class SecurityApi extends BaseAPI {
    /**
     * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4.
     * @summary Get Source Connection Information
     * @param {SecurityApiGetConnectionInformationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    getConnectionInformation(requestParameters: SecurityApiGetConnectionInformationRequest, axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted.
     * @summary Get a Transient Token.
     * @param {SecurityApiGetTransientTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    getTransientToken(requestParameters: SecurityApiGetTransientTokenRequest, axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * ServerApi - axios parameter creator
 * @export
 */
export declare const ServerApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Server Capabilities
     * @summary Server Capabilities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    serverCapabilities: (axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ServerApi - functional programming interface
 * @export
 */
export declare const ServerApiFp: (configuration?: Configuration) => {
    /**
     * Server Capabilities
     * @summary Server Capabilities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    serverCapabilities(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerCapabilities200Response>>;
};
/**
 * ServerApi - factory interface
 * @export
 */
export declare const ServerApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Server Capabilities
     * @summary Server Capabilities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    serverCapabilities(axiosOptions?: any): AxiosPromise<ServerCapabilities200Response>;
};
/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export declare class ServerApi extends BaseAPI {
    /**
     * Server Capabilities
     * @summary Server Capabilities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    serverCapabilities(axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<ServerCapabilities200Response, any>>;
}
/**
 * UpdaterApi - axios parameter creator
 * @export
 */
export declare const UpdaterApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed
     * @summary Applying updates
     * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
     * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    applyingUpdates: (tonight?: any, skip?: any, axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Checking for updates
     * @summary Checking for updates
     * @param {any} [download] Indicate that you want to start download any updates found.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    checkingforUpdates: (download?: any, axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Querying status of updates
     * @summary Querying status of updates
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    queryingUpdateStatus: (axiosOptions?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UpdaterApi - functional programming interface
 * @export
 */
export declare const UpdaterApiFp: (configuration?: Configuration) => {
    /**
     * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed
     * @summary Applying updates
     * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
     * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    applyingUpdates(tonight?: any, skip?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Checking for updates
     * @summary Checking for updates
     * @param {any} [download] Indicate that you want to start download any updates found.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    checkingforUpdates(download?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Querying status of updates
     * @summary Querying status of updates
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    queryingUpdateStatus(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * UpdaterApi - factory interface
 * @export
 */
export declare const UpdaterApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed
     * @summary Applying updates
     * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
     * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    applyingUpdates(tonight?: any, skip?: any, axiosOptions?: any): AxiosPromise<void>;
    /**
     * Checking for updates
     * @summary Checking for updates
     * @param {any} [download] Indicate that you want to start download any updates found.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    checkingforUpdates(download?: any, axiosOptions?: any): AxiosPromise<void>;
    /**
     * Querying status of updates
     * @summary Querying status of updates
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     */
    queryingUpdateStatus(axiosOptions?: any): AxiosPromise<void>;
};
/**
 * Request parameters for applyingUpdates operation in UpdaterApi.
 * @export
 * @interface UpdaterApiApplyingUpdatesRequest
 */
export interface UpdaterApiApplyingUpdatesRequest {
    /**
     * Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
     * @type {any}
     * @memberof UpdaterApiApplyingUpdates
     */
    readonly tonight?: any;
    /**
     * Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
     * @type {any}
     * @memberof UpdaterApiApplyingUpdates
     */
    readonly skip?: any;
}
/**
 * Request parameters for checkingforUpdates operation in UpdaterApi.
 * @export
 * @interface UpdaterApiCheckingforUpdatesRequest
 */
export interface UpdaterApiCheckingforUpdatesRequest {
    /**
     * Indicate that you want to start download any updates found.
     * @type {any}
     * @memberof UpdaterApiCheckingforUpdates
     */
    readonly download?: any;
}
/**
 * UpdaterApi - object-oriented interface
 * @export
 * @class UpdaterApi
 * @extends {BaseAPI}
 */
export declare class UpdaterApi extends BaseAPI {
    /**
     * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed
     * @summary Applying updates
     * @param {UpdaterApiApplyingUpdatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    applyingUpdates(requestParameters?: UpdaterApiApplyingUpdatesRequest, axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Checking for updates
     * @summary Checking for updates
     * @param {UpdaterApiCheckingforUpdatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    checkingforUpdates(requestParameters?: UpdaterApiCheckingforUpdatesRequest, axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Querying status of updates
     * @summary Querying status of updates
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    queryingUpdateStatus(axiosOptions?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
