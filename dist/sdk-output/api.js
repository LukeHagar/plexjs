"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Plex-API
 * An Open API Spec for interacting with Plex.tv and Plex Servers
 *
 * The version of the OpenAPI document: 0.0.3
 * Contact: Lukeslakemail@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdaterApi = exports.UpdaterApiFactory = exports.UpdaterApiFp = exports.UpdaterApiAxiosParamCreator = exports.ServerApi = exports.ServerApiFactory = exports.ServerApiFp = exports.ServerApiAxiosParamCreator = exports.SecurityApi = exports.SecurityApiFactory = exports.SecurityApiFp = exports.SecurityApiAxiosParamCreator = exports.LogApi = exports.LogApiFactory = exports.LogApiFp = exports.LogApiAxiosParamCreator = exports.LibraryApi = exports.LibraryApiFactory = exports.LibraryApiFp = exports.LibraryApiAxiosParamCreator = exports.ButlerApi = exports.ButlerApiFactory = exports.ButlerApiFp = exports.ButlerApiAxiosParamCreator = exports.ActivitiesApi = exports.ActivitiesApiFactory = exports.ActivitiesApiFp = exports.ActivitiesApiAxiosParamCreator = void 0;
var axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("./common");
// @ts-ignore
var base_1 = require("./base");
/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
var ActivitiesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Cancel Server Activities
         * @summary Cancel Server Activities
         * @param {any} activityUUID The UUID of the activity to cancel.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelServerActivities: function (activityUUID, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'activityUUID' is not null or undefined
                            (0, common_1.assertParamExists)('cancelServerActivities', 'activityUUID', activityUUID);
                            localVarPath = "/activities/{activityUUID}"
                                .replace("{".concat("activityUUID", "}"), encodeURIComponent(String(activityUUID)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Server Activities
         * @summary Server Activities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        serverActivities: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/activities";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ActivitiesApiAxiosParamCreator = ActivitiesApiAxiosParamCreator;
/**
 * ActivitiesApi - functional programming interface
 * @export
 */
var ActivitiesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ActivitiesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Cancel Server Activities
         * @summary Cancel Server Activities
         * @param {any} activityUUID The UUID of the activity to cancel.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelServerActivities: function (activityUUID, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.cancelServerActivities(activityUUID, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Server Activities
         * @summary Server Activities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        serverActivities: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.serverActivities(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ActivitiesApiFp = ActivitiesApiFp;
/**
 * ActivitiesApi - factory interface
 * @export
 */
var ActivitiesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ActivitiesApiFp)(configuration);
    return {
        /**
         * Cancel Server Activities
         * @summary Cancel Server Activities
         * @param {any} activityUUID The UUID of the activity to cancel.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelServerActivities: function (activityUUID, axiosOptions) {
            return localVarFp.cancelServerActivities(activityUUID, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Server Activities
         * @summary Server Activities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        serverActivities: function (axiosOptions) {
            return localVarFp.serverActivities(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ActivitiesApiFactory = ActivitiesApiFactory;
/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
var ActivitiesApi = /** @class */ (function (_super) {
    __extends(ActivitiesApi, _super);
    function ActivitiesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Cancel Server Activities
     * @summary Cancel Server Activities
     * @param {ActivitiesApiCancelServerActivitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    ActivitiesApi.prototype.cancelServerActivities = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ActivitiesApiFp)(this.configuration).cancelServerActivities(requestParameters.activityUUID, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Server Activities
     * @summary Server Activities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    ActivitiesApi.prototype.serverActivities = function (axiosOptions) {
        var _this = this;
        return (0, exports.ActivitiesApiFp)(this.configuration).serverActivities(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ActivitiesApi;
}(base_1.BaseAPI));
exports.ActivitiesApi = ActivitiesApi;
/**
 * ButlerApi - axios parameter creator
 * @export
 */
var ButlerApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
         * @summary Start a single Butler task
         * @param {any} taskName the name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAButlerTasks: function (taskName, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'taskName' is not null or undefined
                            (0, common_1.assertParamExists)('startAButlerTasks', 'taskName', taskName);
                            localVarPath = "/butler/{taskName}"
                                .replace("{".concat("taskName", "}"), encodeURIComponent(String(taskName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
         * @summary Start all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAllButlerTasks: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/butler";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint.
         * @summary Stop a single Butler task
         * @param {any} taskName The name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAButlerTasks: function (taskName, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'taskName' is not null or undefined
                            (0, common_1.assertParamExists)('stopAButlerTasks', 'taskName', taskName);
                            localVarPath = "/butler/{taskName}"
                                .replace("{".concat("taskName", "}"), encodeURIComponent(String(taskName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue.
         * @summary Stop all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAllButlerTasks: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/butler";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ButlerApiAxiosParamCreator = ButlerApiAxiosParamCreator;
/**
 * ButlerApi - functional programming interface
 * @export
 */
var ButlerApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ButlerApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
         * @summary Start a single Butler task
         * @param {any} taskName the name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAButlerTasks: function (taskName, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startAButlerTasks(taskName, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
         * @summary Start all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAllButlerTasks: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startAllButlerTasks(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint.
         * @summary Stop a single Butler task
         * @param {any} taskName The name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAButlerTasks: function (taskName, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.stopAButlerTasks(taskName, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue.
         * @summary Stop all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAllButlerTasks: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.stopAllButlerTasks(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ButlerApiFp = ButlerApiFp;
/**
 * ButlerApi - factory interface
 * @export
 */
var ButlerApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ButlerApiFp)(configuration);
    return {
        /**
         * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
         * @summary Start a single Butler task
         * @param {any} taskName the name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAButlerTasks: function (taskName, axiosOptions) {
            return localVarFp.startAButlerTasks(taskName, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
         * @summary Start all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAllButlerTasks: function (axiosOptions) {
            return localVarFp.startAllButlerTasks(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint.
         * @summary Stop a single Butler task
         * @param {any} taskName The name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAButlerTasks: function (taskName, axiosOptions) {
            return localVarFp.stopAButlerTasks(taskName, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue.
         * @summary Stop all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAllButlerTasks: function (axiosOptions) {
            return localVarFp.stopAllButlerTasks(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ButlerApiFactory = ButlerApiFactory;
/**
 * ButlerApi - object-oriented interface
 * @export
 * @class ButlerApi
 * @extends {BaseAPI}
 */
var ButlerApi = /** @class */ (function (_super) {
    __extends(ButlerApi, _super);
    function ButlerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
     * @summary Start a single Butler task
     * @param {ButlerApiStartAButlerTasksRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    ButlerApi.prototype.startAButlerTasks = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ButlerApiFp)(this.configuration).startAButlerTasks(requestParameters.taskName, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
     * @summary Start all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    ButlerApi.prototype.startAllButlerTasks = function (axiosOptions) {
        var _this = this;
        return (0, exports.ButlerApiFp)(this.configuration).startAllButlerTasks(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint.
     * @summary Stop a single Butler task
     * @param {ButlerApiStopAButlerTasksRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    ButlerApi.prototype.stopAButlerTasks = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ButlerApiFp)(this.configuration).stopAButlerTasks(requestParameters.taskName, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue.
     * @summary Stop all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    ButlerApi.prototype.stopAllButlerTasks = function (axiosOptions) {
        var _this = this;
        return (0, exports.ButlerApiFp)(this.configuration).stopAllButlerTasks(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ButlerApi;
}(base_1.BaseAPI));
exports.ButlerApi = ButlerApi;
/**
 * LibraryApi - axios parameter creator
 * @export
 */
var LibraryApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This endpoint will return a list of libraries
         * @summary Get All Libraries
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraries: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/library/sections";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will return a list of library items filtered by the filter and type provided
         * @summary Get Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} category the category to retrieve from the library
         * @param {any} [type] item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItems: function (sectionId, category, type, filter, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sectionId' is not null or undefined
                            (0, common_1.assertParamExists)('getLibraryItems', 'sectionId', sectionId);
                            // verify required parameter 'category' is not null or undefined
                            (0, common_1.assertParamExists)('getLibraryItems', 'category', category);
                            localVarPath = "/library/sections/{sectionId}/{category}"
                                .replace("{".concat("sectionId", "}"), encodeURIComponent(String(sectionId)))
                                .replace("{".concat("category", "}"), encodeURIComponent(String(category)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            if (filter !== undefined) {
                                localVarQueryParameter['filter'] = filter;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.LibraryApiAxiosParamCreator = LibraryApiAxiosParamCreator;
/**
 * LibraryApi - functional programming interface
 * @export
 */
var LibraryApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.LibraryApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint will return a list of libraries
         * @summary Get All Libraries
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraries: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLibraries(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will return a list of library items filtered by the filter and type provided
         * @summary Get Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} category the category to retrieve from the library
         * @param {any} [type] item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItems: function (sectionId, category, type, filter, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLibraryItems(sectionId, category, type, filter, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.LibraryApiFp = LibraryApiFp;
/**
 * LibraryApi - factory interface
 * @export
 */
var LibraryApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.LibraryApiFp)(configuration);
    return {
        /**
         * This endpoint will return a list of libraries
         * @summary Get All Libraries
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraries: function (axiosOptions) {
            return localVarFp.getLibraries(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will return a list of library items filtered by the filter and type provided
         * @summary Get Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} category the category to retrieve from the library
         * @param {any} [type] item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItems: function (sectionId, category, type, filter, axiosOptions) {
            return localVarFp.getLibraryItems(sectionId, category, type, filter, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.LibraryApiFactory = LibraryApiFactory;
/**
 * LibraryApi - object-oriented interface
 * @export
 * @class LibraryApi
 * @extends {BaseAPI}
 */
var LibraryApi = /** @class */ (function (_super) {
    __extends(LibraryApi, _super);
    function LibraryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This endpoint will return a list of libraries
     * @summary Get All Libraries
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    LibraryApi.prototype.getLibraries = function (axiosOptions) {
        var _this = this;
        return (0, exports.LibraryApiFp)(this.configuration).getLibraries(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will return a list of library items filtered by the filter and type provided
     * @summary Get Library Items
     * @param {LibraryApiGetLibraryItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    LibraryApi.prototype.getLibraryItems = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LibraryApiFp)(this.configuration).getLibraryItems(requestParameters.sectionId, requestParameters.category, requestParameters.type, requestParameters.filter, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return LibraryApi;
}(base_1.BaseAPI));
exports.LibraryApi = LibraryApi;
/**
 * LogApi - axios parameter creator
 * @export
 */
var LogApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time.
         * @summary Enabling Papertrail
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enablePaperTrail: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/log/networked";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above.
         * @summary Logging a multi-line message
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logMultipleLines: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/log";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log.
         * @summary Logging a single line message.
         * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose
         * @param {any} message The text of the message to write to the log.
         * @param {any} source a string indicating the source of the message.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logaLine: function (level, message, source, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'level' is not null or undefined
                            (0, common_1.assertParamExists)('logaLine', 'level', level);
                            // verify required parameter 'message' is not null or undefined
                            (0, common_1.assertParamExists)('logaLine', 'message', message);
                            // verify required parameter 'source' is not null or undefined
                            (0, common_1.assertParamExists)('logaLine', 'source', source);
                            localVarPath = "/log";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (level !== undefined) {
                                localVarQueryParameter['level'] = level;
                            }
                            if (message !== undefined) {
                                localVarQueryParameter['message'] = message;
                            }
                            if (source !== undefined) {
                                localVarQueryParameter['source'] = source;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.LogApiAxiosParamCreator = LogApiAxiosParamCreator;
/**
 * LogApi - functional programming interface
 * @export
 */
var LogApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.LogApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time.
         * @summary Enabling Papertrail
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enablePaperTrail: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.enablePaperTrail(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above.
         * @summary Logging a multi-line message
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logMultipleLines: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.logMultipleLines(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log.
         * @summary Logging a single line message.
         * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose
         * @param {any} message The text of the message to write to the log.
         * @param {any} source a string indicating the source of the message.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logaLine: function (level, message, source, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.logaLine(level, message, source, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.LogApiFp = LogApiFp;
/**
 * LogApi - factory interface
 * @export
 */
var LogApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.LogApiFp)(configuration);
    return {
        /**
         * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time.
         * @summary Enabling Papertrail
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enablePaperTrail: function (axiosOptions) {
            return localVarFp.enablePaperTrail(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above.
         * @summary Logging a multi-line message
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logMultipleLines: function (axiosOptions) {
            return localVarFp.logMultipleLines(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log.
         * @summary Logging a single line message.
         * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose
         * @param {any} message The text of the message to write to the log.
         * @param {any} source a string indicating the source of the message.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logaLine: function (level, message, source, axiosOptions) {
            return localVarFp.logaLine(level, message, source, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.LogApiFactory = LogApiFactory;
/**
 * LogApi - object-oriented interface
 * @export
 * @class LogApi
 * @extends {BaseAPI}
 */
var LogApi = /** @class */ (function (_super) {
    __extends(LogApi, _super);
    function LogApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time.
     * @summary Enabling Papertrail
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    LogApi.prototype.enablePaperTrail = function (axiosOptions) {
        var _this = this;
        return (0, exports.LogApiFp)(this.configuration).enablePaperTrail(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above.
     * @summary Logging a multi-line message
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    LogApi.prototype.logMultipleLines = function (axiosOptions) {
        var _this = this;
        return (0, exports.LogApiFp)(this.configuration).logMultipleLines(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log.
     * @summary Logging a single line message.
     * @param {LogApiLogaLineRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    LogApi.prototype.logaLine = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LogApiFp)(this.configuration).logaLine(requestParameters.level, requestParameters.message, requestParameters.source, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return LogApi;
}(base_1.BaseAPI));
exports.LogApi = LogApi;
/**
 * SecurityApi - axios parameter creator
 * @export
 */
var SecurityApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4.
         * @summary Get Source Connection Information
         * @param {any} source The source identifier with an included prefix.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionInformation: function (source, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'source' is not null or undefined
                            (0, common_1.assertParamExists)('getConnectionInformation', 'source', source);
                            localVarPath = "/security/resources";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (source !== undefined) {
                                localVarQueryParameter['source'] = source;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted.
         * @summary Get a Transient Token.
         * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
         * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransientToken: function (type, scope, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('getTransientToken', 'type', type);
                            // verify required parameter 'scope' is not null or undefined
                            (0, common_1.assertParamExists)('getTransientToken', 'scope', scope);
                            localVarPath = "/security/token";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            if (scope !== undefined) {
                                localVarQueryParameter['scope'] = scope;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SecurityApiAxiosParamCreator = SecurityApiAxiosParamCreator;
/**
 * SecurityApi - functional programming interface
 * @export
 */
var SecurityApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SecurityApiAxiosParamCreator)(configuration);
    return {
        /**
         * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4.
         * @summary Get Source Connection Information
         * @param {any} source The source identifier with an included prefix.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionInformation: function (source, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getConnectionInformation(source, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted.
         * @summary Get a Transient Token.
         * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
         * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransientToken: function (type, scope, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getTransientToken(type, scope, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SecurityApiFp = SecurityApiFp;
/**
 * SecurityApi - factory interface
 * @export
 */
var SecurityApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SecurityApiFp)(configuration);
    return {
        /**
         * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4.
         * @summary Get Source Connection Information
         * @param {any} source The source identifier with an included prefix.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionInformation: function (source, axiosOptions) {
            return localVarFp.getConnectionInformation(source, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted.
         * @summary Get a Transient Token.
         * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
         * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransientToken: function (type, scope, axiosOptions) {
            return localVarFp.getTransientToken(type, scope, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SecurityApiFactory = SecurityApiFactory;
/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
var SecurityApi = /** @class */ (function (_super) {
    __extends(SecurityApi, _super);
    function SecurityApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4.
     * @summary Get Source Connection Information
     * @param {SecurityApiGetConnectionInformationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    SecurityApi.prototype.getConnectionInformation = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SecurityApiFp)(this.configuration).getConnectionInformation(requestParameters.source, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted.
     * @summary Get a Transient Token.
     * @param {SecurityApiGetTransientTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    SecurityApi.prototype.getTransientToken = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SecurityApiFp)(this.configuration).getTransientToken(requestParameters.type, requestParameters.scope, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SecurityApi;
}(base_1.BaseAPI));
exports.SecurityApi = SecurityApi;
/**
 * ServerApi - axios parameter creator
 * @export
 */
var ServerApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Server Capabilities
         * @summary Server Capabilities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        serverCapabilities: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ServerApiAxiosParamCreator = ServerApiAxiosParamCreator;
/**
 * ServerApi - functional programming interface
 * @export
 */
var ServerApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ServerApiAxiosParamCreator)(configuration);
    return {
        /**
         * Server Capabilities
         * @summary Server Capabilities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        serverCapabilities: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.serverCapabilities(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ServerApiFp = ServerApiFp;
/**
 * ServerApi - factory interface
 * @export
 */
var ServerApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ServerApiFp)(configuration);
    return {
        /**
         * Server Capabilities
         * @summary Server Capabilities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        serverCapabilities: function (axiosOptions) {
            return localVarFp.serverCapabilities(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ServerApiFactory = ServerApiFactory;
/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
var ServerApi = /** @class */ (function (_super) {
    __extends(ServerApi, _super);
    function ServerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Server Capabilities
     * @summary Server Capabilities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    ServerApi.prototype.serverCapabilities = function (axiosOptions) {
        var _this = this;
        return (0, exports.ServerApiFp)(this.configuration).serverCapabilities(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ServerApi;
}(base_1.BaseAPI));
exports.ServerApi = ServerApi;
/**
 * UpdaterApi - axios parameter creator
 * @export
 */
var UpdaterApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed
         * @summary Applying updates
         * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
         * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        applyingUpdates: function (tonight, skip, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/updater/apply";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (tonight !== undefined) {
                                localVarQueryParameter['tonight'] = tonight;
                            }
                            if (skip !== undefined) {
                                localVarQueryParameter['skip'] = skip;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Checking for updates
         * @summary Checking for updates
         * @param {any} [download] Indicate that you want to start download any updates found.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        checkingforUpdates: function (download, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/updater/check";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (download !== undefined) {
                                localVarQueryParameter['download'] = download;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Querying status of updates
         * @summary Querying status of updates
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryingUpdateStatus: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/updater/status";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.UpdaterApiAxiosParamCreator = UpdaterApiAxiosParamCreator;
/**
 * UpdaterApi - functional programming interface
 * @export
 */
var UpdaterApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.UpdaterApiAxiosParamCreator)(configuration);
    return {
        /**
         * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed
         * @summary Applying updates
         * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
         * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        applyingUpdates: function (tonight, skip, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.applyingUpdates(tonight, skip, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Checking for updates
         * @summary Checking for updates
         * @param {any} [download] Indicate that you want to start download any updates found.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        checkingforUpdates: function (download, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.checkingforUpdates(download, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Querying status of updates
         * @summary Querying status of updates
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryingUpdateStatus: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.queryingUpdateStatus(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.UpdaterApiFp = UpdaterApiFp;
/**
 * UpdaterApi - factory interface
 * @export
 */
var UpdaterApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.UpdaterApiFp)(configuration);
    return {
        /**
         * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed
         * @summary Applying updates
         * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
         * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        applyingUpdates: function (tonight, skip, axiosOptions) {
            return localVarFp.applyingUpdates(tonight, skip, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Checking for updates
         * @summary Checking for updates
         * @param {any} [download] Indicate that you want to start download any updates found.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        checkingforUpdates: function (download, axiosOptions) {
            return localVarFp.checkingforUpdates(download, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Querying status of updates
         * @summary Querying status of updates
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryingUpdateStatus: function (axiosOptions) {
            return localVarFp.queryingUpdateStatus(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.UpdaterApiFactory = UpdaterApiFactory;
/**
 * UpdaterApi - object-oriented interface
 * @export
 * @class UpdaterApi
 * @extends {BaseAPI}
 */
var UpdaterApi = /** @class */ (function (_super) {
    __extends(UpdaterApi, _super);
    function UpdaterApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed
     * @summary Applying updates
     * @param {UpdaterApiApplyingUpdatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    UpdaterApi.prototype.applyingUpdates = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.UpdaterApiFp)(this.configuration).applyingUpdates(requestParameters.tonight, requestParameters.skip, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Checking for updates
     * @summary Checking for updates
     * @param {UpdaterApiCheckingforUpdatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    UpdaterApi.prototype.checkingforUpdates = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.UpdaterApiFp)(this.configuration).checkingforUpdates(requestParameters.download, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Querying status of updates
     * @summary Querying status of updates
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    UpdaterApi.prototype.queryingUpdateStatus = function (axiosOptions) {
        var _this = this;
        return (0, exports.UpdaterApiFp)(this.configuration).queryingUpdateStatus(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return UpdaterApi;
}(base_1.BaseAPI));
exports.UpdaterApi = UpdaterApi;
//# sourceMappingURL=api.js.map