"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Plex-API
 * An Open API Spec for interacting with Plex.tv and Plex Servers
 *
 * The version of the OpenAPI document: 0.0.3
 * Contact: Lukeslakemail@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionsApiFp = exports.SessionsApiAxiosParamCreator = exports.ServerApi = exports.ServerApiFactory = exports.ServerApiFp = exports.ServerApiAxiosParamCreator = exports.SecurityApi = exports.SecurityApiFactory = exports.SecurityApiFp = exports.SecurityApiAxiosParamCreator = exports.SearchApi = exports.SearchApiFactory = exports.SearchApiFp = exports.SearchApiAxiosParamCreator = exports.PlaylistsApi = exports.PlaylistsApiFactory = exports.PlaylistsApiFp = exports.PlaylistsApiAxiosParamCreator = exports.LogApi = exports.LogApiFactory = exports.LogApiFp = exports.LogApiAxiosParamCreator = exports.LibraryApi = exports.LibraryApiFactory = exports.LibraryApiFp = exports.LibraryApiAxiosParamCreator = exports.HubsApi = exports.HubsApiFactory = exports.HubsApiFp = exports.HubsApiAxiosParamCreator = exports.HashesApi = exports.HashesApiFactory = exports.HashesApiFp = exports.HashesApiAxiosParamCreator = exports.DevicesApi = exports.DevicesApiFactory = exports.DevicesApiFp = exports.DevicesApiAxiosParamCreator = exports.ButlerApi = exports.ButlerApiFactory = exports.ButlerApiFp = exports.ButlerApiAxiosParamCreator = exports.AuthenticationApi = exports.AuthenticationApiFactory = exports.AuthenticationApiFp = exports.AuthenticationApiAxiosParamCreator = exports.ActivitiesApi = exports.ActivitiesApiFactory = exports.ActivitiesApiFp = exports.ActivitiesApiAxiosParamCreator = void 0;
exports.UserApi = exports.UserApiFactory = exports.UserApiFp = exports.UserApiAxiosParamCreator = exports.UpdaterApi = exports.UpdaterApiFactory = exports.UpdaterApiFp = exports.UpdaterApiAxiosParamCreator = exports.SessionsApi = exports.SessionsApiFactory = void 0;
var axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("./common");
// @ts-ignore
var base_1 = require("./base");
/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
var ActivitiesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Cancel Server Activities
         * @summary Cancel Server Activities
         * @param {any} activityUUID The UUID of the activity to cancel.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelServerActivities: function (activityUUID, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'activityUUID' is not null or undefined
                            (0, common_1.assertParamExists)('cancelServerActivities', 'activityUUID', activityUUID);
                            localVarPath = "/activities/{activityUUID}"
                                .replace("{".concat("activityUUID", "}"), encodeURIComponent(String(activityUUID)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Server Activities
         * @summary Server Activities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerActivities: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/activities";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ActivitiesApiAxiosParamCreator = ActivitiesApiAxiosParamCreator;
/**
 * ActivitiesApi - functional programming interface
 * @export
 */
var ActivitiesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ActivitiesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Cancel Server Activities
         * @summary Cancel Server Activities
         * @param {any} activityUUID The UUID of the activity to cancel.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelServerActivities: function (activityUUID, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.cancelServerActivities(activityUUID, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Server Activities
         * @summary Server Activities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerActivities: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getServerActivities(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ActivitiesApiFp = ActivitiesApiFp;
/**
 * ActivitiesApi - factory interface
 * @export
 */
var ActivitiesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ActivitiesApiFp)(configuration);
    return {
        /**
         * Cancel Server Activities
         * @summary Cancel Server Activities
         * @param {any} activityUUID The UUID of the activity to cancel.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelServerActivities: function (activityUUID, axiosOptions) {
            return localVarFp.cancelServerActivities(activityUUID, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Server Activities
         * @summary Server Activities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerActivities: function (axiosOptions) {
            return localVarFp.getServerActivities(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ActivitiesApiFactory = ActivitiesApiFactory;
/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
var ActivitiesApi = /** @class */ (function (_super) {
    __extends(ActivitiesApi, _super);
    function ActivitiesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Cancel Server Activities
     * @summary Cancel Server Activities
     * @param {ActivitiesApiCancelServerActivitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    ActivitiesApi.prototype.cancelServerActivities = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ActivitiesApiFp)(this.configuration).cancelServerActivities(requestParameters.activityUUID, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Server Activities
     * @summary Server Activities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    ActivitiesApi.prototype.getServerActivities = function (axiosOptions) {
        var _this = this;
        return (0, exports.ActivitiesApiFp)(this.configuration).getServerActivities(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ActivitiesApi;
}(base_1.BaseAPI));
exports.ActivitiesApi = ActivitiesApi;
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
var AuthenticationApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Retrieve a Pin from Plex.tv for authentication flows
         * @summary Get a Pin
         * @param {any} xPlexClientIdentifier Unique Id, UUID, serial number, or other number unique per device that identifies your client
         * @param {any} [strong] Determines the kind of code returned by the API call Strong codes are used for Pin authentication flows Non-Strong codes are used for &#x60;Plex.tv/link&#x60;
         * @param {any} [xPlexDeviceName] Primary name for the device eg. &#x60;Plex Web (Chrome)&#x60;
         * @param {any} [xPlexDevice] The type of device your application is running on Device name and or model number, eg &#x60;iPhone3,2&#x60;, &#x60;Motorola XOOM™&#x60;, &#x60;LG5200TV&#x60;
         * @param {any} [xPlexPlatformVersion] Operating system version, eg &#x60;4.3.1&#x60;, &#x60;10.6.7&#x60;, &#x60;3.2&#x60;
         * @param {any} [xPlexPlatform] Platform name, eg &#x60;Web&#x60;, &#x60;iOS&#x60;, &#x60;MacOSX&#x60;, &#x60;Android&#x60;, &#x60;LG&#x60;
         * @param {any} [xPlexProduct] Plex application name, eg &#x60;Laika&#x60;, &#x60;Plex Media Server&#x60;, &#x60;Media Link&#x60;
         * @param {any} [xPlexProvides] One or more of &#x60;[player, controller, server]&#x60;
         * @param {any} [xPlexVersion] Your application version number
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPin: function (xPlexClientIdentifier, strong, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'xPlexClientIdentifier' is not null or undefined
                            (0, common_1.assertParamExists)('getPin', 'xPlexClientIdentifier', xPlexClientIdentifier);
                            localVarPath = "/pins";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (strong !== undefined) {
                                localVarQueryParameter['strong'] = strong;
                            }
                            if (xPlexClientIdentifier !== undefined && xPlexClientIdentifier !== null) {
                                localVarHeaderParameter['X-Plex-Client-Identifier'] = String(JSON.stringify(xPlexClientIdentifier));
                            }
                            if (xPlexDeviceName !== undefined && xPlexDeviceName !== null) {
                                localVarHeaderParameter['X-Plex-Device-Name'] = String(JSON.stringify(xPlexDeviceName));
                            }
                            if (xPlexDevice !== undefined && xPlexDevice !== null) {
                                localVarHeaderParameter['X-Plex-Device'] = String(JSON.stringify(xPlexDevice));
                            }
                            if (xPlexPlatformVersion !== undefined && xPlexPlatformVersion !== null) {
                                localVarHeaderParameter['X-Plex-Platform-Version'] = String(JSON.stringify(xPlexPlatformVersion));
                            }
                            if (xPlexPlatform !== undefined && xPlexPlatform !== null) {
                                localVarHeaderParameter['X-Plex-Platform'] = String(JSON.stringify(xPlexPlatform));
                            }
                            if (xPlexProduct !== undefined && xPlexProduct !== null) {
                                localVarHeaderParameter['X-Plex-Product'] = String(JSON.stringify(xPlexProduct));
                            }
                            if (xPlexProvides !== undefined && xPlexProvides !== null) {
                                localVarHeaderParameter['X-Plex-Provides'] = String(JSON.stringify(xPlexProvides));
                            }
                            if (xPlexVersion !== undefined && xPlexVersion !== null) {
                                localVarHeaderParameter['X-Plex-Version'] = String(JSON.stringify(xPlexVersion));
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieve a Pin from Plex.tv for authentication flows
         * @summary Get Access Token
         * @param {any} pinID The PinID to retrieve an access token for
         * @param {any} xPlexClientIdentifier Unique Id, UUID, serial number, or other number unique per device that identifies your client
         * @param {any} [xPlexDeviceName] Primary name for the device eg. &#x60;Plex Web (Chrome)&#x60;
         * @param {any} [xPlexDevice] The type of device your application is running on Device name and or model number, eg &#x60;iPhone3,2&#x60;, &#x60;Motorola XOOM™&#x60;, &#x60;LG5200TV&#x60;
         * @param {any} [xPlexPlatformVersion] Operating system version, eg &#x60;4.3.1&#x60;, &#x60;10.6.7&#x60;, &#x60;3.2&#x60;
         * @param {any} [xPlexPlatform] Platform name, eg &#x60;Web&#x60;, &#x60;iOS&#x60;, &#x60;MacOSX&#x60;, &#x60;Android&#x60;, &#x60;LG&#x60;
         * @param {any} [xPlexProduct] Plex application name, eg &#x60;Laika&#x60;, &#x60;Plex Media Server&#x60;, &#x60;Media Link&#x60;
         * @param {any} [xPlexProvides] One or more of &#x60;[player, controller, server]&#x60;
         * @param {any} [xPlexVersion] Your application version number
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getToken: function (pinID, xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'pinID' is not null or undefined
                            (0, common_1.assertParamExists)('getToken', 'pinID', pinID);
                            // verify required parameter 'xPlexClientIdentifier' is not null or undefined
                            (0, common_1.assertParamExists)('getToken', 'xPlexClientIdentifier', xPlexClientIdentifier);
                            localVarPath = "/pins/{pinID}"
                                .replace("{".concat("pinID", "}"), encodeURIComponent(String(pinID)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (xPlexClientIdentifier !== undefined && xPlexClientIdentifier !== null) {
                                localVarHeaderParameter['X-Plex-Client-Identifier'] = String(JSON.stringify(xPlexClientIdentifier));
                            }
                            if (xPlexDeviceName !== undefined && xPlexDeviceName !== null) {
                                localVarHeaderParameter['X-Plex-Device-Name'] = String(JSON.stringify(xPlexDeviceName));
                            }
                            if (xPlexDevice !== undefined && xPlexDevice !== null) {
                                localVarHeaderParameter['X-Plex-Device'] = String(JSON.stringify(xPlexDevice));
                            }
                            if (xPlexPlatformVersion !== undefined && xPlexPlatformVersion !== null) {
                                localVarHeaderParameter['X-Plex-Platform-Version'] = String(JSON.stringify(xPlexPlatformVersion));
                            }
                            if (xPlexPlatform !== undefined && xPlexPlatform !== null) {
                                localVarHeaderParameter['X-Plex-Platform'] = String(JSON.stringify(xPlexPlatform));
                            }
                            if (xPlexProduct !== undefined && xPlexProduct !== null) {
                                localVarHeaderParameter['X-Plex-Product'] = String(JSON.stringify(xPlexProduct));
                            }
                            if (xPlexProvides !== undefined && xPlexProvides !== null) {
                                localVarHeaderParameter['X-Plex-Provides'] = String(JSON.stringify(xPlexProvides));
                            }
                            if (xPlexVersion !== undefined && xPlexVersion !== null) {
                                localVarHeaderParameter['X-Plex-Version'] = String(JSON.stringify(xPlexVersion));
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.AuthenticationApiAxiosParamCreator = AuthenticationApiAxiosParamCreator;
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
var AuthenticationApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.AuthenticationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve a Pin from Plex.tv for authentication flows
         * @summary Get a Pin
         * @param {any} xPlexClientIdentifier Unique Id, UUID, serial number, or other number unique per device that identifies your client
         * @param {any} [strong] Determines the kind of code returned by the API call Strong codes are used for Pin authentication flows Non-Strong codes are used for &#x60;Plex.tv/link&#x60;
         * @param {any} [xPlexDeviceName] Primary name for the device eg. &#x60;Plex Web (Chrome)&#x60;
         * @param {any} [xPlexDevice] The type of device your application is running on Device name and or model number, eg &#x60;iPhone3,2&#x60;, &#x60;Motorola XOOM™&#x60;, &#x60;LG5200TV&#x60;
         * @param {any} [xPlexPlatformVersion] Operating system version, eg &#x60;4.3.1&#x60;, &#x60;10.6.7&#x60;, &#x60;3.2&#x60;
         * @param {any} [xPlexPlatform] Platform name, eg &#x60;Web&#x60;, &#x60;iOS&#x60;, &#x60;MacOSX&#x60;, &#x60;Android&#x60;, &#x60;LG&#x60;
         * @param {any} [xPlexProduct] Plex application name, eg &#x60;Laika&#x60;, &#x60;Plex Media Server&#x60;, &#x60;Media Link&#x60;
         * @param {any} [xPlexProvides] One or more of &#x60;[player, controller, server]&#x60;
         * @param {any} [xPlexVersion] Your application version number
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPin: function (xPlexClientIdentifier, strong, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPin(xPlexClientIdentifier, strong, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieve a Pin from Plex.tv for authentication flows
         * @summary Get Access Token
         * @param {any} pinID The PinID to retrieve an access token for
         * @param {any} xPlexClientIdentifier Unique Id, UUID, serial number, or other number unique per device that identifies your client
         * @param {any} [xPlexDeviceName] Primary name for the device eg. &#x60;Plex Web (Chrome)&#x60;
         * @param {any} [xPlexDevice] The type of device your application is running on Device name and or model number, eg &#x60;iPhone3,2&#x60;, &#x60;Motorola XOOM™&#x60;, &#x60;LG5200TV&#x60;
         * @param {any} [xPlexPlatformVersion] Operating system version, eg &#x60;4.3.1&#x60;, &#x60;10.6.7&#x60;, &#x60;3.2&#x60;
         * @param {any} [xPlexPlatform] Platform name, eg &#x60;Web&#x60;, &#x60;iOS&#x60;, &#x60;MacOSX&#x60;, &#x60;Android&#x60;, &#x60;LG&#x60;
         * @param {any} [xPlexProduct] Plex application name, eg &#x60;Laika&#x60;, &#x60;Plex Media Server&#x60;, &#x60;Media Link&#x60;
         * @param {any} [xPlexProvides] One or more of &#x60;[player, controller, server]&#x60;
         * @param {any} [xPlexVersion] Your application version number
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getToken: function (pinID, xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getToken(pinID, xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.AuthenticationApiFp = AuthenticationApiFp;
/**
 * AuthenticationApi - factory interface
 * @export
 */
var AuthenticationApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.AuthenticationApiFp)(configuration);
    return {
        /**
         * Retrieve a Pin from Plex.tv for authentication flows
         * @summary Get a Pin
         * @param {any} xPlexClientIdentifier Unique Id, UUID, serial number, or other number unique per device that identifies your client
         * @param {any} [strong] Determines the kind of code returned by the API call Strong codes are used for Pin authentication flows Non-Strong codes are used for &#x60;Plex.tv/link&#x60;
         * @param {any} [xPlexDeviceName] Primary name for the device eg. &#x60;Plex Web (Chrome)&#x60;
         * @param {any} [xPlexDevice] The type of device your application is running on Device name and or model number, eg &#x60;iPhone3,2&#x60;, &#x60;Motorola XOOM™&#x60;, &#x60;LG5200TV&#x60;
         * @param {any} [xPlexPlatformVersion] Operating system version, eg &#x60;4.3.1&#x60;, &#x60;10.6.7&#x60;, &#x60;3.2&#x60;
         * @param {any} [xPlexPlatform] Platform name, eg &#x60;Web&#x60;, &#x60;iOS&#x60;, &#x60;MacOSX&#x60;, &#x60;Android&#x60;, &#x60;LG&#x60;
         * @param {any} [xPlexProduct] Plex application name, eg &#x60;Laika&#x60;, &#x60;Plex Media Server&#x60;, &#x60;Media Link&#x60;
         * @param {any} [xPlexProvides] One or more of &#x60;[player, controller, server]&#x60;
         * @param {any} [xPlexVersion] Your application version number
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPin: function (xPlexClientIdentifier, strong, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions) {
            return localVarFp.getPin(xPlexClientIdentifier, strong, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieve a Pin from Plex.tv for authentication flows
         * @summary Get Access Token
         * @param {any} pinID The PinID to retrieve an access token for
         * @param {any} xPlexClientIdentifier Unique Id, UUID, serial number, or other number unique per device that identifies your client
         * @param {any} [xPlexDeviceName] Primary name for the device eg. &#x60;Plex Web (Chrome)&#x60;
         * @param {any} [xPlexDevice] The type of device your application is running on Device name and or model number, eg &#x60;iPhone3,2&#x60;, &#x60;Motorola XOOM™&#x60;, &#x60;LG5200TV&#x60;
         * @param {any} [xPlexPlatformVersion] Operating system version, eg &#x60;4.3.1&#x60;, &#x60;10.6.7&#x60;, &#x60;3.2&#x60;
         * @param {any} [xPlexPlatform] Platform name, eg &#x60;Web&#x60;, &#x60;iOS&#x60;, &#x60;MacOSX&#x60;, &#x60;Android&#x60;, &#x60;LG&#x60;
         * @param {any} [xPlexProduct] Plex application name, eg &#x60;Laika&#x60;, &#x60;Plex Media Server&#x60;, &#x60;Media Link&#x60;
         * @param {any} [xPlexProvides] One or more of &#x60;[player, controller, server]&#x60;
         * @param {any} [xPlexVersion] Your application version number
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getToken: function (pinID, xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions) {
            return localVarFp.getToken(pinID, xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.AuthenticationApiFactory = AuthenticationApiFactory;
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
var AuthenticationApi = /** @class */ (function (_super) {
    __extends(AuthenticationApi, _super);
    function AuthenticationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieve a Pin from Plex.tv for authentication flows
     * @summary Get a Pin
     * @param {AuthenticationApiGetPinRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    AuthenticationApi.prototype.getPin = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AuthenticationApiFp)(this.configuration).getPin(requestParameters.xPlexClientIdentifier, requestParameters.strong, requestParameters.xPlexDeviceName, requestParameters.xPlexDevice, requestParameters.xPlexPlatformVersion, requestParameters.xPlexPlatform, requestParameters.xPlexProduct, requestParameters.xPlexProvides, requestParameters.xPlexVersion, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieve a Pin from Plex.tv for authentication flows
     * @summary Get Access Token
     * @param {AuthenticationApiGetTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    AuthenticationApi.prototype.getToken = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.AuthenticationApiFp)(this.configuration).getToken(requestParameters.pinID, requestParameters.xPlexClientIdentifier, requestParameters.xPlexDeviceName, requestParameters.xPlexDevice, requestParameters.xPlexPlatformVersion, requestParameters.xPlexPlatform, requestParameters.xPlexProduct, requestParameters.xPlexProvides, requestParameters.xPlexVersion, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return AuthenticationApi;
}(base_1.BaseAPI));
exports.AuthenticationApi = AuthenticationApi;
/**
 * ButlerApi - axios parameter creator
 * @export
 */
var ButlerApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
         * @summary Start all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAllTasks: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/butler";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
         * @summary Start a single Butler task
         * @param {any} taskName the name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startTask: function (taskName, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'taskName' is not null or undefined
                            (0, common_1.assertParamExists)('startTask', 'taskName', taskName);
                            localVarPath = "/butler/{taskName}"
                                .replace("{".concat("taskName", "}"), encodeURIComponent(String(taskName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue.
         * @summary Stop all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAllTasks: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/butler";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint.
         * @summary Stop a single Butler task
         * @param {any} taskName The name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopTask: function (taskName, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'taskName' is not null or undefined
                            (0, common_1.assertParamExists)('stopTask', 'taskName', taskName);
                            localVarPath = "/butler/{taskName}"
                                .replace("{".concat("taskName", "}"), encodeURIComponent(String(taskName)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ButlerApiAxiosParamCreator = ButlerApiAxiosParamCreator;
/**
 * ButlerApi - functional programming interface
 * @export
 */
var ButlerApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ButlerApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
         * @summary Start all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAllTasks: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startAllTasks(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
         * @summary Start a single Butler task
         * @param {any} taskName the name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startTask: function (taskName, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.startTask(taskName, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue.
         * @summary Stop all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAllTasks: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.stopAllTasks(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint.
         * @summary Stop a single Butler task
         * @param {any} taskName The name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopTask: function (taskName, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.stopTask(taskName, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ButlerApiFp = ButlerApiFp;
/**
 * ButlerApi - factory interface
 * @export
 */
var ButlerApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ButlerApiFp)(configuration);
    return {
        /**
         * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
         * @summary Start all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAllTasks: function (axiosOptions) {
            return localVarFp.startAllTasks(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
         * @summary Start a single Butler task
         * @param {any} taskName the name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startTask: function (taskName, axiosOptions) {
            return localVarFp.startTask(taskName, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue.
         * @summary Stop all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAllTasks: function (axiosOptions) {
            return localVarFp.stopAllTasks(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint.
         * @summary Stop a single Butler task
         * @param {any} taskName The name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopTask: function (taskName, axiosOptions) {
            return localVarFp.stopTask(taskName, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ButlerApiFactory = ButlerApiFactory;
/**
 * ButlerApi - object-oriented interface
 * @export
 * @class ButlerApi
 * @extends {BaseAPI}
 */
var ButlerApi = /** @class */ (function (_super) {
    __extends(ButlerApi, _super);
    function ButlerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
     * @summary Start all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    ButlerApi.prototype.startAllTasks = function (axiosOptions) {
        var _this = this;
        return (0, exports.ButlerApiFp)(this.configuration).startAllTasks(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately.
     * @summary Start a single Butler task
     * @param {ButlerApiStartTaskRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    ButlerApi.prototype.startTask = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ButlerApiFp)(this.configuration).startTask(requestParameters.taskName, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue.
     * @summary Stop all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    ButlerApi.prototype.stopAllTasks = function (axiosOptions) {
        var _this = this;
        return (0, exports.ButlerApiFp)(this.configuration).stopAllTasks(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint.
     * @summary Stop a single Butler task
     * @param {ButlerApiStopTaskRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    ButlerApi.prototype.stopTask = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.ButlerApiFp)(this.configuration).stopTask(requestParameters.taskName, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ButlerApi;
}(base_1.BaseAPI));
exports.ButlerApi = ButlerApi;
/**
 * DevicesApi - axios parameter creator
 * @export
 */
var DevicesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Get Available Clients
         * @summary Get Available Clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableClients: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/clients";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get Devices
         * @summary Get Devices
         * @param {any} xPlexClientIdentifier Unique Id, UUID, serial number, or other number unique per device that identifies your client
         * @param {any} [xPlexDeviceName] Primary name for the device eg. &#x60;Plex Web (Chrome)&#x60;
         * @param {any} [xPlexDevice] The type of device your application is running on Device name and or model number, eg &#x60;iPhone3,2&#x60;, &#x60;Motorola XOOM™&#x60;, &#x60;LG5200TV&#x60;
         * @param {any} [xPlexPlatformVersion] Operating system version, eg &#x60;4.3.1&#x60;, &#x60;10.6.7&#x60;, &#x60;3.2&#x60;
         * @param {any} [xPlexPlatform] Platform name, eg &#x60;Web&#x60;, &#x60;iOS&#x60;, &#x60;MacOSX&#x60;, &#x60;Android&#x60;, &#x60;LG&#x60;
         * @param {any} [xPlexProduct] Plex application name, eg &#x60;Laika&#x60;, &#x60;Plex Media Server&#x60;, &#x60;Media Link&#x60;
         * @param {any} [xPlexProvides] One or more of &#x60;[player, controller, server]&#x60;
         * @param {any} [xPlexVersion] Your application version number
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: function (xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'xPlexClientIdentifier' is not null or undefined
                            (0, common_1.assertParamExists)('getDevices', 'xPlexClientIdentifier', xPlexClientIdentifier);
                            localVarPath = "/resources";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (xPlexClientIdentifier !== undefined && xPlexClientIdentifier !== null) {
                                localVarHeaderParameter['X-Plex-Client-Identifier'] = String(JSON.stringify(xPlexClientIdentifier));
                            }
                            if (xPlexDeviceName !== undefined && xPlexDeviceName !== null) {
                                localVarHeaderParameter['X-Plex-Device-Name'] = String(JSON.stringify(xPlexDeviceName));
                            }
                            if (xPlexDevice !== undefined && xPlexDevice !== null) {
                                localVarHeaderParameter['X-Plex-Device'] = String(JSON.stringify(xPlexDevice));
                            }
                            if (xPlexPlatformVersion !== undefined && xPlexPlatformVersion !== null) {
                                localVarHeaderParameter['X-Plex-Platform-Version'] = String(JSON.stringify(xPlexPlatformVersion));
                            }
                            if (xPlexPlatform !== undefined && xPlexPlatform !== null) {
                                localVarHeaderParameter['X-Plex-Platform'] = String(JSON.stringify(xPlexPlatform));
                            }
                            if (xPlexProduct !== undefined && xPlexProduct !== null) {
                                localVarHeaderParameter['X-Plex-Product'] = String(JSON.stringify(xPlexProduct));
                            }
                            if (xPlexProvides !== undefined && xPlexProvides !== null) {
                                localVarHeaderParameter['X-Plex-Provides'] = String(JSON.stringify(xPlexProvides));
                            }
                            if (xPlexVersion !== undefined && xPlexVersion !== null) {
                                localVarHeaderParameter['X-Plex-Version'] = String(JSON.stringify(xPlexVersion));
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.DevicesApiAxiosParamCreator = DevicesApiAxiosParamCreator;
/**
 * DevicesApi - functional programming interface
 * @export
 */
var DevicesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.DevicesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get Available Clients
         * @summary Get Available Clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableClients: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAvailableClients(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get Devices
         * @summary Get Devices
         * @param {any} xPlexClientIdentifier Unique Id, UUID, serial number, or other number unique per device that identifies your client
         * @param {any} [xPlexDeviceName] Primary name for the device eg. &#x60;Plex Web (Chrome)&#x60;
         * @param {any} [xPlexDevice] The type of device your application is running on Device name and or model number, eg &#x60;iPhone3,2&#x60;, &#x60;Motorola XOOM™&#x60;, &#x60;LG5200TV&#x60;
         * @param {any} [xPlexPlatformVersion] Operating system version, eg &#x60;4.3.1&#x60;, &#x60;10.6.7&#x60;, &#x60;3.2&#x60;
         * @param {any} [xPlexPlatform] Platform name, eg &#x60;Web&#x60;, &#x60;iOS&#x60;, &#x60;MacOSX&#x60;, &#x60;Android&#x60;, &#x60;LG&#x60;
         * @param {any} [xPlexProduct] Plex application name, eg &#x60;Laika&#x60;, &#x60;Plex Media Server&#x60;, &#x60;Media Link&#x60;
         * @param {any} [xPlexProvides] One or more of &#x60;[player, controller, server]&#x60;
         * @param {any} [xPlexVersion] Your application version number
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: function (xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDevices(xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.DevicesApiFp = DevicesApiFp;
/**
 * DevicesApi - factory interface
 * @export
 */
var DevicesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.DevicesApiFp)(configuration);
    return {
        /**
         * Get Available Clients
         * @summary Get Available Clients
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableClients: function (axiosOptions) {
            return localVarFp.getAvailableClients(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get Devices
         * @summary Get Devices
         * @param {any} xPlexClientIdentifier Unique Id, UUID, serial number, or other number unique per device that identifies your client
         * @param {any} [xPlexDeviceName] Primary name for the device eg. &#x60;Plex Web (Chrome)&#x60;
         * @param {any} [xPlexDevice] The type of device your application is running on Device name and or model number, eg &#x60;iPhone3,2&#x60;, &#x60;Motorola XOOM™&#x60;, &#x60;LG5200TV&#x60;
         * @param {any} [xPlexPlatformVersion] Operating system version, eg &#x60;4.3.1&#x60;, &#x60;10.6.7&#x60;, &#x60;3.2&#x60;
         * @param {any} [xPlexPlatform] Platform name, eg &#x60;Web&#x60;, &#x60;iOS&#x60;, &#x60;MacOSX&#x60;, &#x60;Android&#x60;, &#x60;LG&#x60;
         * @param {any} [xPlexProduct] Plex application name, eg &#x60;Laika&#x60;, &#x60;Plex Media Server&#x60;, &#x60;Media Link&#x60;
         * @param {any} [xPlexProvides] One or more of &#x60;[player, controller, server]&#x60;
         * @param {any} [xPlexVersion] Your application version number
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: function (xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions) {
            return localVarFp.getDevices(xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.DevicesApiFactory = DevicesApiFactory;
/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
var DevicesApi = /** @class */ (function (_super) {
    __extends(DevicesApi, _super);
    function DevicesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get Available Clients
     * @summary Get Available Clients
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    DevicesApi.prototype.getAvailableClients = function (axiosOptions) {
        var _this = this;
        return (0, exports.DevicesApiFp)(this.configuration).getAvailableClients(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get Devices
     * @summary Get Devices
     * @param {DevicesApiGetDevicesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    DevicesApi.prototype.getDevices = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.DevicesApiFp)(this.configuration).getDevices(requestParameters.xPlexClientIdentifier, requestParameters.xPlexDeviceName, requestParameters.xPlexDevice, requestParameters.xPlexPlatformVersion, requestParameters.xPlexPlatform, requestParameters.xPlexProduct, requestParameters.xPlexProvides, requestParameters.xPlexVersion, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return DevicesApi;
}(base_1.BaseAPI));
exports.DevicesApi = DevicesApi;
/**
 * HashesApi - axios parameter creator
 * @export
 */
var HashesApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This resource returns hash values for local files
         * @summary Get Hash Value
         * @param {any} url This is the path to the local file, must be prefixed by &#x60;file://&#x60;
         * @param {any} [type] Item type
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getFileHash: function (url, type, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'url' is not null or undefined
                            (0, common_1.assertParamExists)('getFileHash', 'url', url);
                            localVarPath = "/library/hashes";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (url !== undefined) {
                                localVarQueryParameter['url'] = url;
                            }
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.HashesApiAxiosParamCreator = HashesApiAxiosParamCreator;
/**
 * HashesApi - functional programming interface
 * @export
 */
var HashesApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.HashesApiAxiosParamCreator)(configuration);
    return {
        /**
         * This resource returns hash values for local files
         * @summary Get Hash Value
         * @param {any} url This is the path to the local file, must be prefixed by &#x60;file://&#x60;
         * @param {any} [type] Item type
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getFileHash: function (url, type, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getFileHash(url, type, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.HashesApiFp = HashesApiFp;
/**
 * HashesApi - factory interface
 * @export
 */
var HashesApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.HashesApiFp)(configuration);
    return {
        /**
         * This resource returns hash values for local files
         * @summary Get Hash Value
         * @param {any} url This is the path to the local file, must be prefixed by &#x60;file://&#x60;
         * @param {any} [type] Item type
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getFileHash: function (url, type, axiosOptions) {
            return localVarFp.getFileHash(url, type, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.HashesApiFactory = HashesApiFactory;
/**
 * HashesApi - object-oriented interface
 * @export
 * @class HashesApi
 * @extends {BaseAPI}
 */
var HashesApi = /** @class */ (function (_super) {
    __extends(HashesApi, _super);
    function HashesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This resource returns hash values for local files
     * @summary Get Hash Value
     * @param {HashesApiGetFileHashRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof HashesApi
     */
    HashesApi.prototype.getFileHash = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.HashesApiFp)(this.configuration).getFileHash(requestParameters.url, requestParameters.type, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return HashesApi;
}(base_1.BaseAPI));
exports.HashesApi = HashesApi;
/**
 * HubsApi - axios parameter creator
 * @export
 */
var HubsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         *
         * @summary Get Global Hubs
         * @param {any} [count] The number of items to return with each hub.
         * @param {any} [onlyTransient] Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalHubs: function (count, onlyTransient, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/hubs";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (onlyTransient !== undefined) {
                                localVarQueryParameter['onlyTransient'] = onlyTransient;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will return a list of library specific hubs
         * @summary Get library specific hubs
         * @param {any} sectionId the Id of the library to query
         * @param {any} [count] The number of items to return with each hub.
         * @param {any} [onlyTransient] Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryHubs: function (sectionId, count, onlyTransient, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sectionId' is not null or undefined
                            (0, common_1.assertParamExists)('getLibraryHubs', 'sectionId', sectionId);
                            localVarPath = "/hubs/sections/{sectionId}"
                                .replace("{".concat("sectionId", "}"), encodeURIComponent(String(sectionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (count !== undefined) {
                                localVarQueryParameter['count'] = count;
                            }
                            if (onlyTransient !== undefined) {
                                localVarQueryParameter['onlyTransient'] = onlyTransient;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.HubsApiAxiosParamCreator = HubsApiAxiosParamCreator;
/**
 * HubsApi - functional programming interface
 * @export
 */
var HubsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.HubsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get Global Hubs
         * @param {any} [count] The number of items to return with each hub.
         * @param {any} [onlyTransient] Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalHubs: function (count, onlyTransient, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getGlobalHubs(count, onlyTransient, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will return a list of library specific hubs
         * @summary Get library specific hubs
         * @param {any} sectionId the Id of the library to query
         * @param {any} [count] The number of items to return with each hub.
         * @param {any} [onlyTransient] Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryHubs: function (sectionId, count, onlyTransient, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLibraryHubs(sectionId, count, onlyTransient, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.HubsApiFp = HubsApiFp;
/**
 * HubsApi - factory interface
 * @export
 */
var HubsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.HubsApiFp)(configuration);
    return {
        /**
         *
         * @summary Get Global Hubs
         * @param {any} [count] The number of items to return with each hub.
         * @param {any} [onlyTransient] Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalHubs: function (count, onlyTransient, axiosOptions) {
            return localVarFp.getGlobalHubs(count, onlyTransient, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will return a list of library specific hubs
         * @summary Get library specific hubs
         * @param {any} sectionId the Id of the library to query
         * @param {any} [count] The number of items to return with each hub.
         * @param {any} [onlyTransient] Only return hubs which are \&quot;transient\&quot;, meaning those which are prone to changing after media playback or addition (e.g. On Deck, or Recently Added).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryHubs: function (sectionId, count, onlyTransient, axiosOptions) {
            return localVarFp.getLibraryHubs(sectionId, count, onlyTransient, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.HubsApiFactory = HubsApiFactory;
/**
 * HubsApi - object-oriented interface
 * @export
 * @class HubsApi
 * @extends {BaseAPI}
 */
var HubsApi = /** @class */ (function (_super) {
    __extends(HubsApi, _super);
    function HubsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get Global Hubs
     * @param {HubsApiGetGlobalHubsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof HubsApi
     */
    HubsApi.prototype.getGlobalHubs = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.HubsApiFp)(this.configuration).getGlobalHubs(requestParameters.count, requestParameters.onlyTransient, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will return a list of library specific hubs
     * @summary Get library specific hubs
     * @param {HubsApiGetLibraryHubsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof HubsApi
     */
    HubsApi.prototype.getLibraryHubs = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.HubsApiFp)(this.configuration).getLibraryHubs(requestParameters.sectionId, requestParameters.count, requestParameters.onlyTransient, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return HubsApi;
}(base_1.BaseAPI));
exports.HubsApi = HubsApi;
/**
 * LibraryApi - axios parameter creator
 * @export
 */
var LibraryApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Represents a \"Common\" item. It contains only the common attributes of the items selected by the provided filter
         * @summary Get Common Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} type item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCommonLibraryItems: function (sectionId, type, filter, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sectionId' is not null or undefined
                            (0, common_1.assertParamExists)('getCommonLibraryItems', 'sectionId', sectionId);
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('getCommonLibraryItems', 'type', type);
                            localVarPath = "/library/sections/{sectionId}/common"
                                .replace("{".concat("sectionId", "}"), encodeURIComponent(String(sectionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            if (filter !== undefined) {
                                localVarQueryParameter['filter'] = filter;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will return a list of the latest library items filtered by the filter and type provided
         * @summary Get Latest Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} type item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLatestLibraryItems: function (sectionId, type, filter, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sectionId' is not null or undefined
                            (0, common_1.assertParamExists)('getLatestLibraryItems', 'sectionId', sectionId);
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('getLatestLibraryItems', 'type', type);
                            localVarPath = "/library/sections/{sectionId}/latest"
                                .replace("{".concat("sectionId", "}"), encodeURIComponent(String(sectionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            if (filter !== undefined) {
                                localVarQueryParameter['filter'] = filter;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * A library section (commonly referred to as just a library) is a collection of media.  Libraries are typed, and depending on their type provide either a flat or a hierarchical view of the media.  For example, a music library has an artist > albums > tracks structure, whereas a movie library is flat.  Libraries have features beyond just being a collection of media; for starters, they include information about supported types, filters and sorts.  This allows a client to provide a rich interface around the media (e.g. allow sorting movies by release year).
         * @summary Get All Libraries
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraries: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/library/sections";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Returns details for the library. This can be thought of as an interstitial endpoint because it contains information about the library, rather than content itself. These details are:  - A list of `Directory` objects: These used to be used by clients to build a menuing system. There are four flavors of directory found here:   - Primary: (e.g. all, On Deck) These are still used in some clients to provide \"shortcuts\" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.   - Secondary: These are marked with `secondary=\"1\"` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there\'s a completely obsolete entry marked `search=\"1\"` which used to be used to allow clients to build search dialogs on the fly. - A list of `Type` objects: These represent the types of things found in this library, and for each one, a list of `Filter` and `Sort` objects. These can be used to build rich controls around a grid of media to allow filtering and organizing. Note that these filters and sorts are optional, and without them, the client won\'t render any filtering controls. The `Type` object contains:   - `key`: This provides the root endpoint returning the actual media list for the type.   - `type`: This is the metadata type for the type (if a standard Plex type).   - `title`: The title for for the content of this type (e.g. \"Movies\"). - Each `Filter` object contains a description of the filter. Note that it is not an exhaustive list of the full media query language, but an inportant subset useful for top-level API.   - `filter`: This represents the filter name used for the filter, which can be used to construct complex media queries with.   - `filterType`: This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.   - `key`: This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a \"Genre\" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.   - `title`: The title for the filter. - Each `Sort` object contains a description of the sort field.   - `defaultDirection`: Can be either `asc` or `desc`, and specifies the default direction for the sort field (e.g. titles default to alphabetically ascending).   - `descKey` and `key`: Contains the parameters passed to the `sort=...` media query for each direction of the sort.   - `title`: The title of the field.
         * @summary Get Library Details
         * @param {any} sectionId the Id of the library to query
         * @param {any} [includeDetails] Whether or not to include details for a section (types, filters, and sorts).  Only exists for backwards compatibility, media providers other than the server libraries have it on always.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryDetails: function (sectionId, includeDetails, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sectionId' is not null or undefined
                            (0, common_1.assertParamExists)('getLibraryDetails', 'sectionId', sectionId);
                            localVarPath = "/library/sections/{sectionId}"
                                .replace("{".concat("sectionId", "}"), encodeURIComponent(String(sectionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (includeDetails !== undefined) {
                                localVarQueryParameter['includeDetails'] = includeDetails;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will return a list of library items filtered by the filter and type provided
         * @summary Get Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} [type] item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItems: function (sectionId, type, filter, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sectionId' is not null or undefined
                            (0, common_1.assertParamExists)('getLibraryItems', 'sectionId', sectionId);
                            localVarPath = "/library/sections/{sectionId}/all"
                                .replace("{".concat("sectionId", "}"), encodeURIComponent(String(sectionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            if (filter !== undefined) {
                                localVarQueryParameter['filter'] = filter;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will return the on deck content.
         * @summary Get On Deck
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOnDeck: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/library/onDeck";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint Refreshes the library.
         * @summary Refresh Library
         * @param {any} sectionId the Id of the library to refresh
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary: function (sectionId, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'sectionId' is not null or undefined
                            (0, common_1.assertParamExists)('refreshLibrary', 'sectionId', sectionId);
                            localVarPath = "/library/sections/{sectionId}/refresh"
                                .replace("{".concat("sectionId", "}"), encodeURIComponent(String(sectionId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.LibraryApiAxiosParamCreator = LibraryApiAxiosParamCreator;
/**
 * LibraryApi - functional programming interface
 * @export
 */
var LibraryApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.LibraryApiAxiosParamCreator)(configuration);
    return {
        /**
         * Represents a \"Common\" item. It contains only the common attributes of the items selected by the provided filter
         * @summary Get Common Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} type item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCommonLibraryItems: function (sectionId, type, filter, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCommonLibraryItems(sectionId, type, filter, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will return a list of the latest library items filtered by the filter and type provided
         * @summary Get Latest Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} type item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLatestLibraryItems: function (sectionId, type, filter, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLatestLibraryItems(sectionId, type, filter, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * A library section (commonly referred to as just a library) is a collection of media.  Libraries are typed, and depending on their type provide either a flat or a hierarchical view of the media.  For example, a music library has an artist > albums > tracks structure, whereas a movie library is flat.  Libraries have features beyond just being a collection of media; for starters, they include information about supported types, filters and sorts.  This allows a client to provide a rich interface around the media (e.g. allow sorting movies by release year).
         * @summary Get All Libraries
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraries: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLibraries(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Returns details for the library. This can be thought of as an interstitial endpoint because it contains information about the library, rather than content itself. These details are:  - A list of `Directory` objects: These used to be used by clients to build a menuing system. There are four flavors of directory found here:   - Primary: (e.g. all, On Deck) These are still used in some clients to provide \"shortcuts\" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.   - Secondary: These are marked with `secondary=\"1\"` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there\'s a completely obsolete entry marked `search=\"1\"` which used to be used to allow clients to build search dialogs on the fly. - A list of `Type` objects: These represent the types of things found in this library, and for each one, a list of `Filter` and `Sort` objects. These can be used to build rich controls around a grid of media to allow filtering and organizing. Note that these filters and sorts are optional, and without them, the client won\'t render any filtering controls. The `Type` object contains:   - `key`: This provides the root endpoint returning the actual media list for the type.   - `type`: This is the metadata type for the type (if a standard Plex type).   - `title`: The title for for the content of this type (e.g. \"Movies\"). - Each `Filter` object contains a description of the filter. Note that it is not an exhaustive list of the full media query language, but an inportant subset useful for top-level API.   - `filter`: This represents the filter name used for the filter, which can be used to construct complex media queries with.   - `filterType`: This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.   - `key`: This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a \"Genre\" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.   - `title`: The title for the filter. - Each `Sort` object contains a description of the sort field.   - `defaultDirection`: Can be either `asc` or `desc`, and specifies the default direction for the sort field (e.g. titles default to alphabetically ascending).   - `descKey` and `key`: Contains the parameters passed to the `sort=...` media query for each direction of the sort.   - `title`: The title of the field.
         * @summary Get Library Details
         * @param {any} sectionId the Id of the library to query
         * @param {any} [includeDetails] Whether or not to include details for a section (types, filters, and sorts).  Only exists for backwards compatibility, media providers other than the server libraries have it on always.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryDetails: function (sectionId, includeDetails, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLibraryDetails(sectionId, includeDetails, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will return a list of library items filtered by the filter and type provided
         * @summary Get Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} [type] item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItems: function (sectionId, type, filter, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLibraryItems(sectionId, type, filter, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will return the on deck content.
         * @summary Get On Deck
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOnDeck: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getOnDeck(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint Refreshes the library.
         * @summary Refresh Library
         * @param {any} sectionId the Id of the library to refresh
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary: function (sectionId, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.refreshLibrary(sectionId, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.LibraryApiFp = LibraryApiFp;
/**
 * LibraryApi - factory interface
 * @export
 */
var LibraryApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.LibraryApiFp)(configuration);
    return {
        /**
         * Represents a \"Common\" item. It contains only the common attributes of the items selected by the provided filter
         * @summary Get Common Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} type item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCommonLibraryItems: function (sectionId, type, filter, axiosOptions) {
            return localVarFp.getCommonLibraryItems(sectionId, type, filter, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will return a list of the latest library items filtered by the filter and type provided
         * @summary Get Latest Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} type item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLatestLibraryItems: function (sectionId, type, filter, axiosOptions) {
            return localVarFp.getLatestLibraryItems(sectionId, type, filter, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * A library section (commonly referred to as just a library) is a collection of media.  Libraries are typed, and depending on their type provide either a flat or a hierarchical view of the media.  For example, a music library has an artist > albums > tracks structure, whereas a movie library is flat.  Libraries have features beyond just being a collection of media; for starters, they include information about supported types, filters and sorts.  This allows a client to provide a rich interface around the media (e.g. allow sorting movies by release year).
         * @summary Get All Libraries
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraries: function (axiosOptions) {
            return localVarFp.getLibraries(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns details for the library. This can be thought of as an interstitial endpoint because it contains information about the library, rather than content itself. These details are:  - A list of `Directory` objects: These used to be used by clients to build a menuing system. There are four flavors of directory found here:   - Primary: (e.g. all, On Deck) These are still used in some clients to provide \"shortcuts\" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.   - Secondary: These are marked with `secondary=\"1\"` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there\'s a completely obsolete entry marked `search=\"1\"` which used to be used to allow clients to build search dialogs on the fly. - A list of `Type` objects: These represent the types of things found in this library, and for each one, a list of `Filter` and `Sort` objects. These can be used to build rich controls around a grid of media to allow filtering and organizing. Note that these filters and sorts are optional, and without them, the client won\'t render any filtering controls. The `Type` object contains:   - `key`: This provides the root endpoint returning the actual media list for the type.   - `type`: This is the metadata type for the type (if a standard Plex type).   - `title`: The title for for the content of this type (e.g. \"Movies\"). - Each `Filter` object contains a description of the filter. Note that it is not an exhaustive list of the full media query language, but an inportant subset useful for top-level API.   - `filter`: This represents the filter name used for the filter, which can be used to construct complex media queries with.   - `filterType`: This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.   - `key`: This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a \"Genre\" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.   - `title`: The title for the filter. - Each `Sort` object contains a description of the sort field.   - `defaultDirection`: Can be either `asc` or `desc`, and specifies the default direction for the sort field (e.g. titles default to alphabetically ascending).   - `descKey` and `key`: Contains the parameters passed to the `sort=...` media query for each direction of the sort.   - `title`: The title of the field.
         * @summary Get Library Details
         * @param {any} sectionId the Id of the library to query
         * @param {any} [includeDetails] Whether or not to include details for a section (types, filters, and sorts).  Only exists for backwards compatibility, media providers other than the server libraries have it on always.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryDetails: function (sectionId, includeDetails, axiosOptions) {
            return localVarFp.getLibraryDetails(sectionId, includeDetails, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will return a list of library items filtered by the filter and type provided
         * @summary Get Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} [type] item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItems: function (sectionId, type, filter, axiosOptions) {
            return localVarFp.getLibraryItems(sectionId, type, filter, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will return the on deck content.
         * @summary Get On Deck
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getOnDeck: function (axiosOptions) {
            return localVarFp.getOnDeck(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint Refreshes the library.
         * @summary Refresh Library
         * @param {any} sectionId the Id of the library to refresh
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary: function (sectionId, axiosOptions) {
            return localVarFp.refreshLibrary(sectionId, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.LibraryApiFactory = LibraryApiFactory;
/**
 * LibraryApi - object-oriented interface
 * @export
 * @class LibraryApi
 * @extends {BaseAPI}
 */
var LibraryApi = /** @class */ (function (_super) {
    __extends(LibraryApi, _super);
    function LibraryApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Represents a \"Common\" item. It contains only the common attributes of the items selected by the provided filter
     * @summary Get Common Library Items
     * @param {LibraryApiGetCommonLibraryItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    LibraryApi.prototype.getCommonLibraryItems = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LibraryApiFp)(this.configuration).getCommonLibraryItems(requestParameters.sectionId, requestParameters.type, requestParameters.filter, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will return a list of the latest library items filtered by the filter and type provided
     * @summary Get Latest Library Items
     * @param {LibraryApiGetLatestLibraryItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    LibraryApi.prototype.getLatestLibraryItems = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LibraryApiFp)(this.configuration).getLatestLibraryItems(requestParameters.sectionId, requestParameters.type, requestParameters.filter, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * A library section (commonly referred to as just a library) is a collection of media.  Libraries are typed, and depending on their type provide either a flat or a hierarchical view of the media.  For example, a music library has an artist > albums > tracks structure, whereas a movie library is flat.  Libraries have features beyond just being a collection of media; for starters, they include information about supported types, filters and sorts.  This allows a client to provide a rich interface around the media (e.g. allow sorting movies by release year).
     * @summary Get All Libraries
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    LibraryApi.prototype.getLibraries = function (axiosOptions) {
        var _this = this;
        return (0, exports.LibraryApiFp)(this.configuration).getLibraries(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Returns details for the library. This can be thought of as an interstitial endpoint because it contains information about the library, rather than content itself. These details are:  - A list of `Directory` objects: These used to be used by clients to build a menuing system. There are four flavors of directory found here:   - Primary: (e.g. all, On Deck) These are still used in some clients to provide \"shortcuts\" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.   - Secondary: These are marked with `secondary=\"1\"` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there\'s a completely obsolete entry marked `search=\"1\"` which used to be used to allow clients to build search dialogs on the fly. - A list of `Type` objects: These represent the types of things found in this library, and for each one, a list of `Filter` and `Sort` objects. These can be used to build rich controls around a grid of media to allow filtering and organizing. Note that these filters and sorts are optional, and without them, the client won\'t render any filtering controls. The `Type` object contains:   - `key`: This provides the root endpoint returning the actual media list for the type.   - `type`: This is the metadata type for the type (if a standard Plex type).   - `title`: The title for for the content of this type (e.g. \"Movies\"). - Each `Filter` object contains a description of the filter. Note that it is not an exhaustive list of the full media query language, but an inportant subset useful for top-level API.   - `filter`: This represents the filter name used for the filter, which can be used to construct complex media queries with.   - `filterType`: This is either `string`, `integer`, or `boolean`, and describes the type of values used for the filter.   - `key`: This provides the endpoint where the possible range of values for the filter can be retrieved (e.g. for a \"Genre\" filter, it returns a list of all the genres in the library). This will include a `type` argument that matches the metadata type of the Type element.   - `title`: The title for the filter. - Each `Sort` object contains a description of the sort field.   - `defaultDirection`: Can be either `asc` or `desc`, and specifies the default direction for the sort field (e.g. titles default to alphabetically ascending).   - `descKey` and `key`: Contains the parameters passed to the `sort=...` media query for each direction of the sort.   - `title`: The title of the field.
     * @summary Get Library Details
     * @param {LibraryApiGetLibraryDetailsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    LibraryApi.prototype.getLibraryDetails = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LibraryApiFp)(this.configuration).getLibraryDetails(requestParameters.sectionId, requestParameters.includeDetails, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will return a list of library items filtered by the filter and type provided
     * @summary Get Library Items
     * @param {LibraryApiGetLibraryItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    LibraryApi.prototype.getLibraryItems = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LibraryApiFp)(this.configuration).getLibraryItems(requestParameters.sectionId, requestParameters.type, requestParameters.filter, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will return the on deck content.
     * @summary Get On Deck
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    LibraryApi.prototype.getOnDeck = function (axiosOptions) {
        var _this = this;
        return (0, exports.LibraryApiFp)(this.configuration).getOnDeck(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint Refreshes the library.
     * @summary Refresh Library
     * @param {LibraryApiRefreshLibraryRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    LibraryApi.prototype.refreshLibrary = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LibraryApiFp)(this.configuration).refreshLibrary(requestParameters.sectionId, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return LibraryApi;
}(base_1.BaseAPI));
exports.LibraryApi = LibraryApi;
/**
 * LogApi - axios parameter creator
 * @export
 */
var LogApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time.
         * @summary Enabling Papertrail
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enablePaperTrail: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/log/networked";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log.
         * @summary Logging a single line message.
         * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose
         * @param {any} message The text of the message to write to the log.
         * @param {any} source a string indicating the source of the message.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logLine: function (level, message, source, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'level' is not null or undefined
                            (0, common_1.assertParamExists)('logLine', 'level', level);
                            // verify required parameter 'message' is not null or undefined
                            (0, common_1.assertParamExists)('logLine', 'message', message);
                            // verify required parameter 'source' is not null or undefined
                            (0, common_1.assertParamExists)('logLine', 'source', source);
                            localVarPath = "/log";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (level !== undefined) {
                                localVarQueryParameter['level'] = level;
                            }
                            if (message !== undefined) {
                                localVarQueryParameter['message'] = message;
                            }
                            if (source !== undefined) {
                                localVarQueryParameter['source'] = source;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above.
         * @summary Logging a multi-line message
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logMultiLine: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/log";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.LogApiAxiosParamCreator = LogApiAxiosParamCreator;
/**
 * LogApi - functional programming interface
 * @export
 */
var LogApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.LogApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time.
         * @summary Enabling Papertrail
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enablePaperTrail: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.enablePaperTrail(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log.
         * @summary Logging a single line message.
         * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose
         * @param {any} message The text of the message to write to the log.
         * @param {any} source a string indicating the source of the message.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logLine: function (level, message, source, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.logLine(level, message, source, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above.
         * @summary Logging a multi-line message
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logMultiLine: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.logMultiLine(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.LogApiFp = LogApiFp;
/**
 * LogApi - factory interface
 * @export
 */
var LogApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.LogApiFp)(configuration);
    return {
        /**
         * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time.
         * @summary Enabling Papertrail
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enablePaperTrail: function (axiosOptions) {
            return localVarFp.enablePaperTrail(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log.
         * @summary Logging a single line message.
         * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose
         * @param {any} message The text of the message to write to the log.
         * @param {any} source a string indicating the source of the message.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logLine: function (level, message, source, axiosOptions) {
            return localVarFp.logLine(level, message, source, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above.
         * @summary Logging a multi-line message
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logMultiLine: function (axiosOptions) {
            return localVarFp.logMultiLine(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.LogApiFactory = LogApiFactory;
/**
 * LogApi - object-oriented interface
 * @export
 * @class LogApi
 * @extends {BaseAPI}
 */
var LogApi = /** @class */ (function (_super) {
    __extends(LogApi, _super);
    function LogApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time.
     * @summary Enabling Papertrail
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    LogApi.prototype.enablePaperTrail = function (axiosOptions) {
        var _this = this;
        return (0, exports.LogApiFp)(this.configuration).enablePaperTrail(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log.
     * @summary Logging a single line message.
     * @param {LogApiLogLineRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    LogApi.prototype.logLine = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.LogApiFp)(this.configuration).logLine(requestParameters.level, requestParameters.message, requestParameters.source, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above.
     * @summary Logging a multi-line message
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    LogApi.prototype.logMultiLine = function (axiosOptions) {
        var _this = this;
        return (0, exports.LogApiFp)(this.configuration).logMultiLine(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return LogApi;
}(base_1.BaseAPI));
exports.LogApi = LogApi;
/**
 * PlaylistsApi - axios parameter creator
 * @export
 */
var PlaylistsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Adds a generator to a playlist, same parameters as the POST above. With a dumb playlist, this adds the specified items to the playlist.  With a smart playlist, passing a new `uri` parameter replaces the rules for the playlist. Returns the playlist.
         * @summary Adding to a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {any} uri the content URI for the playlist
         * @param {any} playQueueID the play queue to add to a playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addPlaylistContents: function (playlistID, uri, playQueueID, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'playlistID' is not null or undefined
                            (0, common_1.assertParamExists)('addPlaylistContents', 'playlistID', playlistID);
                            // verify required parameter 'uri' is not null or undefined
                            (0, common_1.assertParamExists)('addPlaylistContents', 'uri', uri);
                            // verify required parameter 'playQueueID' is not null or undefined
                            (0, common_1.assertParamExists)('addPlaylistContents', 'playQueueID', playQueueID);
                            localVarPath = "/playlists/{playlistID}/items"
                                .replace("{".concat("playlistID", "}"), encodeURIComponent(String(playlistID)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (uri !== undefined) {
                                localVarQueryParameter['uri'] = uri;
                            }
                            if (playQueueID !== undefined) {
                                localVarQueryParameter['playQueueID'] = playQueueID;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Clears a playlist, only works with dumb playlists. Returns the playlist.
         * @summary Delete Playlist Contents
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        clearPlaylistContents: function (playlistID, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'playlistID' is not null or undefined
                            (0, common_1.assertParamExists)('clearPlaylistContents', 'playlistID', playlistID);
                            localVarPath = "/playlists/{playlistID}/items"
                                .replace("{".concat("playlistID", "}"), encodeURIComponent(String(playlistID)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Create a new playlist. By default the playlist is blank. To create a playlist along with a first item, pass: - `uri` - The content URI for what we\'re playing (e.g. `library://...`). - `playQueueID` - To create a playlist from an existing play queue.
         * @summary Create a Playlist
         * @param {any} title name of the playlist
         * @param {any} type type of playlist to create
         * @param {any} smart whether the playlist is smart or not
         * @param {any} [uri] the content URI for the playlist
         * @param {any} [playQueueID] the play queue to copy to a playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist: function (title, type, smart, uri, playQueueID, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'title' is not null or undefined
                            (0, common_1.assertParamExists)('createPlaylist', 'title', title);
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('createPlaylist', 'type', type);
                            // verify required parameter 'smart' is not null or undefined
                            (0, common_1.assertParamExists)('createPlaylist', 'smart', smart);
                            localVarPath = "/playlists";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (title !== undefined) {
                                localVarQueryParameter['title'] = title;
                            }
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            if (smart !== undefined) {
                                localVarQueryParameter['smart'] = smart;
                            }
                            if (uri !== undefined) {
                                localVarQueryParameter['uri'] = uri;
                            }
                            if (playQueueID !== undefined) {
                                localVarQueryParameter['playQueueID'] = playQueueID;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint will delete a playlist
         * @summary Deletes a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist: function (playlistID, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'playlistID' is not null or undefined
                            (0, common_1.assertParamExists)('deletePlaylist', 'playlistID', playlistID);
                            localVarPath = "/playlists/{playlistID}"
                                .replace("{".concat("playlistID", "}"), encodeURIComponent(String(playlistID)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Gets detailed metadata for a playlist. A playlist for many purposes (rating, editing metadata, tagging), can be treated like a regular metadata item: Smart playlist details contain the `content` attribute. This is the content URI for the generator. This can then be parsed by a client to provide smart playlist editing.
         * @summary Retrieve Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist: function (playlistID, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'playlistID' is not null or undefined
                            (0, common_1.assertParamExists)('getPlaylist', 'playlistID', playlistID);
                            localVarPath = "/playlists/{playlistID}"
                                .replace("{".concat("playlistID", "}"), encodeURIComponent(String(playlistID)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Gets the contents of a playlist. Should be paged by clients via standard mechanisms.  By default leaves are returned (e.g. episodes, movies). In order to return other types you can use the `type` parameter.  For example, you could use this to display a list of recently added albums vis a smart playlist.  Note that for dumb playlists, items have a `playlistItemID` attribute which is used for deleting or moving items.
         * @summary Retrieve Playlist Contents
         * @param {any} playlistID the ID of the playlist
         * @param {any} type the metadata type of the item to return
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistContents: function (playlistID, type, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'playlistID' is not null or undefined
                            (0, common_1.assertParamExists)('getPlaylistContents', 'playlistID', playlistID);
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('getPlaylistContents', 'type', type);
                            localVarPath = "/playlists/{playlistID}/items"
                                .replace("{".concat("playlistID", "}"), encodeURIComponent(String(playlistID)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         *
         * @summary Get All Playlists
         * @param {any} [playlistType] limit to a type of playlist.
         * @param {any} [smart] type of playlists to return (default is all).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylists: function (playlistType, smart, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/playlists/all";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (playlistType !== undefined) {
                                localVarQueryParameter['playlistType'] = playlistType;
                            }
                            if (smart !== undefined) {
                                localVarQueryParameter['smart'] = smart;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * From PMS version 1.9.1 clients can also edit playlist metadata using this endpoint as they would via `PUT /library/metadata/{playlistID}`
         * @summary Update a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylist: function (playlistID, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'playlistID' is not null or undefined
                            (0, common_1.assertParamExists)('updatePlaylist', 'playlistID', playlistID);
                            localVarPath = "/playlists/{playlistID}"
                                .replace("{".concat("playlistID", "}"), encodeURIComponent(String(playlistID)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Imports m3u playlists by passing a path on the server to scan for m3u-formatted playlist files, or a path to a single playlist file.
         * @summary Upload Playlist
         * @param {any} path absolute path to a directory on the server where m3u files are stored, or the absolute path to a playlist file on the server.  If the &#x60;path&#x60; argument is a directory, that path will be scanned for playlist files to be processed.  Each file in that directory creates a separate playlist, with a name based on the filename of the file that created it.  The GUID of each playlist is based on the filename.  If the &#x60;path&#x60; argument is a file, that file will be used to create a new playlist, with the name based on the filename of the file that created it.  The GUID of each playlist is based on the filename.
         * @param {any} force force overwriting of duplicate playlists. By default, a playlist file uploaded with the same path will overwrite the existing playlist.  The &#x60;force&#x60; argument is used to disable overwriting. If the &#x60;force&#x60; argument is set to 0, a new playlist will be created suffixed with the date and time that the duplicate was uploaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        uploadPlaylist: function (path, force, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'path' is not null or undefined
                            (0, common_1.assertParamExists)('uploadPlaylist', 'path', path);
                            // verify required parameter 'force' is not null or undefined
                            (0, common_1.assertParamExists)('uploadPlaylist', 'force', force);
                            localVarPath = "/playlists/upload";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (path !== undefined) {
                                localVarQueryParameter['path'] = path;
                            }
                            if (force !== undefined) {
                                localVarQueryParameter['force'] = force;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.PlaylistsApiAxiosParamCreator = PlaylistsApiAxiosParamCreator;
/**
 * PlaylistsApi - functional programming interface
 * @export
 */
var PlaylistsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.PlaylistsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Adds a generator to a playlist, same parameters as the POST above. With a dumb playlist, this adds the specified items to the playlist.  With a smart playlist, passing a new `uri` parameter replaces the rules for the playlist. Returns the playlist.
         * @summary Adding to a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {any} uri the content URI for the playlist
         * @param {any} playQueueID the play queue to add to a playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addPlaylistContents: function (playlistID, uri, playQueueID, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.addPlaylistContents(playlistID, uri, playQueueID, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Clears a playlist, only works with dumb playlists. Returns the playlist.
         * @summary Delete Playlist Contents
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        clearPlaylistContents: function (playlistID, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.clearPlaylistContents(playlistID, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Create a new playlist. By default the playlist is blank. To create a playlist along with a first item, pass: - `uri` - The content URI for what we\'re playing (e.g. `library://...`). - `playQueueID` - To create a playlist from an existing play queue.
         * @summary Create a Playlist
         * @param {any} title name of the playlist
         * @param {any} type type of playlist to create
         * @param {any} smart whether the playlist is smart or not
         * @param {any} [uri] the content URI for the playlist
         * @param {any} [playQueueID] the play queue to copy to a playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist: function (title, type, smart, uri, playQueueID, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createPlaylist(title, type, smart, uri, playQueueID, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint will delete a playlist
         * @summary Deletes a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist: function (playlistID, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deletePlaylist(playlistID, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Gets detailed metadata for a playlist. A playlist for many purposes (rating, editing metadata, tagging), can be treated like a regular metadata item: Smart playlist details contain the `content` attribute. This is the content URI for the generator. This can then be parsed by a client to provide smart playlist editing.
         * @summary Retrieve Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist: function (playlistID, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPlaylist(playlistID, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Gets the contents of a playlist. Should be paged by clients via standard mechanisms.  By default leaves are returned (e.g. episodes, movies). In order to return other types you can use the `type` parameter.  For example, you could use this to display a list of recently added albums vis a smart playlist.  Note that for dumb playlists, items have a `playlistItemID` attribute which is used for deleting or moving items.
         * @summary Retrieve Playlist Contents
         * @param {any} playlistID the ID of the playlist
         * @param {any} type the metadata type of the item to return
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistContents: function (playlistID, type, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPlaylistContents(playlistID, type, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         *
         * @summary Get All Playlists
         * @param {any} [playlistType] limit to a type of playlist.
         * @param {any} [smart] type of playlists to return (default is all).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylists: function (playlistType, smart, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPlaylists(playlistType, smart, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * From PMS version 1.9.1 clients can also edit playlist metadata using this endpoint as they would via `PUT /library/metadata/{playlistID}`
         * @summary Update a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylist: function (playlistID, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updatePlaylist(playlistID, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Imports m3u playlists by passing a path on the server to scan for m3u-formatted playlist files, or a path to a single playlist file.
         * @summary Upload Playlist
         * @param {any} path absolute path to a directory on the server where m3u files are stored, or the absolute path to a playlist file on the server.  If the &#x60;path&#x60; argument is a directory, that path will be scanned for playlist files to be processed.  Each file in that directory creates a separate playlist, with a name based on the filename of the file that created it.  The GUID of each playlist is based on the filename.  If the &#x60;path&#x60; argument is a file, that file will be used to create a new playlist, with the name based on the filename of the file that created it.  The GUID of each playlist is based on the filename.
         * @param {any} force force overwriting of duplicate playlists. By default, a playlist file uploaded with the same path will overwrite the existing playlist.  The &#x60;force&#x60; argument is used to disable overwriting. If the &#x60;force&#x60; argument is set to 0, a new playlist will be created suffixed with the date and time that the duplicate was uploaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        uploadPlaylist: function (path, force, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.uploadPlaylist(path, force, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.PlaylistsApiFp = PlaylistsApiFp;
/**
 * PlaylistsApi - factory interface
 * @export
 */
var PlaylistsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.PlaylistsApiFp)(configuration);
    return {
        /**
         * Adds a generator to a playlist, same parameters as the POST above. With a dumb playlist, this adds the specified items to the playlist.  With a smart playlist, passing a new `uri` parameter replaces the rules for the playlist. Returns the playlist.
         * @summary Adding to a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {any} uri the content URI for the playlist
         * @param {any} playQueueID the play queue to add to a playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        addPlaylistContents: function (playlistID, uri, playQueueID, axiosOptions) {
            return localVarFp.addPlaylistContents(playlistID, uri, playQueueID, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Clears a playlist, only works with dumb playlists. Returns the playlist.
         * @summary Delete Playlist Contents
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        clearPlaylistContents: function (playlistID, axiosOptions) {
            return localVarFp.clearPlaylistContents(playlistID, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Create a new playlist. By default the playlist is blank. To create a playlist along with a first item, pass: - `uri` - The content URI for what we\'re playing (e.g. `library://...`). - `playQueueID` - To create a playlist from an existing play queue.
         * @summary Create a Playlist
         * @param {any} title name of the playlist
         * @param {any} type type of playlist to create
         * @param {any} smart whether the playlist is smart or not
         * @param {any} [uri] the content URI for the playlist
         * @param {any} [playQueueID] the play queue to copy to a playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist: function (title, type, smart, uri, playQueueID, axiosOptions) {
            return localVarFp.createPlaylist(title, type, smart, uri, playQueueID, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint will delete a playlist
         * @summary Deletes a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist: function (playlistID, axiosOptions) {
            return localVarFp.deletePlaylist(playlistID, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets detailed metadata for a playlist. A playlist for many purposes (rating, editing metadata, tagging), can be treated like a regular metadata item: Smart playlist details contain the `content` attribute. This is the content URI for the generator. This can then be parsed by a client to provide smart playlist editing.
         * @summary Retrieve Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist: function (playlistID, axiosOptions) {
            return localVarFp.getPlaylist(playlistID, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets the contents of a playlist. Should be paged by clients via standard mechanisms.  By default leaves are returned (e.g. episodes, movies). In order to return other types you can use the `type` parameter.  For example, you could use this to display a list of recently added albums vis a smart playlist.  Note that for dumb playlists, items have a `playlistItemID` attribute which is used for deleting or moving items.
         * @summary Retrieve Playlist Contents
         * @param {any} playlistID the ID of the playlist
         * @param {any} type the metadata type of the item to return
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistContents: function (playlistID, type, axiosOptions) {
            return localVarFp.getPlaylistContents(playlistID, type, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         *
         * @summary Get All Playlists
         * @param {any} [playlistType] limit to a type of playlist.
         * @param {any} [smart] type of playlists to return (default is all).
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylists: function (playlistType, smart, axiosOptions) {
            return localVarFp.getPlaylists(playlistType, smart, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * From PMS version 1.9.1 clients can also edit playlist metadata using this endpoint as they would via `PUT /library/metadata/{playlistID}`
         * @summary Update a Playlist
         * @param {any} playlistID the ID of the playlist
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylist: function (playlistID, axiosOptions) {
            return localVarFp.updatePlaylist(playlistID, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Imports m3u playlists by passing a path on the server to scan for m3u-formatted playlist files, or a path to a single playlist file.
         * @summary Upload Playlist
         * @param {any} path absolute path to a directory on the server where m3u files are stored, or the absolute path to a playlist file on the server.  If the &#x60;path&#x60; argument is a directory, that path will be scanned for playlist files to be processed.  Each file in that directory creates a separate playlist, with a name based on the filename of the file that created it.  The GUID of each playlist is based on the filename.  If the &#x60;path&#x60; argument is a file, that file will be used to create a new playlist, with the name based on the filename of the file that created it.  The GUID of each playlist is based on the filename.
         * @param {any} force force overwriting of duplicate playlists. By default, a playlist file uploaded with the same path will overwrite the existing playlist.  The &#x60;force&#x60; argument is used to disable overwriting. If the &#x60;force&#x60; argument is set to 0, a new playlist will be created suffixed with the date and time that the duplicate was uploaded.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        uploadPlaylist: function (path, force, axiosOptions) {
            return localVarFp.uploadPlaylist(path, force, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.PlaylistsApiFactory = PlaylistsApiFactory;
/**
 * PlaylistsApi - object-oriented interface
 * @export
 * @class PlaylistsApi
 * @extends {BaseAPI}
 */
var PlaylistsApi = /** @class */ (function (_super) {
    __extends(PlaylistsApi, _super);
    function PlaylistsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Adds a generator to a playlist, same parameters as the POST above. With a dumb playlist, this adds the specified items to the playlist.  With a smart playlist, passing a new `uri` parameter replaces the rules for the playlist. Returns the playlist.
     * @summary Adding to a Playlist
     * @param {PlaylistsApiAddPlaylistContentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    PlaylistsApi.prototype.addPlaylistContents = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PlaylistsApiFp)(this.configuration).addPlaylistContents(requestParameters.playlistID, requestParameters.uri, requestParameters.playQueueID, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Clears a playlist, only works with dumb playlists. Returns the playlist.
     * @summary Delete Playlist Contents
     * @param {PlaylistsApiClearPlaylistContentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    PlaylistsApi.prototype.clearPlaylistContents = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PlaylistsApiFp)(this.configuration).clearPlaylistContents(requestParameters.playlistID, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Create a new playlist. By default the playlist is blank. To create a playlist along with a first item, pass: - `uri` - The content URI for what we\'re playing (e.g. `library://...`). - `playQueueID` - To create a playlist from an existing play queue.
     * @summary Create a Playlist
     * @param {PlaylistsApiCreatePlaylistRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    PlaylistsApi.prototype.createPlaylist = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PlaylistsApiFp)(this.configuration).createPlaylist(requestParameters.title, requestParameters.type, requestParameters.smart, requestParameters.uri, requestParameters.playQueueID, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint will delete a playlist
     * @summary Deletes a Playlist
     * @param {PlaylistsApiDeletePlaylistRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    PlaylistsApi.prototype.deletePlaylist = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PlaylistsApiFp)(this.configuration).deletePlaylist(requestParameters.playlistID, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Gets detailed metadata for a playlist. A playlist for many purposes (rating, editing metadata, tagging), can be treated like a regular metadata item: Smart playlist details contain the `content` attribute. This is the content URI for the generator. This can then be parsed by a client to provide smart playlist editing.
     * @summary Retrieve Playlist
     * @param {PlaylistsApiGetPlaylistRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    PlaylistsApi.prototype.getPlaylist = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PlaylistsApiFp)(this.configuration).getPlaylist(requestParameters.playlistID, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Gets the contents of a playlist. Should be paged by clients via standard mechanisms.  By default leaves are returned (e.g. episodes, movies). In order to return other types you can use the `type` parameter.  For example, you could use this to display a list of recently added albums vis a smart playlist.  Note that for dumb playlists, items have a `playlistItemID` attribute which is used for deleting or moving items.
     * @summary Retrieve Playlist Contents
     * @param {PlaylistsApiGetPlaylistContentsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    PlaylistsApi.prototype.getPlaylistContents = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PlaylistsApiFp)(this.configuration).getPlaylistContents(requestParameters.playlistID, requestParameters.type, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     *
     * @summary Get All Playlists
     * @param {PlaylistsApiGetPlaylistsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    PlaylistsApi.prototype.getPlaylists = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.PlaylistsApiFp)(this.configuration).getPlaylists(requestParameters.playlistType, requestParameters.smart, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * From PMS version 1.9.1 clients can also edit playlist metadata using this endpoint as they would via `PUT /library/metadata/{playlistID}`
     * @summary Update a Playlist
     * @param {PlaylistsApiUpdatePlaylistRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    PlaylistsApi.prototype.updatePlaylist = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PlaylistsApiFp)(this.configuration).updatePlaylist(requestParameters.playlistID, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Imports m3u playlists by passing a path on the server to scan for m3u-formatted playlist files, or a path to a single playlist file.
     * @summary Upload Playlist
     * @param {PlaylistsApiUploadPlaylistRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    PlaylistsApi.prototype.uploadPlaylist = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.PlaylistsApiFp)(this.configuration).uploadPlaylist(requestParameters.path, requestParameters.force, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return PlaylistsApi;
}(base_1.BaseAPI));
exports.PlaylistsApi = PlaylistsApi;
/**
 * SearchApi - axios parameter creator
 * @export
 */
var SearchApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This endpoint performs a search across all library sections, or a single section, and returns matches as hubs, split up by type. It performs spell checking, looks for partial matches, and orders the hubs based on quality of results. In addition, based on matches, it will return other related matches (e.g. for a genre match, it may return movies in that genre, or for an actor match, movies with that actor).  In the response\'s items, the following extra attributes are returned to further describe or disambiguate the result:  - `reason`: The reason for the result, if not because of a direct search term match; can be either:   - `section`: There are multiple identical results from different sections.   - `originalTitle`: There was a search term match from the original title field (sometimes those can be very different or in a foreign language).   - `<hub identifier>`: If the reason for the result is due to a result in another hub, the source hub identifier is returned. For example, if the search is for \"dylan\" then Bob Dylan may be returned as an artist result, an a few of his albums returned as album results with a reason code of `artist` (the identifier of that particular hub). Or if the search is for \"arnold\", there might be movie results returned with a reason of `actor` - `reasonTitle`: The string associated with the reason code. For a section reason, it\'ll be the section name; For a hub identifier, it\'ll be a string associated with the match (e.g. `Arnold Schwarzenegger` for movies which were returned because the search was for \"arnold\"). - `reasonID`: The ID of the item associated with the reason for the result. This might be a section ID, a tag ID, an artist ID, or a show ID.  This request is intended to be very fast, and called as the user types.
         * @summary Perform a search
         * @param {any} query The query term
         * @param {any} [sectionId] This gives context to the search, and can result in re-ordering of search result hubs
         * @param {any} [limit] The number of items to return per hub
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        performSearch: function (query, sectionId, limit, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'query' is not null or undefined
                            (0, common_1.assertParamExists)('performSearch', 'query', query);
                            localVarPath = "/hubs/search";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (query !== undefined) {
                                localVarQueryParameter['query'] = query;
                            }
                            if (sectionId !== undefined) {
                                localVarQueryParameter['sectionId'] = sectionId;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint performs a search specifically tailored towards voice or other imprecise input which may work badly with the substring and spell-checking heuristics used by the `/hubs/search` endpoint.  It uses a [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) heuristic to search titles, and as such is much slower than the other search endpoint.  Whenever possible, clients should limit the search to the appropriate type.  Results, as well as their containing per-type hubs, contain a `distance` attribute which can be used to judge result quality.
         * @summary Perform a voice search
         * @param {any} query The query term
         * @param {any} [sectionId] This gives context to the search, and can result in re-ordering of search result hubs
         * @param {any} [limit] The number of items to return per hub
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        performVoiceSearch: function (query, sectionId, limit, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'query' is not null or undefined
                            (0, common_1.assertParamExists)('performVoiceSearch', 'query', query);
                            localVarPath = "/hubs/search/voice";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (query !== undefined) {
                                localVarQueryParameter['query'] = query;
                            }
                            if (sectionId !== undefined) {
                                localVarQueryParameter['sectionId'] = sectionId;
                            }
                            if (limit !== undefined) {
                                localVarQueryParameter['limit'] = limit;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SearchApiAxiosParamCreator = SearchApiAxiosParamCreator;
/**
 * SearchApi - functional programming interface
 * @export
 */
var SearchApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SearchApiAxiosParamCreator)(configuration);
    return {
        /**
         * This endpoint performs a search across all library sections, or a single section, and returns matches as hubs, split up by type. It performs spell checking, looks for partial matches, and orders the hubs based on quality of results. In addition, based on matches, it will return other related matches (e.g. for a genre match, it may return movies in that genre, or for an actor match, movies with that actor).  In the response\'s items, the following extra attributes are returned to further describe or disambiguate the result:  - `reason`: The reason for the result, if not because of a direct search term match; can be either:   - `section`: There are multiple identical results from different sections.   - `originalTitle`: There was a search term match from the original title field (sometimes those can be very different or in a foreign language).   - `<hub identifier>`: If the reason for the result is due to a result in another hub, the source hub identifier is returned. For example, if the search is for \"dylan\" then Bob Dylan may be returned as an artist result, an a few of his albums returned as album results with a reason code of `artist` (the identifier of that particular hub). Or if the search is for \"arnold\", there might be movie results returned with a reason of `actor` - `reasonTitle`: The string associated with the reason code. For a section reason, it\'ll be the section name; For a hub identifier, it\'ll be a string associated with the match (e.g. `Arnold Schwarzenegger` for movies which were returned because the search was for \"arnold\"). - `reasonID`: The ID of the item associated with the reason for the result. This might be a section ID, a tag ID, an artist ID, or a show ID.  This request is intended to be very fast, and called as the user types.
         * @summary Perform a search
         * @param {any} query The query term
         * @param {any} [sectionId] This gives context to the search, and can result in re-ordering of search result hubs
         * @param {any} [limit] The number of items to return per hub
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        performSearch: function (query, sectionId, limit, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.performSearch(query, sectionId, limit, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint performs a search specifically tailored towards voice or other imprecise input which may work badly with the substring and spell-checking heuristics used by the `/hubs/search` endpoint.  It uses a [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) heuristic to search titles, and as such is much slower than the other search endpoint.  Whenever possible, clients should limit the search to the appropriate type.  Results, as well as their containing per-type hubs, contain a `distance` attribute which can be used to judge result quality.
         * @summary Perform a voice search
         * @param {any} query The query term
         * @param {any} [sectionId] This gives context to the search, and can result in re-ordering of search result hubs
         * @param {any} [limit] The number of items to return per hub
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        performVoiceSearch: function (query, sectionId, limit, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.performVoiceSearch(query, sectionId, limit, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SearchApiFp = SearchApiFp;
/**
 * SearchApi - factory interface
 * @export
 */
var SearchApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SearchApiFp)(configuration);
    return {
        /**
         * This endpoint performs a search across all library sections, or a single section, and returns matches as hubs, split up by type. It performs spell checking, looks for partial matches, and orders the hubs based on quality of results. In addition, based on matches, it will return other related matches (e.g. for a genre match, it may return movies in that genre, or for an actor match, movies with that actor).  In the response\'s items, the following extra attributes are returned to further describe or disambiguate the result:  - `reason`: The reason for the result, if not because of a direct search term match; can be either:   - `section`: There are multiple identical results from different sections.   - `originalTitle`: There was a search term match from the original title field (sometimes those can be very different or in a foreign language).   - `<hub identifier>`: If the reason for the result is due to a result in another hub, the source hub identifier is returned. For example, if the search is for \"dylan\" then Bob Dylan may be returned as an artist result, an a few of his albums returned as album results with a reason code of `artist` (the identifier of that particular hub). Or if the search is for \"arnold\", there might be movie results returned with a reason of `actor` - `reasonTitle`: The string associated with the reason code. For a section reason, it\'ll be the section name; For a hub identifier, it\'ll be a string associated with the match (e.g. `Arnold Schwarzenegger` for movies which were returned because the search was for \"arnold\"). - `reasonID`: The ID of the item associated with the reason for the result. This might be a section ID, a tag ID, an artist ID, or a show ID.  This request is intended to be very fast, and called as the user types.
         * @summary Perform a search
         * @param {any} query The query term
         * @param {any} [sectionId] This gives context to the search, and can result in re-ordering of search result hubs
         * @param {any} [limit] The number of items to return per hub
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        performSearch: function (query, sectionId, limit, axiosOptions) {
            return localVarFp.performSearch(query, sectionId, limit, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint performs a search specifically tailored towards voice or other imprecise input which may work badly with the substring and spell-checking heuristics used by the `/hubs/search` endpoint.  It uses a [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) heuristic to search titles, and as such is much slower than the other search endpoint.  Whenever possible, clients should limit the search to the appropriate type.  Results, as well as their containing per-type hubs, contain a `distance` attribute which can be used to judge result quality.
         * @summary Perform a voice search
         * @param {any} query The query term
         * @param {any} [sectionId] This gives context to the search, and can result in re-ordering of search result hubs
         * @param {any} [limit] The number of items to return per hub
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        performVoiceSearch: function (query, sectionId, limit, axiosOptions) {
            return localVarFp.performVoiceSearch(query, sectionId, limit, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SearchApiFactory = SearchApiFactory;
/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
var SearchApi = /** @class */ (function (_super) {
    __extends(SearchApi, _super);
    function SearchApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This endpoint performs a search across all library sections, or a single section, and returns matches as hubs, split up by type. It performs spell checking, looks for partial matches, and orders the hubs based on quality of results. In addition, based on matches, it will return other related matches (e.g. for a genre match, it may return movies in that genre, or for an actor match, movies with that actor).  In the response\'s items, the following extra attributes are returned to further describe or disambiguate the result:  - `reason`: The reason for the result, if not because of a direct search term match; can be either:   - `section`: There are multiple identical results from different sections.   - `originalTitle`: There was a search term match from the original title field (sometimes those can be very different or in a foreign language).   - `<hub identifier>`: If the reason for the result is due to a result in another hub, the source hub identifier is returned. For example, if the search is for \"dylan\" then Bob Dylan may be returned as an artist result, an a few of his albums returned as album results with a reason code of `artist` (the identifier of that particular hub). Or if the search is for \"arnold\", there might be movie results returned with a reason of `actor` - `reasonTitle`: The string associated with the reason code. For a section reason, it\'ll be the section name; For a hub identifier, it\'ll be a string associated with the match (e.g. `Arnold Schwarzenegger` for movies which were returned because the search was for \"arnold\"). - `reasonID`: The ID of the item associated with the reason for the result. This might be a section ID, a tag ID, an artist ID, or a show ID.  This request is intended to be very fast, and called as the user types.
     * @summary Perform a search
     * @param {SearchApiPerformSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    SearchApi.prototype.performSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SearchApiFp)(this.configuration).performSearch(requestParameters.query, requestParameters.sectionId, requestParameters.limit, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint performs a search specifically tailored towards voice or other imprecise input which may work badly with the substring and spell-checking heuristics used by the `/hubs/search` endpoint.  It uses a [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) heuristic to search titles, and as such is much slower than the other search endpoint.  Whenever possible, clients should limit the search to the appropriate type.  Results, as well as their containing per-type hubs, contain a `distance` attribute which can be used to judge result quality.
     * @summary Perform a voice search
     * @param {SearchApiPerformVoiceSearchRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    SearchApi.prototype.performVoiceSearch = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SearchApiFp)(this.configuration).performVoiceSearch(requestParameters.query, requestParameters.sectionId, requestParameters.limit, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SearchApi;
}(base_1.BaseAPI));
exports.SearchApi = SearchApi;
/**
 * SecurityApi - axios parameter creator
 * @export
 */
var SecurityApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4.
         * @summary Get Source Connection Information
         * @param {any} source The source identifier with an included prefix.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionInformation: function (source, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'source' is not null or undefined
                            (0, common_1.assertParamExists)('getConnectionInformation', 'source', source);
                            localVarPath = "/security/resources";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (source !== undefined) {
                                localVarQueryParameter['source'] = source;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted.
         * @summary Get a Transient Token.
         * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
         * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransientToken: function (type, scope, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'type' is not null or undefined
                            (0, common_1.assertParamExists)('getTransientToken', 'type', type);
                            // verify required parameter 'scope' is not null or undefined
                            (0, common_1.assertParamExists)('getTransientToken', 'scope', scope);
                            localVarPath = "/security/token";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (type !== undefined) {
                                localVarQueryParameter['type'] = type;
                            }
                            if (scope !== undefined) {
                                localVarQueryParameter['scope'] = scope;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SecurityApiAxiosParamCreator = SecurityApiAxiosParamCreator;
/**
 * SecurityApi - functional programming interface
 * @export
 */
var SecurityApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SecurityApiAxiosParamCreator)(configuration);
    return {
        /**
         * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4.
         * @summary Get Source Connection Information
         * @param {any} source The source identifier with an included prefix.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionInformation: function (source, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getConnectionInformation(source, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted.
         * @summary Get a Transient Token.
         * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
         * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransientToken: function (type, scope, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getTransientToken(type, scope, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SecurityApiFp = SecurityApiFp;
/**
 * SecurityApi - factory interface
 * @export
 */
var SecurityApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SecurityApiFp)(configuration);
    return {
        /**
         * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4.
         * @summary Get Source Connection Information
         * @param {any} source The source identifier with an included prefix.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionInformation: function (source, axiosOptions) {
            return localVarFp.getConnectionInformation(source, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted.
         * @summary Get a Transient Token.
         * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
         * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransientToken: function (type, scope, axiosOptions) {
            return localVarFp.getTransientToken(type, scope, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SecurityApiFactory = SecurityApiFactory;
/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
var SecurityApi = /** @class */ (function (_super) {
    __extends(SecurityApi, _super);
    function SecurityApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4.
     * @summary Get Source Connection Information
     * @param {SecurityApiGetConnectionInformationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    SecurityApi.prototype.getConnectionInformation = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SecurityApiFp)(this.configuration).getConnectionInformation(requestParameters.source, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted.
     * @summary Get a Transient Token.
     * @param {SecurityApiGetTransientTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    SecurityApi.prototype.getTransientToken = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.SecurityApiFp)(this.configuration).getTransientToken(requestParameters.type, requestParameters.scope, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SecurityApi;
}(base_1.BaseAPI));
exports.SecurityApi = SecurityApi;
/**
 * ServerApi - axios parameter creator
 * @export
 */
var ServerApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Server Capabilities
         * @summary Server Capabilities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerCapabilities: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Get Server Preferences
         * @summary Get Server Preferences
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerPreferences: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/:/prefs";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.ServerApiAxiosParamCreator = ServerApiAxiosParamCreator;
/**
 * ServerApi - functional programming interface
 * @export
 */
var ServerApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.ServerApiAxiosParamCreator)(configuration);
    return {
        /**
         * Server Capabilities
         * @summary Server Capabilities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerCapabilities: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getServerCapabilities(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Get Server Preferences
         * @summary Get Server Preferences
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerPreferences: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getServerPreferences(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.ServerApiFp = ServerApiFp;
/**
 * ServerApi - factory interface
 * @export
 */
var ServerApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.ServerApiFp)(configuration);
    return {
        /**
         * Server Capabilities
         * @summary Server Capabilities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerCapabilities: function (axiosOptions) {
            return localVarFp.getServerCapabilities(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get Server Preferences
         * @summary Get Server Preferences
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getServerPreferences: function (axiosOptions) {
            return localVarFp.getServerPreferences(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.ServerApiFactory = ServerApiFactory;
/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
var ServerApi = /** @class */ (function (_super) {
    __extends(ServerApi, _super);
    function ServerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Server Capabilities
     * @summary Server Capabilities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    ServerApi.prototype.getServerCapabilities = function (axiosOptions) {
        var _this = this;
        return (0, exports.ServerApiFp)(this.configuration).getServerCapabilities(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Get Server Preferences
     * @summary Get Server Preferences
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    ServerApi.prototype.getServerPreferences = function (axiosOptions) {
        var _this = this;
        return (0, exports.ServerApiFp)(this.configuration).getServerPreferences(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ServerApi;
}(base_1.BaseAPI));
exports.ServerApi = ServerApi;
/**
 * SessionsApi - axios parameter creator
 * @export
 */
var SessionsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * This will Retrieve a listing of all history views.
         * @summary Get Session History
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSessionHistory: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/status/sessions/history/all";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * This will retrieve the \"Now Playing\" Information of the PMS.
         * @summary Get Active Sessions
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/status/sessions";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.SessionsApiAxiosParamCreator = SessionsApiAxiosParamCreator;
/**
 * SessionsApi - functional programming interface
 * @export
 */
var SessionsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SessionsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This will Retrieve a listing of all history views.
         * @summary Get Session History
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSessionHistory: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSessionHistory(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * This will retrieve the \"Now Playing\" Information of the PMS.
         * @summary Get Active Sessions
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSessions(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.SessionsApiFp = SessionsApiFp;
/**
 * SessionsApi - factory interface
 * @export
 */
var SessionsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SessionsApiFp)(configuration);
    return {
        /**
         * This will Retrieve a listing of all history views.
         * @summary Get Session History
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSessionHistory: function (axiosOptions) {
            return localVarFp.getSessionHistory(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * This will retrieve the \"Now Playing\" Information of the PMS.
         * @summary Get Active Sessions
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: function (axiosOptions) {
            return localVarFp.getSessions(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SessionsApiFactory = SessionsApiFactory;
/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
var SessionsApi = /** @class */ (function (_super) {
    __extends(SessionsApi, _super);
    function SessionsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This will Retrieve a listing of all history views.
     * @summary Get Session History
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    SessionsApi.prototype.getSessionHistory = function (axiosOptions) {
        var _this = this;
        return (0, exports.SessionsApiFp)(this.configuration).getSessionHistory(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * This will retrieve the \"Now Playing\" Information of the PMS.
     * @summary Get Active Sessions
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    SessionsApi.prototype.getSessions = function (axiosOptions) {
        var _this = this;
        return (0, exports.SessionsApiFp)(this.configuration).getSessions(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return SessionsApi;
}(base_1.BaseAPI));
exports.SessionsApi = SessionsApi;
/**
 * UpdaterApi - axios parameter creator
 * @export
 */
var UpdaterApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed
         * @summary Applying updates
         * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
         * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        applyUpdates: function (tonight, skip, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/updater/apply";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (tonight !== undefined) {
                                localVarQueryParameter['tonight'] = tonight;
                            }
                            if (skip !== undefined) {
                                localVarQueryParameter['skip'] = skip;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Checking for updates
         * @summary Checking for updates
         * @param {any} [download] Indicate that you want to start download any updates found.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        checkForUpdates: function (download, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/updater/check";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (download !== undefined) {
                                localVarQueryParameter['download'] = download;
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Querying status of updates
         * @summary Querying status of updates
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryUpdateStatus: function (axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            localVarPath = "/updater/status";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.UpdaterApiAxiosParamCreator = UpdaterApiAxiosParamCreator;
/**
 * UpdaterApi - functional programming interface
 * @export
 */
var UpdaterApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.UpdaterApiAxiosParamCreator)(configuration);
    return {
        /**
         * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed
         * @summary Applying updates
         * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
         * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        applyUpdates: function (tonight, skip, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.applyUpdates(tonight, skip, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Checking for updates
         * @summary Checking for updates
         * @param {any} [download] Indicate that you want to start download any updates found.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        checkForUpdates: function (download, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.checkForUpdates(download, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Querying status of updates
         * @summary Querying status of updates
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryUpdateStatus: function (axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.queryUpdateStatus(axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.UpdaterApiFp = UpdaterApiFp;
/**
 * UpdaterApi - factory interface
 * @export
 */
var UpdaterApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.UpdaterApiFp)(configuration);
    return {
        /**
         * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed
         * @summary Applying updates
         * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
         * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        applyUpdates: function (tonight, skip, axiosOptions) {
            return localVarFp.applyUpdates(tonight, skip, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Checking for updates
         * @summary Checking for updates
         * @param {any} [download] Indicate that you want to start download any updates found.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        checkForUpdates: function (download, axiosOptions) {
            return localVarFp.checkForUpdates(download, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Querying status of updates
         * @summary Querying status of updates
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryUpdateStatus: function (axiosOptions) {
            return localVarFp.queryUpdateStatus(axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.UpdaterApiFactory = UpdaterApiFactory;
/**
 * UpdaterApi - object-oriented interface
 * @export
 * @class UpdaterApi
 * @extends {BaseAPI}
 */
var UpdaterApi = /** @class */ (function (_super) {
    __extends(UpdaterApi, _super);
    function UpdaterApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed
     * @summary Applying updates
     * @param {UpdaterApiApplyUpdatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    UpdaterApi.prototype.applyUpdates = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.UpdaterApiFp)(this.configuration).applyUpdates(requestParameters.tonight, requestParameters.skip, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Checking for updates
     * @summary Checking for updates
     * @param {UpdaterApiCheckForUpdatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    UpdaterApi.prototype.checkForUpdates = function (requestParameters, axiosOptions) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.UpdaterApiFp)(this.configuration).checkForUpdates(requestParameters.download, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Querying status of updates
     * @summary Querying status of updates
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    UpdaterApi.prototype.queryUpdateStatus = function (axiosOptions) {
        var _this = this;
        return (0, exports.UpdaterApiFp)(this.configuration).queryUpdateStatus(axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return UpdaterApi;
}(base_1.BaseAPI));
exports.UpdaterApi = UpdaterApi;
/**
 * UserApi - axios parameter creator
 * @export
 */
var UserApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Get Logged in User
         * @summary Get Logged in User
         * @param {any} xPlexClientIdentifier Unique Id, UUID, serial number, or other number unique per device that identifies your client
         * @param {any} [xPlexDeviceName] Primary name for the device eg. &#x60;Plex Web (Chrome)&#x60;
         * @param {any} [xPlexDevice] The type of device your application is running on Device name and or model number, eg &#x60;iPhone3,2&#x60;, &#x60;Motorola XOOM™&#x60;, &#x60;LG5200TV&#x60;
         * @param {any} [xPlexPlatformVersion] Operating system version, eg &#x60;4.3.1&#x60;, &#x60;10.6.7&#x60;, &#x60;3.2&#x60;
         * @param {any} [xPlexPlatform] Platform name, eg &#x60;Web&#x60;, &#x60;iOS&#x60;, &#x60;MacOSX&#x60;, &#x60;Android&#x60;, &#x60;LG&#x60;
         * @param {any} [xPlexProduct] Plex application name, eg &#x60;Laika&#x60;, &#x60;Plex Media Server&#x60;, &#x60;Media Link&#x60;
         * @param {any} [xPlexProvides] One or more of &#x60;[player, controller, server]&#x60;
         * @param {any} [xPlexVersion] Your application version number
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserDetails: function (xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions) {
            if (axiosOptions === void 0) { axiosOptions = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'xPlexClientIdentifier' is not null or undefined
                            (0, common_1.assertParamExists)('getCurrentUserDetails', 'xPlexClientIdentifier', xPlexClientIdentifier);
                            localVarPath = "/user";
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), axiosOptions);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication PlexToken required
                            return [4 /*yield*/, (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Plex-Token", configuration)];
                        case 1:
                            // authentication PlexToken required
                            _a.sent();
                            if (xPlexClientIdentifier !== undefined && xPlexClientIdentifier !== null) {
                                localVarHeaderParameter['X-Plex-Client-Identifier'] = String(JSON.stringify(xPlexClientIdentifier));
                            }
                            if (xPlexDeviceName !== undefined && xPlexDeviceName !== null) {
                                localVarHeaderParameter['X-Plex-Device-Name'] = String(JSON.stringify(xPlexDeviceName));
                            }
                            if (xPlexDevice !== undefined && xPlexDevice !== null) {
                                localVarHeaderParameter['X-Plex-Device'] = String(JSON.stringify(xPlexDevice));
                            }
                            if (xPlexPlatformVersion !== undefined && xPlexPlatformVersion !== null) {
                                localVarHeaderParameter['X-Plex-Platform-Version'] = String(JSON.stringify(xPlexPlatformVersion));
                            }
                            if (xPlexPlatform !== undefined && xPlexPlatform !== null) {
                                localVarHeaderParameter['X-Plex-Platform'] = String(JSON.stringify(xPlexPlatform));
                            }
                            if (xPlexProduct !== undefined && xPlexProduct !== null) {
                                localVarHeaderParameter['X-Plex-Product'] = String(JSON.stringify(xPlexProduct));
                            }
                            if (xPlexProvides !== undefined && xPlexProvides !== null) {
                                localVarHeaderParameter['X-Plex-Provides'] = String(JSON.stringify(xPlexProvides));
                            }
                            if (xPlexVersion !== undefined && xPlexVersion !== null) {
                                localVarHeaderParameter['X-Plex-Version'] = String(JSON.stringify(xPlexVersion));
                            }
                            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), axiosOptions.headers);
                            return [2 /*return*/, {
                                    url: (0, common_1.toPathString)(localVarUrlObj),
                                    axiosOptions: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
exports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;
/**
 * UserApi - functional programming interface
 * @export
 */
var UserApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.UserApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get Logged in User
         * @summary Get Logged in User
         * @param {any} xPlexClientIdentifier Unique Id, UUID, serial number, or other number unique per device that identifies your client
         * @param {any} [xPlexDeviceName] Primary name for the device eg. &#x60;Plex Web (Chrome)&#x60;
         * @param {any} [xPlexDevice] The type of device your application is running on Device name and or model number, eg &#x60;iPhone3,2&#x60;, &#x60;Motorola XOOM™&#x60;, &#x60;LG5200TV&#x60;
         * @param {any} [xPlexPlatformVersion] Operating system version, eg &#x60;4.3.1&#x60;, &#x60;10.6.7&#x60;, &#x60;3.2&#x60;
         * @param {any} [xPlexPlatform] Platform name, eg &#x60;Web&#x60;, &#x60;iOS&#x60;, &#x60;MacOSX&#x60;, &#x60;Android&#x60;, &#x60;LG&#x60;
         * @param {any} [xPlexProduct] Plex application name, eg &#x60;Laika&#x60;, &#x60;Plex Media Server&#x60;, &#x60;Media Link&#x60;
         * @param {any} [xPlexProvides] One or more of &#x60;[player, controller, server]&#x60;
         * @param {any} [xPlexVersion] Your application version number
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserDetails: function (xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCurrentUserDetails(xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
exports.UserApiFp = UserApiFp;
/**
 * UserApi - factory interface
 * @export
 */
var UserApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.UserApiFp)(configuration);
    return {
        /**
         * Get Logged in User
         * @summary Get Logged in User
         * @param {any} xPlexClientIdentifier Unique Id, UUID, serial number, or other number unique per device that identifies your client
         * @param {any} [xPlexDeviceName] Primary name for the device eg. &#x60;Plex Web (Chrome)&#x60;
         * @param {any} [xPlexDevice] The type of device your application is running on Device name and or model number, eg &#x60;iPhone3,2&#x60;, &#x60;Motorola XOOM™&#x60;, &#x60;LG5200TV&#x60;
         * @param {any} [xPlexPlatformVersion] Operating system version, eg &#x60;4.3.1&#x60;, &#x60;10.6.7&#x60;, &#x60;3.2&#x60;
         * @param {any} [xPlexPlatform] Platform name, eg &#x60;Web&#x60;, &#x60;iOS&#x60;, &#x60;MacOSX&#x60;, &#x60;Android&#x60;, &#x60;LG&#x60;
         * @param {any} [xPlexProduct] Plex application name, eg &#x60;Laika&#x60;, &#x60;Plex Media Server&#x60;, &#x60;Media Link&#x60;
         * @param {any} [xPlexProvides] One or more of &#x60;[player, controller, server]&#x60;
         * @param {any} [xPlexVersion] Your application version number
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserDetails: function (xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions) {
            return localVarFp.getCurrentUserDetails(xPlexClientIdentifier, xPlexDeviceName, xPlexDevice, xPlexPlatformVersion, xPlexPlatform, xPlexProduct, xPlexProvides, xPlexVersion, axiosOptions).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.UserApiFactory = UserApiFactory;
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
var UserApi = /** @class */ (function (_super) {
    __extends(UserApi, _super);
    function UserApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get Logged in User
     * @summary Get Logged in User
     * @param {UserApiGetCurrentUserDetailsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    UserApi.prototype.getCurrentUserDetails = function (requestParameters, axiosOptions) {
        var _this = this;
        return (0, exports.UserApiFp)(this.configuration).getCurrentUserDetails(requestParameters.xPlexClientIdentifier, requestParameters.xPlexDeviceName, requestParameters.xPlexDevice, requestParameters.xPlexPlatformVersion, requestParameters.xPlexPlatform, requestParameters.xPlexProduct, requestParameters.xPlexProvides, requestParameters.xPlexVersion, axiosOptions).then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return UserApi;
}(base_1.BaseAPI));
exports.UserApi = UserApi;
//# sourceMappingURL=api.js.map