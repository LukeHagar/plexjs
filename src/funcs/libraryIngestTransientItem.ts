/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { PlexAPICore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import { PlexAPIError } from "../models/errors/plexapierror.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Ingest a transient item
 *
 * @remarks
 * This endpoint takes a file path specified in the `url` parameter, matches it using the scanner's match mechanism, downloads rich metadata, and then ingests the item as a transient item (without a library section). In the case where the file represents an episode, the entire tree (show, season, and episode) is added as transient items. At this time, movies and episodes are the only supported types, which are gleaned automatically from the file path.
 * Note that any of the parameters passed to the metadata details endpoint (e.g. `includeExtras=1`) work here.
 */
export function libraryIngestTransientItem(
  client: PlexAPICore,
  request: operations.IngestTransientItemRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.IngestTransientItemResponse,
    | PlexAPIError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: PlexAPICore,
  request: operations.IngestTransientItemRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.IngestTransientItemResponse,
      | PlexAPIError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.IngestTransientItemRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/library/file")();

  const query = encodeFormQuery({
    "computeHashes": payload.computeHashes,
    "ingestNonMatches": payload.ingestNonMatches,
    "url": payload.url,
    "virtualFilePath": payload.virtualFilePath,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
    "X-Plex-Client-Identifier": encodeSimple(
      "X-Plex-Client-Identifier",
      payload["Client-Identifier"] ?? client._options.clientIdentifier,
      { explode: false, charEncoding: "none" },
    ),
    "X-Plex-Device": encodeSimple(
      "X-Plex-Device",
      payload.Device ?? client._options.device,
      { explode: false, charEncoding: "none" },
    ),
    "X-Plex-Device-Name": encodeSimple(
      "X-Plex-Device-Name",
      payload["Device-Name"] ?? client._options.deviceName,
      { explode: false, charEncoding: "none" },
    ),
    "X-Plex-Device-Vendor": encodeSimple(
      "X-Plex-Device-Vendor",
      payload["Device-Vendor"] ?? client._options.deviceVendor,
      { explode: false, charEncoding: "none" },
    ),
    "X-Plex-Marketplace": encodeSimple(
      "X-Plex-Marketplace",
      payload.Marketplace ?? client._options.marketplace,
      { explode: false, charEncoding: "none" },
    ),
    "X-Plex-Model": encodeSimple(
      "X-Plex-Model",
      payload.Model ?? client._options.model,
      { explode: false, charEncoding: "none" },
    ),
    "X-Plex-Platform": encodeSimple(
      "X-Plex-Platform",
      payload.Platform ?? client._options.platform,
      { explode: false, charEncoding: "none" },
    ),
    "X-Plex-Platform-Version": encodeSimple(
      "X-Plex-Platform-Version",
      payload["Platform-Version"] ?? client._options.platformVersion,
      { explode: false, charEncoding: "none" },
    ),
    "X-Plex-Product": encodeSimple(
      "X-Plex-Product",
      payload.Product ?? client._options.product,
      { explode: false, charEncoding: "none" },
    ),
    "X-Plex-Version": encodeSimple(
      "X-Plex-Version",
      payload.Version ?? client._options.version,
      { explode: false, charEncoding: "none" },
    ),
    "accepts": encodeSimple(
      "accepts",
      payload.accepts ?? client._options.accepts,
      { explode: false, charEncoding: "none" },
    ),
  }));

  const secConfig = await extractSecurity(client._options.token);
  const securityInput = secConfig == null ? {} : { token: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "ingestTransientItem",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: client._options.token,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    operations.IngestTransientItemResponse,
    | PlexAPIError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, operations.IngestTransientItemResponse$inboundSchema, {
      hdrs: true,
      key: "Result",
    }),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
