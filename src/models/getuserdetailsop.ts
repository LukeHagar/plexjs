/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { remap as remap$ } from "../lib/primitives.js";
import * as z from "zod";

export const GetUserDetailsOpServerList = ["https://plex.tv/api/v2"] as const;

export type GetUserDetailsErrors = {
    code?: number | undefined;
    message?: string | undefined;
    status?: number | undefined;
};

/**
 * Unauthorized - Returned if the X-Plex-Token is missing from the header or query.
 */
export type GetUserDetailsResponseBodyData = {
    errors?: Array<GetUserDetailsErrors> | undefined;
    /**
     * Raw HTTP response; suitable for custom response parsing
     */
    rawResponse?: Response | undefined;
};

/**
 * Unauthorized - Returned if the X-Plex-Token is missing from the header or query.
 */
export class GetUserDetailsResponseBody extends Error {
    errors?: Array<GetUserDetailsErrors> | undefined;
    /**
     * Raw HTTP response; suitable for custom response parsing
     */
    rawResponse?: Response | undefined;

    /** The original data that was passed to this error instance. */
    data$: GetUserDetailsResponseBodyData;

    constructor(err: GetUserDetailsResponseBodyData) {
        const message =
            "message" in err && typeof err.message === "string"
                ? err.message
                : `API error occurred: ${JSON.stringify(err)}`;
        super(message);
        this.data$ = err;

        if (err.errors != null) {
            this.errors = err.errors;
        }
        if (err.rawResponse != null) {
            this.rawResponse = err.rawResponse;
        }

        this.name = "GetUserDetailsResponseBody";
    }
}

/**
 * Your current mailing list status
 */
export enum MailingListStatus {
    Subscribed = "subscribed",
    Unsubscribed = "unsubscribed",
}

export type UserProfile = {
    /**
     * If the account has automatically select audio and subtitle tracks enabled
     */
    autoSelectAudio?: boolean | undefined;
    /**
     * The preferred audio language for the account
     */
    defaultAudioLanguage?: string | undefined;
    /**
     * The preferred subtitle language for the account
     */
    defaultSubtitleLanguage?: string | undefined;
    /**
     * The auto-select subtitle mode (0 = Manually selected, 1 = Shown with foreign audio, 2 = Always enabled)
     */
    autoSelectSubtitle?: number | undefined;
    /**
     * The subtitles for the deaf or hard-of-hearing (SDH) searches mode (0 = Prefer non-SDH subtitles, 1 = Prefer SDH subtitles, 2 = Only show SDH subtitles, 3 = Only shown non-SDH subtitles)
     */
    defaultSubtitleAccessibility?: number | undefined;
    /**
     * The forced subtitles searches mode (0 = Prefer non-forced subtitles, 1 = Prefer forced subtitles, 2 = Only show forced subtitles, 3 = Only show non-forced subtitles)
     */
    defaultSubtitleForced?: number | undefined;
    watchedIndicator?: number | undefined;
    mediaReviewsVisibility?: number | undefined;
};

export enum GetUserDetailsStatus {
    Online = "online",
    Offline = "offline",
}

export type Services = {
    identifier: string;
    endpoint: string;
    token: string | null;
    secret: string | null;
    status: GetUserDetailsStatus;
};

export enum Features {
    AndroidDolbyVision = "Android - Dolby Vision",
    AndroidPiP = "Android - PiP",
    CUSunset = "CU Sunset",
    HRKEnableEUR = "HRK_enable_EUR",
    TREBLEShowFeatures = "TREBLE-show-features",
    AdCountdownTimer = "ad-countdown-timer",
    AdaptiveBitrate = "adaptive_bitrate",
    AmazonLoopDebug = "amazon-loop-debug",
    AvodAdAnalysis = "avod-ad-analysis",
    AvodNewMedia = "avod-new-media",
    BlacklistGetSignin = "blacklist_get_signin",
    ClientRadioStations = "client-radio-stations",
    CloudflareTurnstileRequired = "cloudflare-turnstile-required",
    Collections = "collections",
    CommentsAndRepliesPushNotifications = "comments_and_replies_push_notifications",
    CommunityAccessPlexTv = "community_access_plex_tv",
    CompanionsSonos = "companions_sonos",
    CustomHomeRemoval = "custom-home-removal",
    DisableHomeUserFriendships = "disable_home_user_friendships",
    DisableSharingFriendships = "disable_sharing_friendships",
    DrmSupport = "drm_support",
    ExcludeRestrictions = "exclude restrictions",
    FederatedAuth = "federated-auth",
    FriendRequestPushNotifications = "friend_request_push_notifications",
    GuidedUpgrade = "guided-upgrade",
    Home = "home",
    IncreasePasswordComplexity = "increase-password-complexity",
    Ios14PrivacyBanner = "ios14-privacy-banner",
    IterableNotificationTokens = "iterable-notification-tokens",
    KeepPaymentMethod = "keep-payment-method",
    KevinBacon = "kevin-bacon",
    KoreaConsent = "korea-consent",
    LeIsrgRootX1 = "le_isrg_root_x1",
    LetsEncrypt = "lets_encrypt",
    LightningDvrPivot = "lightning-dvr-pivot",
    LiveTvSupportIncompleteSegments = "live-tv-support-incomplete-segments",
    Livetv = "livetv",
    MetadataSearch = "metadata_search",
    NewPlexPassPrices = "new_plex_pass_prices",
    NewsProviderSunsetModal = "news-provider-sunset-modal",
    PhotosFavorites = "photos-favorites",
    PhotosMetadataEdition = "photos-metadata-edition",
    PmsHealth = "pms_health",
    Radio = "radio",
    RateLimitClientToken = "rate-limit-client-token",
    ScrobblingServicePlexTv = "scrobbling-service-plex-tv",
    SharedServerNotification = "shared_server_notification",
    SharedSourceNotification = "shared_source_notification",
    SigninWithApple = "signin_with_apple",
    SpringServeAdProvider = "spring_serve_ad_provider",
    TranscoderCache = "transcoder_cache",
    TunerSharing = "tuner-sharing",
    TwoFactorAuthentication = "two-factor-authentication",
    Unsupportedtuners = "unsupportedtuners",
    Upgrade3ds2 = "upgrade-3ds2",
    VodSchema = "vod-schema",
    VodCloudflare = "vod_cloudflare",
    WatchTogetherInvite = "watch-together-invite",
    WebServerDashboard = "web_server_dashboard",
}

/**
 * String representation of subscriptionActive
 */
export enum GetUserDetailsPlexStatus {
    Inactive = "Inactive",
    Active = "Active",
}

/**
 * If the account’s Plex Pass subscription is active
 */
export type Subscription = {
    /**
     * List of features allowed on your Plex Pass subscription
     */
    features?: Array<Features> | undefined;
    /**
     * If the account's Plex Pass subscription is active
     */
    active?: boolean | undefined;
    /**
     * Date the account subscribed to Plex Pass
     */
    subscribedAt?: Date | undefined;
    /**
     * String representation of subscriptionActive
     */
    status?: GetUserDetailsPlexStatus | undefined;
    /**
     * Payment service used for your Plex Pass subscription
     */
    paymentService?: string | null | undefined;
    /**
     * Name of Plex Pass subscription plan
     */
    plan?: string | null | undefined;
};

export enum GetUserDetailsFeatures {
    AndroidDolbyVision = "Android - Dolby Vision",
    AndroidPiP = "Android - PiP",
    CUSunset = "CU Sunset",
    HRKEnableEUR = "HRK_enable_EUR",
    TREBLEShowFeatures = "TREBLE-show-features",
    AdCountdownTimer = "ad-countdown-timer",
    AdaptiveBitrate = "adaptive_bitrate",
    AmazonLoopDebug = "amazon-loop-debug",
    AvodAdAnalysis = "avod-ad-analysis",
    AvodNewMedia = "avod-new-media",
    BlacklistGetSignin = "blacklist_get_signin",
    ClientRadioStations = "client-radio-stations",
    CloudflareTurnstileRequired = "cloudflare-turnstile-required",
    Collections = "collections",
    CommentsAndRepliesPushNotifications = "comments_and_replies_push_notifications",
    CommunityAccessPlexTv = "community_access_plex_tv",
    CompanionsSonos = "companions_sonos",
    CustomHomeRemoval = "custom-home-removal",
    DisableHomeUserFriendships = "disable_home_user_friendships",
    DisableSharingFriendships = "disable_sharing_friendships",
    DrmSupport = "drm_support",
    ExcludeRestrictions = "exclude restrictions",
    FederatedAuth = "federated-auth",
    FriendRequestPushNotifications = "friend_request_push_notifications",
    GuidedUpgrade = "guided-upgrade",
    Home = "home",
    IncreasePasswordComplexity = "increase-password-complexity",
    Ios14PrivacyBanner = "ios14-privacy-banner",
    IterableNotificationTokens = "iterable-notification-tokens",
    KeepPaymentMethod = "keep-payment-method",
    KevinBacon = "kevin-bacon",
    KoreaConsent = "korea-consent",
    LeIsrgRootX1 = "le_isrg_root_x1",
    LetsEncrypt = "lets_encrypt",
    LightningDvrPivot = "lightning-dvr-pivot",
    LiveTvSupportIncompleteSegments = "live-tv-support-incomplete-segments",
    Livetv = "livetv",
    MetadataSearch = "metadata_search",
    NewPlexPassPrices = "new_plex_pass_prices",
    NewsProviderSunsetModal = "news-provider-sunset-modal",
    PhotosFavorites = "photos-favorites",
    PhotosMetadataEdition = "photos-metadata-edition",
    PmsHealth = "pms_health",
    Radio = "radio",
    RateLimitClientToken = "rate-limit-client-token",
    ScrobblingServicePlexTv = "scrobbling-service-plex-tv",
    SharedServerNotification = "shared_server_notification",
    SharedSourceNotification = "shared_source_notification",
    SigninWithApple = "signin_with_apple",
    SpringServeAdProvider = "spring_serve_ad_provider",
    TranscoderCache = "transcoder_cache",
    TunerSharing = "tuner-sharing",
    TwoFactorAuthentication = "two-factor-authentication",
    Unsupportedtuners = "unsupportedtuners",
    Upgrade3ds2 = "upgrade-3ds2",
    VodSchema = "vod-schema",
    VodCloudflare = "vod_cloudflare",
    WatchTogetherInvite = "watch-together-invite",
    WebServerDashboard = "web_server_dashboard",
}

/**
 * String representation of subscriptionActive
 */
export enum GetUserDetailsPlexResponseStatus {
    Inactive = "Inactive",
    Active = "Active",
}

export type GetUserDetailsSubscription = {
    /**
     * List of features allowed on your Plex Pass subscription
     */
    features?: Array<GetUserDetailsFeatures> | undefined;
    /**
     * If the account's Plex Pass subscription is active
     */
    active?: boolean | undefined;
    /**
     * Date the account subscribed to Plex Pass
     */
    subscribedAt?: Date | undefined;
    /**
     * String representation of subscriptionActive
     */
    status?: GetUserDetailsPlexResponseStatus | undefined;
    /**
     * Payment service used for your Plex Pass subscription
     */
    paymentService?: string | null | undefined;
    /**
     * Name of Plex Pass subscription plan
     */
    plan?: string | null | undefined;
};

/**
 * Logged in user details
 */
export type GetUserDetailsUserPlexAccount = {
    /**
     * Unknown
     */
    adsConsent: boolean | null;
    /**
     * Unknown
     */
    adsConsentReminderAt: Date | null;
    /**
     * Unknown
     */
    adsConsentSetAt: Date | null;
    /**
     * Unknown
     */
    anonymous?: boolean | undefined;
    /**
     * The account token
     */
    authToken: string;
    /**
     * If the two-factor authentication backup codes have been created
     */
    backupCodesCreated?: boolean | undefined;
    /**
     * If the account has been confirmed
     */
    confirmed?: boolean | undefined;
    /**
     * The account country
     */
    country: string;
    /**
     * The account email address
     */
    email: string;
    /**
     * If login with email only is enabled
     */
    emailOnlyAuth?: boolean | undefined;
    /**
     * If experimental features are enabled
     */
    experimentalFeatures?: boolean | undefined;
    /**
     * Your account full name
     */
    friendlyName: string;
    /**
     * List of devices your allowed to use with this account
     */
    entitlements: Array<string>;
    /**
     * If the account is a Plex Home guest user
     */
    guest?: boolean | undefined;
    /**
     * If the account has a password
     */
    hasPassword?: boolean | undefined;
    /**
     * If the account is a Plex Home user
     */
    home?: boolean | undefined;
    /**
     * If the account is the Plex Home admin
     */
    homeAdmin?: boolean | undefined;
    /**
     * The number of accounts in the Plex Home
     */
    homeSize: number;
    /**
     * The Plex account ID
     */
    id: number;
    /**
     * Unix epoch datetime the account joined Plex
     */
    joinedAt: number;
    /**
     * The account locale
     */
    locale: string | null;
    /**
     * If you are subscribed to the Plex newsletter
     */
    mailingListActive?: boolean | undefined;
    /**
     * Your current mailing list status
     */
    mailingListStatus: MailingListStatus;
    /**
     * The maximum number of accounts allowed in the Plex Home
     */
    maxHomeSize: number;
    /**
     * [Might be removed] The hashed Plex Home PIN
     *
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    pin?: string | undefined;
    profile: Array<UserProfile>;
    /**
     * If the account has a Plex Home PIN enabled
     */
    protected?: boolean | undefined;
    /**
     * Unix epoch datetime the authtoken expires
     */
    rememberExpiresAt: number;
    /**
     * If the account is a Plex Home managed user
     */
    restricted?: boolean | undefined;
    /**
     * [Might be removed] List of account roles. Plexpass membership listed here
     */
    roles?: Array<string> | undefined;
    /**
     * Unknown
     */
    scrobbleTypes: string;
    services: Array<Services>;
    /**
     * If the account’s Plex Pass subscription is active
     */
    subscription: Subscription;
    /**
     * Description of the Plex Pass subscription
     */
    subscriptionDescription: string | null;
    subscriptions: Array<GetUserDetailsSubscription>;
    /**
     * URL of the account thumbnail
     */
    thumb: string;
    /**
     * The title of the account (username or friendly name)
     */
    title: string;
    /**
     * If two-factor authentication is enabled
     */
    twoFactorEnabled?: boolean | undefined;
    /**
     * The account username
     */
    username: string;
    /**
     * The account UUID
     */
    uuid: string;
};

export type GetUserDetailsResponse = {
    /**
     * HTTP response content type for this operation
     */
    contentType: string;
    /**
     * HTTP response status code for this operation
     */
    statusCode: number;
    /**
     * Raw HTTP response; suitable for custom response parsing
     */
    rawResponse: Response;
    /**
     * Logged in user details
     */
    userPlexAccount?: GetUserDetailsUserPlexAccount | undefined;
};

/** @internal */
export const GetUserDetailsErrors$inboundSchema: z.ZodType<
    GetUserDetailsErrors,
    z.ZodTypeDef,
    unknown
> = z.object({
    code: z.number().optional(),
    message: z.string().optional(),
    status: z.number().optional(),
});

/** @internal */
export type GetUserDetailsErrors$Outbound = {
    code?: number | undefined;
    message?: string | undefined;
    status?: number | undefined;
};

/** @internal */
export const GetUserDetailsErrors$outboundSchema: z.ZodType<
    GetUserDetailsErrors$Outbound,
    z.ZodTypeDef,
    GetUserDetailsErrors
> = z.object({
    code: z.number().optional(),
    message: z.string().optional(),
    status: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsErrors$ {
    /** @deprecated use `GetUserDetailsErrors$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsErrors$inboundSchema;
    /** @deprecated use `GetUserDetailsErrors$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsErrors$outboundSchema;
    /** @deprecated use `GetUserDetailsErrors$Outbound` instead. */
    export type Outbound = GetUserDetailsErrors$Outbound;
}

/** @internal */
export const GetUserDetailsResponseBody$inboundSchema: z.ZodType<
    GetUserDetailsResponseBody,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        errors: z.array(z.lazy(() => GetUserDetailsErrors$inboundSchema)).optional(),
        RawResponse: z.instanceof(Response).optional(),
    })
    .transform((v) => {
        const remapped = remap$(v, {
            RawResponse: "rawResponse",
        });

        return new GetUserDetailsResponseBody(remapped);
    });

/** @internal */
export type GetUserDetailsResponseBody$Outbound = {
    errors?: Array<GetUserDetailsErrors$Outbound> | undefined;
    RawResponse?: never | undefined;
};

/** @internal */
export const GetUserDetailsResponseBody$outboundSchema: z.ZodType<
    GetUserDetailsResponseBody$Outbound,
    z.ZodTypeDef,
    GetUserDetailsResponseBody
> = z
    .instanceof(GetUserDetailsResponseBody)
    .transform((v) => v.data$)
    .pipe(
        z
            .object({
                errors: z.array(z.lazy(() => GetUserDetailsErrors$outboundSchema)).optional(),
                rawResponse: z
                    .instanceof(Response)
                    .transform(() => {
                        throw new Error("Response cannot be serialized");
                    })
                    .optional(),
            })
            .transform((v) => {
                return remap$(v, {
                    rawResponse: "RawResponse",
                });
            })
    );

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsResponseBody$ {
    /** @deprecated use `GetUserDetailsResponseBody$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsResponseBody$inboundSchema;
    /** @deprecated use `GetUserDetailsResponseBody$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsResponseBody$outboundSchema;
    /** @deprecated use `GetUserDetailsResponseBody$Outbound` instead. */
    export type Outbound = GetUserDetailsResponseBody$Outbound;
}

/** @internal */
export const MailingListStatus$inboundSchema: z.ZodNativeEnum<typeof MailingListStatus> =
    z.nativeEnum(MailingListStatus);

/** @internal */
export const MailingListStatus$outboundSchema: z.ZodNativeEnum<typeof MailingListStatus> =
    MailingListStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MailingListStatus$ {
    /** @deprecated use `MailingListStatus$inboundSchema` instead. */
    export const inboundSchema = MailingListStatus$inboundSchema;
    /** @deprecated use `MailingListStatus$outboundSchema` instead. */
    export const outboundSchema = MailingListStatus$outboundSchema;
}

/** @internal */
export const UserProfile$inboundSchema: z.ZodType<UserProfile, z.ZodTypeDef, unknown> = z.object({
    autoSelectAudio: z.boolean().default(true),
    defaultAudioLanguage: z.string().optional(),
    defaultSubtitleLanguage: z.string().optional(),
    autoSelectSubtitle: z.number().int().optional(),
    defaultSubtitleAccessibility: z.number().int().optional(),
    defaultSubtitleForced: z.number().int().optional(),
    watchedIndicator: z.number().int().optional(),
    mediaReviewsVisibility: z.number().int().optional(),
});

/** @internal */
export type UserProfile$Outbound = {
    autoSelectAudio: boolean;
    defaultAudioLanguage?: string | undefined;
    defaultSubtitleLanguage?: string | undefined;
    autoSelectSubtitle?: number | undefined;
    defaultSubtitleAccessibility?: number | undefined;
    defaultSubtitleForced?: number | undefined;
    watchedIndicator?: number | undefined;
    mediaReviewsVisibility?: number | undefined;
};

/** @internal */
export const UserProfile$outboundSchema: z.ZodType<
    UserProfile$Outbound,
    z.ZodTypeDef,
    UserProfile
> = z.object({
    autoSelectAudio: z.boolean().default(true),
    defaultAudioLanguage: z.string().optional(),
    defaultSubtitleLanguage: z.string().optional(),
    autoSelectSubtitle: z.number().int().optional(),
    defaultSubtitleAccessibility: z.number().int().optional(),
    defaultSubtitleForced: z.number().int().optional(),
    watchedIndicator: z.number().int().optional(),
    mediaReviewsVisibility: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserProfile$ {
    /** @deprecated use `UserProfile$inboundSchema` instead. */
    export const inboundSchema = UserProfile$inboundSchema;
    /** @deprecated use `UserProfile$outboundSchema` instead. */
    export const outboundSchema = UserProfile$outboundSchema;
    /** @deprecated use `UserProfile$Outbound` instead. */
    export type Outbound = UserProfile$Outbound;
}

/** @internal */
export const GetUserDetailsStatus$inboundSchema: z.ZodNativeEnum<typeof GetUserDetailsStatus> =
    z.nativeEnum(GetUserDetailsStatus);

/** @internal */
export const GetUserDetailsStatus$outboundSchema: z.ZodNativeEnum<typeof GetUserDetailsStatus> =
    GetUserDetailsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsStatus$ {
    /** @deprecated use `GetUserDetailsStatus$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsStatus$inboundSchema;
    /** @deprecated use `GetUserDetailsStatus$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsStatus$outboundSchema;
}

/** @internal */
export const Services$inboundSchema: z.ZodType<Services, z.ZodTypeDef, unknown> = z.object({
    identifier: z.string(),
    endpoint: z.string(),
    token: z.nullable(z.string()),
    secret: z.nullable(z.string()),
    status: GetUserDetailsStatus$inboundSchema,
});

/** @internal */
export type Services$Outbound = {
    identifier: string;
    endpoint: string;
    token: string | null;
    secret: string | null;
    status: string;
};

/** @internal */
export const Services$outboundSchema: z.ZodType<Services$Outbound, z.ZodTypeDef, Services> =
    z.object({
        identifier: z.string(),
        endpoint: z.string(),
        token: z.nullable(z.string()),
        secret: z.nullable(z.string()),
        status: GetUserDetailsStatus$outboundSchema,
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Services$ {
    /** @deprecated use `Services$inboundSchema` instead. */
    export const inboundSchema = Services$inboundSchema;
    /** @deprecated use `Services$outboundSchema` instead. */
    export const outboundSchema = Services$outboundSchema;
    /** @deprecated use `Services$Outbound` instead. */
    export type Outbound = Services$Outbound;
}

/** @internal */
export const Features$inboundSchema: z.ZodNativeEnum<typeof Features> = z.nativeEnum(Features);

/** @internal */
export const Features$outboundSchema: z.ZodNativeEnum<typeof Features> = Features$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Features$ {
    /** @deprecated use `Features$inboundSchema` instead. */
    export const inboundSchema = Features$inboundSchema;
    /** @deprecated use `Features$outboundSchema` instead. */
    export const outboundSchema = Features$outboundSchema;
}

/** @internal */
export const GetUserDetailsPlexStatus$inboundSchema: z.ZodNativeEnum<
    typeof GetUserDetailsPlexStatus
> = z.nativeEnum(GetUserDetailsPlexStatus);

/** @internal */
export const GetUserDetailsPlexStatus$outboundSchema: z.ZodNativeEnum<
    typeof GetUserDetailsPlexStatus
> = GetUserDetailsPlexStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsPlexStatus$ {
    /** @deprecated use `GetUserDetailsPlexStatus$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsPlexStatus$inboundSchema;
    /** @deprecated use `GetUserDetailsPlexStatus$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsPlexStatus$outboundSchema;
}

/** @internal */
export const Subscription$inboundSchema: z.ZodType<Subscription, z.ZodTypeDef, unknown> = z.object({
    features: z.array(Features$inboundSchema).optional(),
    active: z.boolean().optional(),
    subscribedAt: z
        .string()
        .datetime({ offset: true })
        .transform((v) => new Date(v))
        .optional(),
    status: GetUserDetailsPlexStatus$inboundSchema.optional(),
    paymentService: z.nullable(z.string()).optional(),
    plan: z.nullable(z.string()).optional(),
});

/** @internal */
export type Subscription$Outbound = {
    features?: Array<string> | undefined;
    active?: boolean | undefined;
    subscribedAt?: string | undefined;
    status?: string | undefined;
    paymentService?: string | null | undefined;
    plan?: string | null | undefined;
};

/** @internal */
export const Subscription$outboundSchema: z.ZodType<
    Subscription$Outbound,
    z.ZodTypeDef,
    Subscription
> = z.object({
    features: z.array(Features$outboundSchema).optional(),
    active: z.boolean().optional(),
    subscribedAt: z
        .date()
        .transform((v) => v.toISOString())
        .optional(),
    status: GetUserDetailsPlexStatus$outboundSchema.optional(),
    paymentService: z.nullable(z.string()).optional(),
    plan: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Subscription$ {
    /** @deprecated use `Subscription$inboundSchema` instead. */
    export const inboundSchema = Subscription$inboundSchema;
    /** @deprecated use `Subscription$outboundSchema` instead. */
    export const outboundSchema = Subscription$outboundSchema;
    /** @deprecated use `Subscription$Outbound` instead. */
    export type Outbound = Subscription$Outbound;
}

/** @internal */
export const GetUserDetailsFeatures$inboundSchema: z.ZodNativeEnum<typeof GetUserDetailsFeatures> =
    z.nativeEnum(GetUserDetailsFeatures);

/** @internal */
export const GetUserDetailsFeatures$outboundSchema: z.ZodNativeEnum<typeof GetUserDetailsFeatures> =
    GetUserDetailsFeatures$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsFeatures$ {
    /** @deprecated use `GetUserDetailsFeatures$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsFeatures$inboundSchema;
    /** @deprecated use `GetUserDetailsFeatures$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsFeatures$outboundSchema;
}

/** @internal */
export const GetUserDetailsPlexResponseStatus$inboundSchema: z.ZodNativeEnum<
    typeof GetUserDetailsPlexResponseStatus
> = z.nativeEnum(GetUserDetailsPlexResponseStatus);

/** @internal */
export const GetUserDetailsPlexResponseStatus$outboundSchema: z.ZodNativeEnum<
    typeof GetUserDetailsPlexResponseStatus
> = GetUserDetailsPlexResponseStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsPlexResponseStatus$ {
    /** @deprecated use `GetUserDetailsPlexResponseStatus$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsPlexResponseStatus$inboundSchema;
    /** @deprecated use `GetUserDetailsPlexResponseStatus$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsPlexResponseStatus$outboundSchema;
}

/** @internal */
export const GetUserDetailsSubscription$inboundSchema: z.ZodType<
    GetUserDetailsSubscription,
    z.ZodTypeDef,
    unknown
> = z.object({
    features: z.array(GetUserDetailsFeatures$inboundSchema).optional(),
    active: z.boolean().optional(),
    subscribedAt: z
        .string()
        .datetime({ offset: true })
        .transform((v) => new Date(v))
        .optional(),
    status: GetUserDetailsPlexResponseStatus$inboundSchema.optional(),
    paymentService: z.nullable(z.string()).optional(),
    plan: z.nullable(z.string()).optional(),
});

/** @internal */
export type GetUserDetailsSubscription$Outbound = {
    features?: Array<string> | undefined;
    active?: boolean | undefined;
    subscribedAt?: string | undefined;
    status?: string | undefined;
    paymentService?: string | null | undefined;
    plan?: string | null | undefined;
};

/** @internal */
export const GetUserDetailsSubscription$outboundSchema: z.ZodType<
    GetUserDetailsSubscription$Outbound,
    z.ZodTypeDef,
    GetUserDetailsSubscription
> = z.object({
    features: z.array(GetUserDetailsFeatures$outboundSchema).optional(),
    active: z.boolean().optional(),
    subscribedAt: z
        .date()
        .transform((v) => v.toISOString())
        .optional(),
    status: GetUserDetailsPlexResponseStatus$outboundSchema.optional(),
    paymentService: z.nullable(z.string()).optional(),
    plan: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsSubscription$ {
    /** @deprecated use `GetUserDetailsSubscription$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsSubscription$inboundSchema;
    /** @deprecated use `GetUserDetailsSubscription$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsSubscription$outboundSchema;
    /** @deprecated use `GetUserDetailsSubscription$Outbound` instead. */
    export type Outbound = GetUserDetailsSubscription$Outbound;
}

/** @internal */
export const GetUserDetailsUserPlexAccount$inboundSchema: z.ZodType<
    GetUserDetailsUserPlexAccount,
    z.ZodTypeDef,
    unknown
> = z.object({
    adsConsent: z.nullable(z.boolean()),
    adsConsentReminderAt: z.nullable(
        z
            .string()
            .datetime({ offset: true })
            .transform((v) => new Date(v))
    ),
    adsConsentSetAt: z.nullable(
        z
            .string()
            .datetime({ offset: true })
            .transform((v) => new Date(v))
    ),
    anonymous: z.boolean(),
    authToken: z.string(),
    backupCodesCreated: z.boolean(),
    confirmed: z.boolean(),
    country: z.string(),
    email: z.string(),
    emailOnlyAuth: z.boolean(),
    experimentalFeatures: z.boolean(),
    friendlyName: z.string(),
    entitlements: z.array(z.string()),
    guest: z.boolean(),
    hasPassword: z.boolean().default(true),
    home: z.boolean(),
    homeAdmin: z.boolean(),
    homeSize: z.number().int(),
    id: z.number().int(),
    joinedAt: z.number().int(),
    locale: z.nullable(z.string()),
    mailingListActive: z.boolean(),
    mailingListStatus: MailingListStatus$inboundSchema,
    maxHomeSize: z.number().int(),
    pin: z.string().optional(),
    profile: z.array(z.lazy(() => UserProfile$inboundSchema)),
    protected: z.boolean(),
    rememberExpiresAt: z.number().int(),
    restricted: z.boolean(),
    roles: z.array(z.string()).optional(),
    scrobbleTypes: z.string(),
    services: z.array(z.lazy(() => Services$inboundSchema)),
    subscription: z.lazy(() => Subscription$inboundSchema),
    subscriptionDescription: z.nullable(z.string()),
    subscriptions: z.array(z.lazy(() => GetUserDetailsSubscription$inboundSchema)),
    thumb: z.string(),
    title: z.string(),
    twoFactorEnabled: z.boolean(),
    username: z.string(),
    uuid: z.string(),
});

/** @internal */
export type GetUserDetailsUserPlexAccount$Outbound = {
    adsConsent: boolean | null;
    adsConsentReminderAt: string | null;
    adsConsentSetAt: string | null;
    anonymous: boolean;
    authToken: string;
    backupCodesCreated: boolean;
    confirmed: boolean;
    country: string;
    email: string;
    emailOnlyAuth: boolean;
    experimentalFeatures: boolean;
    friendlyName: string;
    entitlements: Array<string>;
    guest: boolean;
    hasPassword: boolean;
    home: boolean;
    homeAdmin: boolean;
    homeSize: number;
    id: number;
    joinedAt: number;
    locale: string | null;
    mailingListActive: boolean;
    mailingListStatus: string;
    maxHomeSize: number;
    pin?: string | undefined;
    profile: Array<UserProfile$Outbound>;
    protected: boolean;
    rememberExpiresAt: number;
    restricted: boolean;
    roles?: Array<string> | undefined;
    scrobbleTypes: string;
    services: Array<Services$Outbound>;
    subscription: Subscription$Outbound;
    subscriptionDescription: string | null;
    subscriptions: Array<GetUserDetailsSubscription$Outbound>;
    thumb: string;
    title: string;
    twoFactorEnabled: boolean;
    username: string;
    uuid: string;
};

/** @internal */
export const GetUserDetailsUserPlexAccount$outboundSchema: z.ZodType<
    GetUserDetailsUserPlexAccount$Outbound,
    z.ZodTypeDef,
    GetUserDetailsUserPlexAccount
> = z.object({
    adsConsent: z.nullable(z.boolean()),
    adsConsentReminderAt: z.nullable(z.date().transform((v) => v.toISOString())),
    adsConsentSetAt: z.nullable(z.date().transform((v) => v.toISOString())),
    anonymous: z.boolean().default(false),
    authToken: z.string(),
    backupCodesCreated: z.boolean().default(false),
    confirmed: z.boolean().default(false),
    country: z.string(),
    email: z.string(),
    emailOnlyAuth: z.boolean().default(false),
    experimentalFeatures: z.boolean().default(false),
    friendlyName: z.string(),
    entitlements: z.array(z.string()),
    guest: z.boolean().default(false),
    hasPassword: z.boolean().default(true),
    home: z.boolean().default(false),
    homeAdmin: z.boolean().default(false),
    homeSize: z.number().int(),
    id: z.number().int(),
    joinedAt: z.number().int(),
    locale: z.nullable(z.string()),
    mailingListActive: z.boolean().default(false),
    mailingListStatus: MailingListStatus$outboundSchema,
    maxHomeSize: z.number().int(),
    pin: z.string().optional(),
    profile: z.array(z.lazy(() => UserProfile$outboundSchema)),
    protected: z.boolean().default(false),
    rememberExpiresAt: z.number().int(),
    restricted: z.boolean().default(false),
    roles: z.array(z.string()).optional(),
    scrobbleTypes: z.string(),
    services: z.array(z.lazy(() => Services$outboundSchema)),
    subscription: z.lazy(() => Subscription$outboundSchema),
    subscriptionDescription: z.nullable(z.string()),
    subscriptions: z.array(z.lazy(() => GetUserDetailsSubscription$outboundSchema)),
    thumb: z.string(),
    title: z.string(),
    twoFactorEnabled: z.boolean().default(false),
    username: z.string(),
    uuid: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsUserPlexAccount$ {
    /** @deprecated use `GetUserDetailsUserPlexAccount$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsUserPlexAccount$inboundSchema;
    /** @deprecated use `GetUserDetailsUserPlexAccount$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsUserPlexAccount$outboundSchema;
    /** @deprecated use `GetUserDetailsUserPlexAccount$Outbound` instead. */
    export type Outbound = GetUserDetailsUserPlexAccount$Outbound;
}

/** @internal */
export const GetUserDetailsResponse$inboundSchema: z.ZodType<
    GetUserDetailsResponse,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        ContentType: z.string(),
        StatusCode: z.number().int(),
        RawResponse: z.instanceof(Response),
        UserPlexAccount: z.lazy(() => GetUserDetailsUserPlexAccount$inboundSchema).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            ContentType: "contentType",
            StatusCode: "statusCode",
            RawResponse: "rawResponse",
            UserPlexAccount: "userPlexAccount",
        });
    });

/** @internal */
export type GetUserDetailsResponse$Outbound = {
    ContentType: string;
    StatusCode: number;
    RawResponse: never;
    UserPlexAccount?: GetUserDetailsUserPlexAccount$Outbound | undefined;
};

/** @internal */
export const GetUserDetailsResponse$outboundSchema: z.ZodType<
    GetUserDetailsResponse$Outbound,
    z.ZodTypeDef,
    GetUserDetailsResponse
> = z
    .object({
        contentType: z.string(),
        statusCode: z.number().int(),
        rawResponse: z.instanceof(Response).transform(() => {
            throw new Error("Response cannot be serialized");
        }),
        userPlexAccount: z.lazy(() => GetUserDetailsUserPlexAccount$outboundSchema).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            contentType: "ContentType",
            statusCode: "StatusCode",
            rawResponse: "RawResponse",
            userPlexAccount: "UserPlexAccount",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsResponse$ {
    /** @deprecated use `GetUserDetailsResponse$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsResponse$inboundSchema;
    /** @deprecated use `GetUserDetailsResponse$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsResponse$outboundSchema;
    /** @deprecated use `GetUserDetailsResponse$Outbound` instead. */
    export type Outbound = GetUserDetailsResponse$Outbound;
}
