/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as shared from "../shared/index.js";

export const PostUsersSignInDataServerList = [
  "https://plex.tv/api/v2",
] as const;

export type PostUsersSignInDataGlobals = {
  /**
   * Indicates the client accepts the indicated media types
   */
  accepts?: shared.Accepts | undefined;
  /**
   * An opaque identifier unique to the client
   */
  clientIdentifier?: string | undefined;
  /**
   * The name of the client product
   */
  product?: string | undefined;
  /**
   * The version of the client application
   */
  version?: string | undefined;
  /**
   * The platform of the client
   */
  platform?: string | undefined;
  /**
   * The version of the platform
   */
  platformVersion?: string | undefined;
  /**
   * A relatively friendly name for the client device
   */
  device?: string | undefined;
  /**
   * A potentially less friendly identifier for the device model
   */
  model?: string | undefined;
  /**
   * The device vendor
   */
  deviceVendor?: string | undefined;
  /**
   * A friendly name for the client
   */
  deviceName?: string | undefined;
  /**
   * The marketplace on which the client application is distributed
   */
  marketplace?: string | undefined;
};

/**
 * Login credentials
 */
export type PostUsersSignInDataRequestBody = {
  login: string;
  password: string;
  rememberMe?: boolean | undefined;
  verificationCode?: string | undefined;
};

export type PostUsersSignInDataRequest = {
  /**
   * Indicates the client accepts the indicated media types
   */
  accepts?: shared.Accepts | undefined;
  /**
   * An opaque identifier unique to the client
   */
  clientIdentifier?: string | undefined;
  /**
   * The name of the client product
   */
  product?: string | undefined;
  /**
   * The version of the client application
   */
  version?: string | undefined;
  /**
   * The platform of the client
   */
  platform?: string | undefined;
  /**
   * The version of the platform
   */
  platformVersion?: string | undefined;
  /**
   * A relatively friendly name for the client device
   */
  device?: string | undefined;
  /**
   * A potentially less friendly identifier for the device model
   */
  model?: string | undefined;
  /**
   * The device vendor
   */
  deviceVendor?: string | undefined;
  /**
   * A friendly name for the client
   */
  deviceName?: string | undefined;
  /**
   * The marketplace on which the client application is distributed
   */
  marketplace?: string | undefined;
  /**
   * Login credentials
   */
  requestBody?: PostUsersSignInDataRequestBody | undefined;
};

export type PostUsersSignInDataUnauthorizedError = {
  code?: number | undefined;
  message?: string | undefined;
  status?: number | undefined;
};

export type PostUsersSignInDataBadRequestError = {
  code?: number | undefined;
  message?: string | undefined;
  status?: number | undefined;
};

/**
 * Your current mailing list status
 */
export enum MailingListStatus {
  Active = "active",
  Unsubscribed = "unsubscribed",
  Removed = "removed",
}
/**
 * Your current mailing list status
 */
export type MailingListStatusOpen = OpenEnum<typeof MailingListStatus>;

export enum ServiceStatus {
  Online = "online",
  Offline = "offline",
}
export type ServiceStatusOpen = OpenEnum<typeof ServiceStatus>;

export type Service = {
  identifier: string;
  endpoint: string;
  token: string | null;
  secret: string | null;
  status: ServiceStatusOpen;
};

/**
 * String representation of subscriptionActive
 */
export enum SubscriptionStatus1 {
  Inactive = "Inactive",
  Active = "Active",
}
/**
 * String representation of subscriptionActive
 */
export type SubscriptionStatus1Open = OpenEnum<typeof SubscriptionStatus1>;

/**
 * If the account's Plex Pass subscription is active
 */
export type Subscription1 = {
  /**
   * List of features allowed on your Plex Pass subscription
   */
  features?: Array<string> | undefined;
  /**
   * If the account's Plex Pass subscription is active
   */
  active?: boolean | undefined;
  /**
   * Date the account subscribed to Plex Pass
   */
  subscribedAt?: string | null | undefined;
  /**
   * String representation of subscriptionActive
   */
  status?: SubscriptionStatus1Open | undefined;
  /**
   * Payment service used for your Plex Pass subscription
   */
  paymentService?: string | null | undefined;
  /**
   * Name of Plex Pass subscription plan
   */
  plan?: string | null | undefined;
};

/**
 * String representation of subscriptionActive
 */
export enum SubscriptionStatus2 {
  Inactive = "Inactive",
  Active = "Active",
}
/**
 * String representation of subscriptionActive
 */
export type SubscriptionStatus2Open = OpenEnum<typeof SubscriptionStatus2>;

export type Subscription2 = {
  /**
   * List of features allowed on your Plex Pass subscription
   */
  features?: Array<string> | undefined;
  /**
   * If the account's Plex Pass subscription is active
   */
  active?: boolean | undefined;
  /**
   * Date the account subscribed to Plex Pass
   */
  subscribedAt?: string | null | undefined;
  /**
   * String representation of subscriptionActive
   */
  status?: SubscriptionStatus2Open | undefined;
  /**
   * Payment service used for your Plex Pass subscription
   */
  paymentService?: string | null | undefined;
  /**
   * Name of Plex Pass subscription plan
   */
  plan?: string | null | undefined;
};

export enum PostUsersSignInDataState {
  Ended = "ended",
}
export type PostUsersSignInDataStateOpen = OpenEnum<
  typeof PostUsersSignInDataState
>;

export type InternalPaymentMethod = {};

export type Billing = {
  internalPaymentMethod: InternalPaymentMethod;
  paymentMethodId: number | null;
};

export type PastSubscription = {
  id: string | null;
  mode: string | null;
  renewsAt: number | null;
  endsAt: number | null;
  canceled?: boolean | undefined;
  gracePeriod?: boolean | undefined;
  onHold?: boolean | undefined;
  canReactivate?: boolean | undefined;
  canUpgrade?: boolean | undefined;
  canDowngrade?: boolean | undefined;
  canConvert?: boolean | undefined;
  type: string;
  transfer: string | null;
  state: PostUsersSignInDataStateOpen;
  billing: Billing;
};

export type Trial = {};

/**
 * Returns the user account data with a valid auth token
 */
export type UserPlexAccount = {
  /**
   * Unknown
   */
  adsConsent?: boolean | null | undefined;
  adsConsentReminderAt?: number | null | undefined;
  adsConsentSetAt?: number | null | undefined;
  /**
   * Unknown
   */
  anonymous?: boolean | null | undefined;
  /**
   * The account token
   */
  authToken: string;
  /**
   * If the two-factor authentication backup codes have been created
   */
  backupCodesCreated?: boolean | undefined;
  /**
   * If the account has been confirmed
   */
  confirmed?: boolean | undefined;
  /**
   * The account country
   */
  country?: string | undefined;
  /**
   * The account email address
   */
  email: string;
  /**
   * If login with email only is enabled
   */
  emailOnlyAuth?: boolean | undefined;
  /**
   * If experimental features are enabled
   */
  experimentalFeatures?: boolean | undefined;
  /**
   * Your account full name
   */
  friendlyName: string;
  /**
   * List of devices your allowed to use with this account
   */
  entitlements?: Array<string> | undefined;
  /**
   * If the account is a Plex Home guest user
   */
  guest?: boolean | undefined;
  /**
   * If the account has a password
   */
  hasPassword?: boolean | undefined;
  /**
   * If the account is a Plex Home user
   */
  home?: boolean | undefined;
  /**
   * If the account is the Plex Home admin
   */
  homeAdmin?: boolean | undefined;
  /**
   * The number of accounts in the Plex Home
   */
  homeSize?: number | undefined;
  /**
   * The Plex account ID
   */
  id: number;
  /**
   * Unix epoch datetime in seconds
   */
  joinedAt: number;
  /**
   * The account locale
   */
  locale?: string | null | undefined;
  /**
   * If you are subscribed to the Plex newsletter
   */
  mailingListActive?: boolean | undefined;
  /**
   * Your current mailing list status
   */
  mailingListStatus?: MailingListStatusOpen | undefined;
  /**
   * The maximum number of accounts allowed in the Plex Home
   */
  maxHomeSize?: number | undefined;
  /**
   * [Might be removed] The hashed Plex Home PIN
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  pin?: string | undefined;
  profile?: shared.UserProfile | undefined;
  /**
   * If the account has a Plex Home PIN enabled
   */
  protected?: boolean | undefined;
  /**
   * Unix epoch datetime in seconds
   */
  rememberExpiresAt?: number | undefined;
  /**
   * If the account is a Plex Home managed user
   */
  restricted?: boolean | undefined;
  /**
   * [Might be removed] List of account roles. Plexpass membership listed here
   */
  roles?: Array<string> | undefined;
  /**
   * Unknown
   */
  scrobbleTypes?: string | undefined;
  services?: Array<Service> | undefined;
  /**
   * If the account's Plex Pass subscription is active
   */
  subscription?: Subscription1 | undefined;
  /**
   * Description of the Plex Pass subscription
   */
  subscriptionDescription?: string | null | undefined;
  subscriptions?: Array<Subscription2> | undefined;
  /**
   * URL of the account thumbnail
   */
  thumb?: string | undefined;
  /**
   * The title of the account (username or friendly name)
   */
  title: string;
  /**
   * If two-factor authentication is enabled
   */
  twoFactorEnabled?: boolean | undefined;
  /**
   * The account username
   */
  username: string;
  /**
   * The account UUID
   */
  uuid: string;
  attributionPartner?: string | null | undefined;
  pastSubscriptions: Array<PastSubscription>;
  trials: Array<Trial>;
};

/** @internal */
export type PostUsersSignInDataRequestBody$Outbound = {
  login: string;
  password: string;
  rememberMe: boolean;
  verificationCode?: string | undefined;
};

/** @internal */
export const PostUsersSignInDataRequestBody$outboundSchema: z.ZodType<
  PostUsersSignInDataRequestBody$Outbound,
  PostUsersSignInDataRequestBody
> = z.object({
  login: z.string(),
  password: z.string(),
  rememberMe: z.boolean().default(false),
  verificationCode: z.string().optional(),
});

export function postUsersSignInDataRequestBodyToJSON(
  postUsersSignInDataRequestBody: PostUsersSignInDataRequestBody,
): string {
  return JSON.stringify(
    PostUsersSignInDataRequestBody$outboundSchema.parse(
      postUsersSignInDataRequestBody,
    ),
  );
}

/** @internal */
export type PostUsersSignInDataRequest$Outbound = {
  accepts: string;
  "Client-Identifier"?: string | undefined;
  Product?: string | undefined;
  Version?: string | undefined;
  Platform?: string | undefined;
  "Platform-Version"?: string | undefined;
  Device?: string | undefined;
  Model?: string | undefined;
  "Device-Vendor"?: string | undefined;
  "Device-Name"?: string | undefined;
  Marketplace?: string | undefined;
  RequestBody?: PostUsersSignInDataRequestBody$Outbound | undefined;
};

/** @internal */
export const PostUsersSignInDataRequest$outboundSchema: z.ZodType<
  PostUsersSignInDataRequest$Outbound,
  PostUsersSignInDataRequest
> = z.object({
  accepts: shared.Accepts$outboundSchema.default(shared.Accepts.ApplicationXml),
  clientIdentifier: z.string().optional(),
  product: z.string().optional(),
  version: z.string().optional(),
  platform: z.string().optional(),
  platformVersion: z.string().optional(),
  device: z.string().optional(),
  model: z.string().optional(),
  deviceVendor: z.string().optional(),
  deviceName: z.string().optional(),
  marketplace: z.string().optional(),
  requestBody: z.lazy(() => PostUsersSignInDataRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    clientIdentifier: "Client-Identifier",
    product: "Product",
    version: "Version",
    platform: "Platform",
    platformVersion: "Platform-Version",
    device: "Device",
    model: "Model",
    deviceVendor: "Device-Vendor",
    deviceName: "Device-Name",
    marketplace: "Marketplace",
    requestBody: "RequestBody",
  });
});

export function postUsersSignInDataRequestToJSON(
  postUsersSignInDataRequest: PostUsersSignInDataRequest,
): string {
  return JSON.stringify(
    PostUsersSignInDataRequest$outboundSchema.parse(postUsersSignInDataRequest),
  );
}

/** @internal */
export const PostUsersSignInDataUnauthorizedError$inboundSchema: z.ZodType<
  PostUsersSignInDataUnauthorizedError,
  unknown
> = z.object({
  code: types.optional(types.number()),
  message: types.optional(types.string()),
  status: types.optional(types.number()),
});

export function postUsersSignInDataUnauthorizedErrorFromJSON(
  jsonString: string,
): SafeParseResult<PostUsersSignInDataUnauthorizedError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PostUsersSignInDataUnauthorizedError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostUsersSignInDataUnauthorizedError' from JSON`,
  );
}

/** @internal */
export const PostUsersSignInDataBadRequestError$inboundSchema: z.ZodType<
  PostUsersSignInDataBadRequestError,
  unknown
> = z.object({
  code: types.optional(types.number()),
  message: types.optional(types.string()),
  status: types.optional(types.number()),
});

export function postUsersSignInDataBadRequestErrorFromJSON(
  jsonString: string,
): SafeParseResult<PostUsersSignInDataBadRequestError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PostUsersSignInDataBadRequestError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostUsersSignInDataBadRequestError' from JSON`,
  );
}

/** @internal */
export const MailingListStatus$inboundSchema: z.ZodType<
  MailingListStatusOpen,
  unknown
> = openEnums.inboundSchema(MailingListStatus);

/** @internal */
export const ServiceStatus$inboundSchema: z.ZodType<
  ServiceStatusOpen,
  unknown
> = openEnums.inboundSchema(ServiceStatus);

/** @internal */
export const Service$inboundSchema: z.ZodType<Service, unknown> = z.object({
  identifier: types.string(),
  endpoint: types.string(),
  token: types.nullable(types.string()),
  secret: types.nullable(types.string()),
  status: ServiceStatus$inboundSchema,
});

export function serviceFromJSON(
  jsonString: string,
): SafeParseResult<Service, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Service$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Service' from JSON`,
  );
}

/** @internal */
export const SubscriptionStatus1$inboundSchema: z.ZodType<
  SubscriptionStatus1Open,
  unknown
> = openEnums.inboundSchema(SubscriptionStatus1);

/** @internal */
export const Subscription1$inboundSchema: z.ZodType<Subscription1, unknown> = z
  .object({
    features: types.optional(z.array(types.string())),
    active: types.optional(types.boolean()),
    subscribedAt: z.nullable(types.string()).optional(),
    status: types.optional(SubscriptionStatus1$inboundSchema),
    paymentService: z.nullable(types.string()).optional(),
    plan: z.nullable(types.string()).optional(),
  });

export function subscription1FromJSON(
  jsonString: string,
): SafeParseResult<Subscription1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Subscription1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Subscription1' from JSON`,
  );
}

/** @internal */
export const SubscriptionStatus2$inboundSchema: z.ZodType<
  SubscriptionStatus2Open,
  unknown
> = openEnums.inboundSchema(SubscriptionStatus2);

/** @internal */
export const Subscription2$inboundSchema: z.ZodType<Subscription2, unknown> = z
  .object({
    features: types.optional(z.array(types.string())),
    active: types.optional(types.boolean()),
    subscribedAt: z.nullable(types.string()).optional(),
    status: types.optional(SubscriptionStatus2$inboundSchema),
    paymentService: z.nullable(types.string()).optional(),
    plan: z.nullable(types.string()).optional(),
  });

export function subscription2FromJSON(
  jsonString: string,
): SafeParseResult<Subscription2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Subscription2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Subscription2' from JSON`,
  );
}

/** @internal */
export const PostUsersSignInDataState$inboundSchema: z.ZodType<
  PostUsersSignInDataStateOpen,
  unknown
> = openEnums.inboundSchema(PostUsersSignInDataState);

/** @internal */
export const InternalPaymentMethod$inboundSchema: z.ZodType<
  InternalPaymentMethod,
  unknown
> = z.object({});

export function internalPaymentMethodFromJSON(
  jsonString: string,
): SafeParseResult<InternalPaymentMethod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InternalPaymentMethod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InternalPaymentMethod' from JSON`,
  );
}

/** @internal */
export const Billing$inboundSchema: z.ZodType<Billing, unknown> = z.object({
  internalPaymentMethod: z.lazy(() => InternalPaymentMethod$inboundSchema),
  paymentMethodId: types.nullable(types.number()),
});

export function billingFromJSON(
  jsonString: string,
): SafeParseResult<Billing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Billing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Billing' from JSON`,
  );
}

/** @internal */
export const PastSubscription$inboundSchema: z.ZodType<
  PastSubscription,
  unknown
> = z.object({
  id: types.nullable(types.string()),
  mode: types.nullable(types.string()),
  renewsAt: types.nullable(types.number()),
  endsAt: types.nullable(types.number()),
  canceled: types.boolean().default(false),
  gracePeriod: types.boolean().default(false),
  onHold: types.boolean().default(false),
  canReactivate: types.boolean().default(false),
  canUpgrade: types.boolean().default(false),
  canDowngrade: types.boolean().default(false),
  canConvert: types.boolean().default(false),
  type: types.string(),
  transfer: types.nullable(types.string()),
  state: PostUsersSignInDataState$inboundSchema,
  billing: z.lazy(() => Billing$inboundSchema),
});

export function pastSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<PastSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PastSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PastSubscription' from JSON`,
  );
}

/** @internal */
export const Trial$inboundSchema: z.ZodType<Trial, unknown> = z.object({});

export function trialFromJSON(
  jsonString: string,
): SafeParseResult<Trial, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Trial$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Trial' from JSON`,
  );
}

/** @internal */
export const UserPlexAccount$inboundSchema: z.ZodType<
  UserPlexAccount,
  unknown
> = z.object({
  adsConsent: z.nullable(types.boolean()).optional(),
  adsConsentReminderAt: z.nullable(types.number()).optional(),
  adsConsentSetAt: z.nullable(types.number()).optional(),
  anonymous: z.nullable(types.boolean().default(false)),
  authToken: types.string(),
  backupCodesCreated: types.boolean().default(false),
  confirmed: types.boolean().default(false),
  country: types.optional(types.string()),
  email: types.string(),
  emailOnlyAuth: types.boolean().default(false),
  experimentalFeatures: types.boolean().default(false),
  friendlyName: types.string(),
  entitlements: types.optional(z.array(types.string())),
  guest: types.boolean().default(false),
  hasPassword: types.boolean().default(true),
  home: types.boolean().default(false),
  homeAdmin: types.boolean().default(false),
  homeSize: types.optional(types.number()),
  id: types.number(),
  joinedAt: types.number(),
  locale: z.nullable(types.string()).optional(),
  mailingListActive: types.boolean().default(false),
  mailingListStatus: types.optional(MailingListStatus$inboundSchema),
  maxHomeSize: types.optional(types.number()),
  pin: types.optional(types.string()),
  profile: types.optional(shared.UserProfile$inboundSchema),
  protected: types.boolean().default(false),
  rememberExpiresAt: types.optional(types.number()),
  restricted: types.boolean().default(false),
  roles: types.optional(z.array(types.string())),
  scrobbleTypes: types.optional(types.string()),
  services: types.optional(z.array(z.lazy(() => Service$inboundSchema))),
  subscription: types.optional(z.lazy(() => Subscription1$inboundSchema)),
  subscriptionDescription: z.nullable(types.string()).optional(),
  subscriptions: types.optional(
    z.array(z.lazy(() => Subscription2$inboundSchema)),
  ),
  thumb: types.optional(types.string()),
  title: types.string(),
  twoFactorEnabled: types.boolean().default(false),
  username: types.string(),
  uuid: types.string(),
  attributionPartner: z.nullable(types.string()).optional(),
  pastSubscriptions: z.array(z.lazy(() => PastSubscription$inboundSchema)),
  trials: z.array(z.lazy(() => Trial$inboundSchema)),
});

export function userPlexAccountFromJSON(
  jsonString: string,
): SafeParseResult<UserPlexAccount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserPlexAccount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserPlexAccount' from JSON`,
  );
}
