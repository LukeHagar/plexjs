/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as z from "zod";

/**
 * Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
 */
export enum Tonight {
    Zero = 0,
    One = 1,
}

/**
 * Indicate that the latest version should be marked as skipped. The <Release> entry for this version will have the `state` set to `skipped`.
 */
export enum Skip {
    Zero = 0,
    One = 1,
}

export type ApplyUpdatesRequest = {
    /**
     * Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
     */
    tonight?: Tonight | undefined;
    /**
     * Indicate that the latest version should be marked as skipped. The <Release> entry for this version will have the `state` set to `skipped`.
     */
    skip?: Skip | undefined;
};

export type ApplyUpdatesResponse = {
    /**
     * HTTP response content type for this operation
     */
    contentType: string;
    /**
     * HTTP response status code for this operation
     */
    statusCode: number;
    /**
     * Raw HTTP response; suitable for custom response parsing
     */
    rawResponse: Response;
};

/** @internal */
export namespace Tonight$ {
    export const inboundSchema = z.nativeEnum(Tonight);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Skip$ {
    export const inboundSchema = z.nativeEnum(Skip);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace ApplyUpdatesRequest$ {
    export const inboundSchema: z.ZodType<ApplyUpdatesRequest, z.ZodTypeDef, unknown> = z
        .object({
            tonight: Tonight$.inboundSchema.optional(),
            skip: Skip$.inboundSchema.optional(),
        })
        .transform((v) => {
            return {
                ...(v.tonight === undefined ? null : { tonight: v.tonight }),
                ...(v.skip === undefined ? null : { skip: v.skip }),
            };
        });

    export type Outbound = {
        tonight?: number | undefined;
        skip?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ApplyUpdatesRequest> = z
        .object({
            tonight: Tonight$.outboundSchema.optional(),
            skip: Skip$.outboundSchema.optional(),
        })
        .transform((v) => {
            return {
                ...(v.tonight === undefined ? null : { tonight: v.tonight }),
                ...(v.skip === undefined ? null : { skip: v.skip }),
            };
        });
}

/** @internal */
export namespace ApplyUpdatesResponse$ {
    export const inboundSchema: z.ZodType<ApplyUpdatesResponse, z.ZodTypeDef, unknown> = z
        .object({
            ContentType: z.string(),
            StatusCode: z.number().int(),
            RawResponse: z.instanceof(Response),
        })
        .transform((v) => {
            return {
                contentType: v.ContentType,
                statusCode: v.StatusCode,
                rawResponse: v.RawResponse,
            };
        });

    export type Outbound = {
        ContentType: string;
        StatusCode: number;
        RawResponse: never;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ApplyUpdatesResponse> = z
        .object({
            contentType: z.string(),
            statusCode: z.number().int(),
            rawResponse: z.instanceof(Response).transform(() => {
                throw new Error("Response cannot be serialized");
            }),
        })
        .transform((v) => {
            return {
                ContentType: v.contentType,
                StatusCode: v.statusCode,
                RawResponse: v.rawResponse,
            };
        });
}
