/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as shared from "../shared/index.js";

export const GetUsersServerList = [
  "https://plex.tv/api",
] as const;

export type GetUsersGlobals = {
  /**
   * Indicates the client accepts the indicated media types
   */
  accepts?: shared.Accepts | undefined;
  /**
   * An opaque identifier unique to the client
   */
  clientIdentifier?: string | undefined;
  /**
   * The name of the client product
   */
  product?: string | undefined;
  /**
   * The version of the client application
   */
  version?: string | undefined;
  /**
   * The platform of the client
   */
  platform?: string | undefined;
  /**
   * The version of the platform
   */
  platformVersion?: string | undefined;
  /**
   * A relatively friendly name for the client device
   */
  device?: string | undefined;
  /**
   * A potentially less friendly identifier for the device model
   */
  model?: string | undefined;
  /**
   * The device vendor
   */
  deviceVendor?: string | undefined;
  /**
   * A friendly name for the client
   */
  deviceName?: string | undefined;
  /**
   * The marketplace on which the client application is distributed
   */
  marketplace?: string | undefined;
};

export type GetUsersRequest = {
  /**
   * Indicates the client accepts the indicated media types
   */
  accepts?: shared.Accepts | undefined;
  /**
   * An opaque identifier unique to the client
   */
  clientIdentifier?: string | undefined;
  /**
   * The name of the client product
   */
  product?: string | undefined;
  /**
   * The version of the client application
   */
  version?: string | undefined;
  /**
   * The platform of the client
   */
  platform?: string | undefined;
  /**
   * The version of the platform
   */
  platformVersion?: string | undefined;
  /**
   * A relatively friendly name for the client device
   */
  device?: string | undefined;
  /**
   * A potentially less friendly identifier for the device model
   */
  model?: string | undefined;
  /**
   * The device vendor
   */
  deviceVendor?: string | undefined;
  /**
   * A friendly name for the client
   */
  deviceName?: string | undefined;
  /**
   * The marketplace on which the client application is distributed
   */
  marketplace?: string | undefined;
};

export type GetUsersUnauthorizedError = {
  code?: number | undefined;
  message?: string | undefined;
  status?: number | undefined;
};

export type GetUsersBadRequestError = {
  code?: number | undefined;
  message?: string | undefined;
  status?: number | undefined;
};

/**
 * Indicates whether the account is protected.
 */
export enum Protected {
  Disable = 0,
  Enable = 1,
}
/**
 * Indicates whether the account is protected.
 */
export type ProtectedOpen = OpenEnum<typeof Protected>;

/**
 * Indicates if the user is part of a home group.
 */
export enum Home {
  Disable = 0,
  Enable = 1,
}
/**
 * Indicates if the user is part of a home group.
 */
export type HomeOpen = OpenEnum<typeof Home>;

/**
 * Indicates if the user is allowed to use tuners.
 */
export enum AllowTuners {
  Disable = 0,
  Enable = 1,
}
/**
 * Indicates if the user is allowed to use tuners.
 */
export type AllowTunersOpen = OpenEnum<typeof AllowTuners>;

/**
 * Indicates if the user is allowed to sync media.
 */
export enum AllowSync {
  Disable = 0,
  Enable = 1,
}
/**
 * Indicates if the user is allowed to sync media.
 */
export type AllowSyncOpen = OpenEnum<typeof AllowSync>;

/**
 * Indicates if the user is allowed to upload from a camera.
 */
export enum AllowCameraUpload {
  Disable = 0,
  Enable = 1,
}
/**
 * Indicates if the user is allowed to upload from a camera.
 */
export type AllowCameraUploadOpen = OpenEnum<typeof AllowCameraUpload>;

/**
 * Indicates if the user has access to channels.
 */
export enum AllowChannels {
  Disable = 0,
  Enable = 1,
}
/**
 * Indicates if the user has access to channels.
 */
export type AllowChannelsOpen = OpenEnum<typeof AllowChannels>;

/**
 * Indicates if the user can manage subtitles.
 */
export enum AllowSubtitleAdmin {
  Disable = 0,
  Enable = 1,
}
/**
 * Indicates if the user can manage subtitles.
 */
export type AllowSubtitleAdminOpen = OpenEnum<typeof AllowSubtitleAdmin>;

/**
 * Indicates if the user has restricted access.
 */
export enum Restricted {
  Disable = 0,
  Enable = 1,
}
/**
 * Indicates if the user has restricted access.
 */
export type RestrictedOpen = OpenEnum<typeof Restricted>;

/**
 * Indicates if the user has access to all libraries.
 */
export enum AllLibraries {
  Disable = 0,
  Enable = 1,
}
/**
 * Indicates if the user has access to all libraries.
 */
export type AllLibrariesOpen = OpenEnum<typeof AllLibraries>;

/**
 * Indicates if the user owns the server.
 */
export enum Owned {
  Disable = 0,
  Enable = 1,
}
/**
 * Indicates if the user owns the server.
 */
export type OwnedOpen = OpenEnum<typeof Owned>;

/**
 * Indicates if the server is pending approval.
 */
export enum Pending {
  Disable = 0,
  Enable = 1,
}
/**
 * Indicates if the server is pending approval.
 */
export type PendingOpen = OpenEnum<typeof Pending>;

export type Server = {
  /**
   * Unique ID of the server of the connected user
   */
  id: number;
  /**
   * ID of the actual Plex server.
   */
  serverId: number;
  /**
   * Machine identifier of the Plex server.
   */
  machineIdentifier: string;
  /**
   * Name of the Plex server of the connected user.
   */
  name: string;
  /**
   * Unix epoch datetime in seconds
   */
  lastSeenAt: number;
  /**
   * Number of libraries in the server this user has access to.
   */
  numLibraries: number;
  allLibraries?: AllLibrariesOpen | undefined;
  owned?: OwnedOpen | undefined;
  pending?: PendingOpen | undefined;
};

export type User = {
  /**
   * User's unique ID.
   */
  id: number;
  /**
   * User's display name.
   */
  title: string;
  /**
   * User's username.
   */
  username: string;
  /**
   * User's email address.
   */
  email: string;
  /**
   * ID of the user's recommendation playlist.
   */
  recommendationsPlaylistId?: string | null | undefined;
  /**
   * URL to the user's avatar image.
   */
  thumb: string;
  protected?: ProtectedOpen | undefined;
  home?: HomeOpen | undefined;
  allowTuners?: AllowTunersOpen | undefined;
  allowSync?: AllowSyncOpen | undefined;
  allowCameraUpload?: AllowCameraUploadOpen | undefined;
  allowChannels?: AllowChannelsOpen | undefined;
  allowSubtitleAdmin?: AllowSubtitleAdminOpen | undefined;
  /**
   * Filters applied for all content.
   */
  filterAll?: string | null | undefined;
  /**
   * Filters applied for movies.
   */
  filterMovies?: string | null | undefined;
  /**
   * Filters applied for music.
   */
  filterMusic?: string | null | undefined;
  /**
   * Filters applied for photos.
   */
  filterPhotos?: string | null | undefined;
  /**
   * Filters applied for television.
   */
  filterTelevision?: string | undefined;
  restricted?: RestrictedOpen | undefined;
  /**
   * List of servers owned by the user.
   */
  server: Array<Server>;
};

/**
 * Container holding user and server details.
 */
export type GetUsersMediaContainer = {
  /**
   * The friendly name of the Plex instance.
   */
  friendlyName: string;
  identifier: string;
  /**
   * Unique Machine identifier of the Plex server.
   */
  machineIdentifier: string;
  /**
   * Total number of users.
   */
  totalSize: number;
  /**
   * Number of users in the current response.
   */
  size: number;
  /**
   * List of users with access to the Plex server.
   */
  user: Array<User>;
};

/**
 * Successful response with media container data in JSON
 */
export type GetUsersResponse = {
  /**
   * Container holding user and server details.
   */
  mediaContainer?: GetUsersMediaContainer | undefined;
};

/** @internal */
export type GetUsersRequest$Outbound = {
  accepts: string;
  "Client-Identifier"?: string | undefined;
  Product?: string | undefined;
  Version?: string | undefined;
  Platform?: string | undefined;
  "Platform-Version"?: string | undefined;
  Device?: string | undefined;
  Model?: string | undefined;
  "Device-Vendor"?: string | undefined;
  "Device-Name"?: string | undefined;
  Marketplace?: string | undefined;
};

/** @internal */
export const GetUsersRequest$outboundSchema: z.ZodType<
  GetUsersRequest$Outbound,
  GetUsersRequest
> = z.object({
  accepts: shared.Accepts$outboundSchema.default(shared.Accepts.ApplicationXml),
  clientIdentifier: z.string().optional(),
  product: z.string().optional(),
  version: z.string().optional(),
  platform: z.string().optional(),
  platformVersion: z.string().optional(),
  device: z.string().optional(),
  model: z.string().optional(),
  deviceVendor: z.string().optional(),
  deviceName: z.string().optional(),
  marketplace: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    clientIdentifier: "Client-Identifier",
    product: "Product",
    version: "Version",
    platform: "Platform",
    platformVersion: "Platform-Version",
    device: "Device",
    model: "Model",
    deviceVendor: "Device-Vendor",
    deviceName: "Device-Name",
    marketplace: "Marketplace",
  });
});

export function getUsersRequestToJSON(
  getUsersRequest: GetUsersRequest,
): string {
  return JSON.stringify(GetUsersRequest$outboundSchema.parse(getUsersRequest));
}

/** @internal */
export const GetUsersUnauthorizedError$inboundSchema: z.ZodType<
  GetUsersUnauthorizedError,
  unknown
> = z.object({
  code: types.optional(types.number()),
  message: types.optional(types.string()),
  status: types.optional(types.number()),
});

export function getUsersUnauthorizedErrorFromJSON(
  jsonString: string,
): SafeParseResult<GetUsersUnauthorizedError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUsersUnauthorizedError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUsersUnauthorizedError' from JSON`,
  );
}

/** @internal */
export const GetUsersBadRequestError$inboundSchema: z.ZodType<
  GetUsersBadRequestError,
  unknown
> = z.object({
  code: types.optional(types.number()),
  message: types.optional(types.string()),
  status: types.optional(types.number()),
});

export function getUsersBadRequestErrorFromJSON(
  jsonString: string,
): SafeParseResult<GetUsersBadRequestError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUsersBadRequestError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUsersBadRequestError' from JSON`,
  );
}

/** @internal */
export const Protected$inboundSchema: z.ZodType<ProtectedOpen, unknown> =
  openEnums.inboundSchemaInt(Protected);

/** @internal */
export const Home$inboundSchema: z.ZodType<HomeOpen, unknown> = openEnums
  .inboundSchemaInt(Home);

/** @internal */
export const AllowTuners$inboundSchema: z.ZodType<AllowTunersOpen, unknown> =
  openEnums.inboundSchemaInt(AllowTuners);

/** @internal */
export const AllowSync$inboundSchema: z.ZodType<AllowSyncOpen, unknown> =
  openEnums.inboundSchemaInt(AllowSync);

/** @internal */
export const AllowCameraUpload$inboundSchema: z.ZodType<
  AllowCameraUploadOpen,
  unknown
> = openEnums.inboundSchemaInt(AllowCameraUpload);

/** @internal */
export const AllowChannels$inboundSchema: z.ZodType<
  AllowChannelsOpen,
  unknown
> = openEnums.inboundSchemaInt(AllowChannels);

/** @internal */
export const AllowSubtitleAdmin$inboundSchema: z.ZodType<
  AllowSubtitleAdminOpen,
  unknown
> = openEnums.inboundSchemaInt(AllowSubtitleAdmin);

/** @internal */
export const Restricted$inboundSchema: z.ZodType<RestrictedOpen, unknown> =
  openEnums.inboundSchemaInt(Restricted);

/** @internal */
export const AllLibraries$inboundSchema: z.ZodType<AllLibrariesOpen, unknown> =
  openEnums.inboundSchemaInt(AllLibraries);

/** @internal */
export const Owned$inboundSchema: z.ZodType<OwnedOpen, unknown> = openEnums
  .inboundSchemaInt(Owned);

/** @internal */
export const Pending$inboundSchema: z.ZodType<PendingOpen, unknown> = openEnums
  .inboundSchemaInt(Pending);

/** @internal */
export const Server$inboundSchema: z.ZodType<Server, unknown> = z.object({
  id: types.number(),
  serverId: types.number(),
  machineIdentifier: types.string(),
  name: types.string(),
  lastSeenAt: types.number(),
  numLibraries: types.number(),
  allLibraries: AllLibraries$inboundSchema.default(AllLibraries.Disable),
  owned: Owned$inboundSchema.default(Owned.Disable),
  pending: Pending$inboundSchema.default(Pending.Disable),
});

export function serverFromJSON(
  jsonString: string,
): SafeParseResult<Server, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Server$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Server' from JSON`,
  );
}

/** @internal */
export const User$inboundSchema: z.ZodType<User, unknown> = z.object({
  id: types.number(),
  title: types.string(),
  username: types.string(),
  email: types.string(),
  recommendationsPlaylistId: z.nullable(types.string()).optional(),
  thumb: types.string(),
  protected: Protected$inboundSchema.default(Protected.Disable),
  home: Home$inboundSchema.default(Home.Disable),
  allowTuners: AllowTuners$inboundSchema.default(AllowTuners.Disable),
  allowSync: AllowSync$inboundSchema.default(AllowSync.Disable),
  allowCameraUpload: AllowCameraUpload$inboundSchema.default(
    AllowCameraUpload.Disable,
  ),
  allowChannels: AllowChannels$inboundSchema.default(AllowChannels.Disable),
  allowSubtitleAdmin: AllowSubtitleAdmin$inboundSchema.default(
    AllowSubtitleAdmin.Disable,
  ),
  filterAll: z.nullable(types.string()).optional(),
  filterMovies: z.nullable(types.string()).optional(),
  filterMusic: z.nullable(types.string()).optional(),
  filterPhotos: z.nullable(types.string()).optional(),
  filterTelevision: types.optional(types.string()),
  restricted: Restricted$inboundSchema.default(Restricted.Disable),
  Server: z.array(z.lazy(() => Server$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "Server": "server",
  });
});

export function userFromJSON(
  jsonString: string,
): SafeParseResult<User, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => User$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'User' from JSON`,
  );
}

/** @internal */
export const GetUsersMediaContainer$inboundSchema: z.ZodType<
  GetUsersMediaContainer,
  unknown
> = z.object({
  friendlyName: types.string(),
  identifier: types.string(),
  machineIdentifier: types.string(),
  totalSize: types.number(),
  size: types.number(),
  User: z.array(z.lazy(() => User$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "User": "user",
  });
});

export function getUsersMediaContainerFromJSON(
  jsonString: string,
): SafeParseResult<GetUsersMediaContainer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUsersMediaContainer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUsersMediaContainer' from JSON`,
  );
}

/** @internal */
export const GetUsersResponse$inboundSchema: z.ZodType<
  GetUsersResponse,
  unknown
> = z.object({
  MediaContainer: types.optional(
    z.lazy(() => GetUsersMediaContainer$inboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    "MediaContainer": "mediaContainer",
  });
});

export function getUsersResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetUsersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUsersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUsersResponse' from JSON`,
  );
}
