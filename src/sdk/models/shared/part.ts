/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Stream,
  Stream$inboundSchema,
  Stream$Outbound,
  Stream$outboundSchema,
} from "./stream.js";

/**
 * `Part` represents a particular file or "part" of a media item. The part is the playable unit of the media hierarchy. Suppose that a movie library contains a movie that is broken up into files, reminiscent of a movie split across two BDs. The metadata item represents information about the movie, the media item represents this instance of the movie at this resolution and quality, and the part items represent the two playable files.  If another media were added which contained the joining of these two parts transcoded down to a lower resolution, then this metadata would contain 2 medias, one with 2 parts and one with 1 part.
 *
 * @remarks
 */
export type Part = {
  audioProfile?: any | undefined;
  /**
   * The container of the media file, such as `mp4` or `mkv`
   */
  container?: any | undefined;
  /**
   * The duration of the media item, in milliseconds
   */
  duration?: number | undefined;
  /**
   * The local file path at which the part is stored on the server
   */
  file?: any | undefined;
  has64bitOffsets?: boolean | undefined;
  id?: number | undefined;
  /**
   * The key from which the media can be streamed
   */
  key?: any | undefined;
  optimizedForStreaming?: boolean | undefined;
  /**
   * The size of the media, in bytes
   */
  size?: number | undefined;
  stream?: Array<Stream> | undefined;
  videoProfile?: any | undefined;
  additionalProperties?: { [k: string]: any };
};

/** @internal */
export const Part$inboundSchema: z.ZodType<Part, z.ZodTypeDef, unknown> =
  collectExtraKeys$(
    z.object({
      audioProfile: z.any().optional(),
      container: z.any().optional(),
      duration: z.number().int().optional(),
      file: z.any().optional(),
      has64bitOffsets: z.boolean().optional(),
      id: z.number().int().optional(),
      key: z.any().optional(),
      optimizedForStreaming: z.boolean().optional(),
      size: z.number().int().optional(),
      Stream: z.array(Stream$inboundSchema).optional(),
      videoProfile: z.any().optional(),
    }).catchall(z.any()),
    "additionalProperties",
    true,
  ).transform((v) => {
    return remap$(v, {
      "Stream": "stream",
    });
  });

/** @internal */
export type Part$Outbound = {
  audioProfile?: any | undefined;
  container?: any | undefined;
  duration?: number | undefined;
  file?: any | undefined;
  has64bitOffsets?: boolean | undefined;
  id?: number | undefined;
  key?: any | undefined;
  optimizedForStreaming?: boolean | undefined;
  size?: number | undefined;
  Stream?: Array<Stream$Outbound> | undefined;
  videoProfile?: any | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const Part$outboundSchema: z.ZodType<Part$Outbound, z.ZodTypeDef, Part> =
  z.object({
    audioProfile: z.any().optional(),
    container: z.any().optional(),
    duration: z.number().int().optional(),
    file: z.any().optional(),
    has64bitOffsets: z.boolean().optional(),
    id: z.number().int().optional(),
    key: z.any().optional(),
    optimizedForStreaming: z.boolean().optional(),
    size: z.number().int().optional(),
    stream: z.array(Stream$outboundSchema).optional(),
    videoProfile: z.any().optional(),
    additionalProperties: z.record(z.any()),
  }).transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        stream: "Stream",
        additionalProperties: null,
      }),
    };
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Part$ {
  /** @deprecated use `Part$inboundSchema` instead. */
  export const inboundSchema = Part$inboundSchema;
  /** @deprecated use `Part$outboundSchema` instead. */
  export const outboundSchema = Part$outboundSchema;
  /** @deprecated use `Part$Outbound` instead. */
  export type Outbound = Part$Outbound;
}

export function partToJSON(part: Part): string {
  return JSON.stringify(Part$outboundSchema.parse(part));
}

export function partFromJSON(
  jsonString: string,
): SafeParseResult<Part, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Part$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Part' from JSON`,
  );
}
