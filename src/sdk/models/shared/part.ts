/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { Stream, Stream$inboundSchema } from "./stream.js";

/**
 * `Part` represents a particular file or "part" of a media item. The part is the playable unit of the media hierarchy. Suppose that a movie library contains a movie that is broken up into files, reminiscent of a movie split across two BDs. The metadata item represents information about the movie, the media item represents this instance of the movie at this resolution and quality, and the part items represent the two playable files.  If another media were added which contained the joining of these two parts transcoded down to a lower resolution, then this metadata would contain 2 medias, one with 2 parts and one with 1 part.
 *
 * @remarks
 */
export type Part = {
  /**
   * Indicates if the part is accessible.
   */
  accessible?: boolean | undefined;
  audioProfile?: string | undefined;
  /**
   * The container of the media file, such as `mp4` or `mkv`
   */
  container?: string | undefined;
  /**
   * The duration of the media item, in milliseconds
   */
  duration?: number | undefined;
  /**
   * Indicates if the part exists.
   */
  exists?: boolean | undefined;
  /**
   * The local file path at which the part is stored on the server
   */
  file?: string | undefined;
  has64bitOffsets?: boolean | undefined;
  id: number;
  indexes?: string | undefined;
  /**
   * The key from which the media can be streamed
   */
  key: string;
  optimizedForStreaming?: boolean | undefined;
  /**
   * The size of the media, in bytes
   */
  size?: number | undefined;
  stream?: Array<Stream> | undefined;
  videoProfile?: string | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

/** @internal */
export const Part$inboundSchema: z.ZodType<Part, z.ZodTypeDef, unknown> =
  collectExtraKeys$(
    z.object({
      accessible: z.boolean().optional(),
      audioProfile: z.string().optional(),
      container: z.string().optional(),
      duration: z.number().int().optional(),
      exists: z.boolean().optional(),
      file: z.string().optional(),
      has64bitOffsets: z.boolean().optional(),
      id: z.number().int(),
      indexes: z.string().optional(),
      key: z.string(),
      optimizedForStreaming: z.boolean().optional(),
      size: z.number().int().optional(),
      Stream: z.array(Stream$inboundSchema).optional(),
      videoProfile: z.string().optional(),
    }).catchall(z.any()),
    "additionalProperties",
    true,
  ).transform((v) => {
    return remap$(v, {
      "Stream": "stream",
    });
  });

export function partFromJSON(
  jsonString: string,
): SafeParseResult<Part, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Part$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Part' from JSON`,
  );
}
