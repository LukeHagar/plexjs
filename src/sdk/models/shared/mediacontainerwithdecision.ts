/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Filter,
  Filter$inboundSchema,
  Filter$Outbound,
  Filter$outboundSchema,
} from "./filter.js";
import {
  Image,
  Image$inboundSchema,
  Image$Outbound,
  Image$outboundSchema,
} from "./image.js";
import {
  Sort,
  Sort$inboundSchema,
  Sort$Outbound,
  Sort$outboundSchema,
} from "./sort.js";
import {
  Tag,
  Tag$inboundSchema,
  Tag$Outbound,
  Tag$outboundSchema,
} from "./tag.js";

export enum StreamDecision {
  Copy = "copy",
  Transcode = "transcode",
  Burn = "burn",
  Unavailable = "unavailable",
  Ignore = "ignore",
  None = "none",
}

export enum MediaContainerWithDecisionLocation {
  Direct = "direct",
  SidecarSubs = "sidecar-subs",
  SegmentsVideo = "segments-video",
  SegmentsAudio = "segments-audio",
  SegmentsAv = "segments-av",
  SegmentsSubs = "segments-subs",
  Embedded = "embedded",
  Sidecar = "sidecar",
}

/**
 * `Stream` represents a particular stream from a media item, such as the video stream, audio stream, or subtitle stream. The stream may either be part of the file represented by the parent `Part` or, especially for subtitles, an external file. The stream contains more detailed information about the specific stream. For example, a video may include the `aspectRatio` at the `Media` level, but detailed information about the video stream like the color space will be included on the `Stream` for the video stream.  Note that photos do not have streams (mostly as an optimization).
 *
 * @remarks
 */
export type MediaContainerWithDecisionStream = {
  default?: boolean | undefined;
  audioChannelLayout?: any | undefined;
  bitDepth?: number | undefined;
  bitrate?: number | undefined;
  /**
   * For subtitle streams only. If `true` then the server can attempt to automatically sync the subtitle timestamps with the video.
   */
  canAutoSync?: boolean | undefined;
  chromaLocation?: any | undefined;
  chromaSubsampling?: any | undefined;
  /**
   * The codec of the stream, such as `h264` or `aac`
   */
  codec?: any | undefined;
  colorPrimaries?: any | undefined;
  colorRange?: any | undefined;
  colorSpace?: any | undefined;
  colorTrc?: any | undefined;
  /**
   * A friendly name for the stream, often comprised of the language and codec information
   */
  displayTitle?: any | undefined;
  frameRate?: number | undefined;
  hasScalingMatrix?: any | undefined;
  height?: number | undefined;
  id?: number | undefined;
  /**
   * If the stream is part of the `Part` and not an external resource, the index of the stream within that part
   */
  index?: number | undefined;
  /**
   * If the stream is independently streamable, the key from which it can be streamed
   */
  key?: any | undefined;
  language?: any | undefined;
  /**
   * The three character language code for the stream contents
   */
  languageCode?: any | undefined;
  level?: number | undefined;
  profile?: any | undefined;
  refFrames?: number | undefined;
  samplingRate?: number | undefined;
  selected?: boolean | undefined;
  streamIdentifier?: number | undefined;
  /**
   * A number indicating the type of the stream. `1` for video, `2` for audio, `3` for subtitles, `4` for lyrics
   */
  streamType?: number | undefined;
  width?: number | undefined;
  decision?: StreamDecision | undefined;
  location?: MediaContainerWithDecisionLocation | undefined;
  additionalProperties?: { [k: string]: any };
};

export enum Decision {
  Directplay = "directplay",
  Transcode = "transcode",
  None = "none",
}

/**
 * `Part` represents a particular file or "part" of a media item. The part is the playable unit of the media hierarchy. Suppose that a movie library contains a movie that is broken up into files, reminiscent of a movie split across two BDs. The metadata item represents information about the movie, the media item represents this instance of the movie at this resolution and quality, and the part items represent the two playable files.  If another media were added which contained the joining of these two parts transcoded down to a lower resolution, then this metadata would contain 2 medias, one with 2 parts and one with 1 part.
 *
 * @remarks
 */
export type MediaContainerWithDecisionPart = {
  audioProfile?: any | undefined;
  /**
   * The container of the media file, such as `mp4` or `mkv`
   */
  container?: any | undefined;
  /**
   * The duration of the media item, in milliseconds
   */
  duration?: number | undefined;
  /**
   * The local file path at which the part is stored on the server
   */
  file?: any | undefined;
  has64bitOffsets?: boolean | undefined;
  id?: number | undefined;
  /**
   * The key from which the media can be streamed
   */
  key?: any | undefined;
  optimizedForStreaming?: boolean | undefined;
  /**
   * The size of the media, in bytes
   */
  size?: number | undefined;
  stream?: Array<MediaContainerWithDecisionStream> | undefined;
  videoProfile?: any | undefined;
  decision?: Decision | undefined;
  selected?: boolean | undefined;
  additionalProperties?: { [k: string]: any };
};

/**
 * `Media` represents an one or more media files (parts) and is a child of a metadata item. There aren't necessarily any guaranteed attributes on media elements since the attributes will vary based on the type. The possible attributes are not documented here, but they typically have self-evident names. High-level media information that can be used for badging and flagging, such as `videoResolution` and codecs, is included on the media element.
 *
 * @remarks
 */
export type MediaContainerWithDecisionMedia = {
  aspectRatio?: number | undefined;
  audioChannels?: number | undefined;
  audioCodec?: any | undefined;
  audioProfile?: any | undefined;
  bitrate?: number | undefined;
  container?: any | undefined;
  duration?: number | undefined;
  has64bitOffsets?: boolean | undefined;
  hasVoiceActivity?: boolean | undefined;
  height?: number | undefined;
  id?: number | undefined;
  optimizedForStreaming?: boolean | undefined;
  part?: Array<MediaContainerWithDecisionPart> | undefined;
  videoCodec?: any | undefined;
  videoFrameRate?: any | undefined;
  videoProfile?: any | undefined;
  videoResolution?: any | undefined;
  width?: number | undefined;
  abr?: boolean | undefined;
  resourceSession?: string | undefined;
  selected?: boolean | undefined;
  additionalProperties?: { [k: string]: any };
};

/**
 * Items in a library are referred to as "metadata items." These metadata items are distinct from "media items" which represent actual instances of media that can be consumed. Consider a TV library that has a single video file in it for a particular episode of a show. The library has a single media item, but it has three metadata items: one for the show, one for the season, and one for the episode. Consider a movie library that has two video files in it: the same movie, but two different resolutions. The library has a single metadata item for the movie, but that metadata item has two media items, one for each resolution. Additionally a "media item" will have one or more "media parts" where the the parts are intended to be watched together, such as a CD1 and CD2 parts of the same movie.
 *
 * @remarks
 *
 * Note that when a metadata item has multiple media items, those media items should be isomorphic. That is, a 4K version and 1080p version of a movie are different versions of the same movie. They have the same duration, same summary, same rating, etc. and they can generally be considered interchangeable. A theatrical release vs. director's cut vs. unrated version on the other hand would be separate metadata items.
 *
 * Metadata items can often live in a hierarchy with relationships between them.  For example, the metadata item for an episodes is associated with a season metadata item which is associated with a show metadata item.  A similar hierarchy exists with track, album, and artist and photos and photo album.  The relationships may be expressed via relative terms and absolute terms.  For example, "leaves" refer to metadata items which has associated media (there is no media for a season nor show).  A show will have "children" in the form of seasons and a season will have "children" in the form of episodes and episodes have "parent" in the form of a season which has a "parent" in the form of a show.  Similarly, a show has "grandchildren" in the form of episodse and an episode has a "grandparent" in the form of a show.
 */
export type MediaContainerWithDecisionMetadatum = {
  /**
   * The title of the item (e.g. “300” or “The Simpsons”)
   */
  title?: any | undefined;
  /**
   * The type of the video item, such as `movie`, `episode`, or `clip`.
   */
  type?: any | undefined;
  /**
   * When present, contains the disc number for a track on multi-disc albums.
   */
  absoluteIndex?: number | undefined;
  /**
   * In units of seconds since the epoch, returns the time at which the item was added to the library.
   */
  addedAt?: number | undefined;
  /**
   * When present, the URL for the background artwork for the item.
   */
  art?: any | undefined;
  /**
   * Some rating systems separate reviewer ratings from audience ratings
   */
  audienceRating?: number | undefined;
  /**
   * A URI representing the image to be shown with the audience rating (e.g. rottentomatoes://image.rating.spilled).
   */
  audienceRatingImage?: any | undefined;
  autotag?: Array<Tag> | undefined;
  /**
   * When present, the URL for a banner graphic for the item.
   */
  banner?: any | undefined;
  /**
   * When present, indicates the source for the chapters in the media file. Can be media (the chapters were embedded in the media itself), agent (a metadata agent computed them), or mixed (a combination of the two).
   */
  chapterSource?: any | undefined;
  /**
   * When present, the URL for a composite image for descendent items (e.g. photo albums or playlists).
   */
  composite?: any | undefined;
  /**
   * If known, the content rating (e.g. MPAA) for an item.
   */
  contentRating?: any | undefined;
  country?: Array<Tag> | undefined;
  director?: Array<Tag> | undefined;
  /**
   * When present, the duration for the item, in units of milliseconds.
   */
  duration?: number | undefined;
  /**
   * Typically only seen in metadata at a library's top level
   */
  filter?: Array<Filter> | undefined;
  genre?: Array<Tag> | undefined;
  /**
   * The `art` of the grandparent
   */
  grandparentArt?: string | undefined;
  /**
   * The `hero` of the grandparent
   */
  grandparentHero?: string | undefined;
  /**
   * The `key` of the grandparent
   */
  grandparentKey?: string | undefined;
  /**
   * The `ratingKey` of the grandparent
   */
  grandparentRatingKey?: string | undefined;
  /**
   * The `theme` of the grandparent
   */
  grandparentTheme?: string | undefined;
  /**
   * The `thumb` of the grandparent
   */
  grandparentThumb?: string | undefined;
  /**
   * The `title` of the grandparent
   */
  grandparentTitle?: string | undefined;
  guid?: Array<Tag> | undefined;
  /**
   * When present, the URL for a hero image for the item.
   */
  hero?: any | undefined;
  image?: Array<Image> | undefined;
  /**
   * When present, this represents the episode number for episodes, season number for seasons, or track number for audio tracks.
   */
  index?: number | undefined;
  /**
   * The key at which the item's details can be fetched.  In many cases a metadata item may be passed without all the details (such as in a hub) and this key corresponds to the endpoint to fetch additional details.
   */
  key?: any | undefined;
  /**
   * When a user has watched or listened to an item, this contains a timestamp (epoch seconds) for that last consumption time.
   */
  lastViewedAt?: number | undefined;
  /**
   * For shows and seasons, contains the number of total episodes.
   */
  leafCount?: number | undefined;
  media?: Array<MediaContainerWithDecisionMedia> | undefined;
  /**
   * When present, in the format YYYY-MM-DD [HH:MM:SS] (the hours/minutes/seconds part is not always present). The air date, or a higher resolution release date for an item, depending on type. For example, episodes usually have air date like 1979-08-10 (we don't use epoch seconds because media existed prior to 1970). In some cases, recorded over-the-air content has higher resolution air date which includes a time component. Albums and movies may have day-resolution release dates as well.
   */
  originallyAvailableAt?: any | undefined;
  /**
   * When present, used to indicate an item's original title, e.g. a movie's foreign title.
   */
  originalTitle?: any | undefined;
  /**
   * The `hero` of the parent
   */
  parentHero?: string | undefined;
  /**
   * The `index` of the parent
   */
  parentIndex?: number | undefined;
  /**
   * The `key` of the parent
   */
  parentKey?: string | undefined;
  /**
   * The `ratingKey` of the parent
   */
  parentRatingKey?: string | undefined;
  /**
   * The `thumb` of the parent
   */
  parentThumb?: string | undefined;
  /**
   * The `title` of the parent
   */
  parentTitle?: string | undefined;
  /**
   * Indicates that the item has a primary extra; for a movie, this is a trailer, and for a music track it is a music video. The URL points to the metadata details endpoint for the item.
   */
  primaryExtraKey?: any | undefined;
  /**
   * Prompt to give the user for this directory (such as `Search Movies`)
   */
  prompt?: string | undefined;
  /**
   * When present, the rating for the item. The exact meaning and representation depends on where the rating was sourced from.
   */
  rating?: number | undefined;
  ratingArray?: Array<Tag> | undefined;
  /**
   * Number of ratings under this metadata
   */
  ratingCount?: number | undefined;
  /**
   * When present, indicates an image to be shown with the rating. This is passed back as a small set of defined URI values, e.g. rottentomatoes://image.rating.rotten.
   */
  ratingImage?: any | undefined;
  /**
   * This is the opaque string to be passed into timeline, scrobble, and rating endpoints to identify them.  While it often appears to be numeric, this is not guaranteed.
   */
  ratingKey?: any | undefined;
  role?: Array<Tag> | undefined;
  /**
   * Indicates this is a search directory
   */
  search?: boolean | undefined;
  /**
   * Used by old clients to provide nested menus allowing for primative (but structured) navigation.
   */
  secondary?: boolean | undefined;
  /**
   * When found on a show item, indicates that the children (seasons) should be skipped in favor of the grandchildren (episodes). Useful for mini-series, etc.
   */
  skipChildren?: boolean | undefined;
  /**
   * When present on an episode or track item, indicates parent should be skipped in favor of grandparent (show).
   */
  skipParent?: boolean | undefined;
  /**
   * Typically only seen in metadata at a library's top level
   */
  sort?: Array<Sort> | undefined;
  /**
   * When present, the studio or label which produced an item (e.g. movie studio for movies, record label for albums).
   */
  studio?: any | undefined;
  /**
   * The subtype of the video item, such as `photo` when the video item is in a photo library
   */
  subtype?: any | undefined;
  /**
   * When present, the extended textual information about the item (e.g. movie plot, artist biography, album review).
   */
  summary?: any | undefined;
  /**
   * When present, a pithy one-liner about the item (usually only seen for movies).
   */
  tagline?: any | undefined;
  /**
   * When present, the URL for theme music for the item (usually only for TV shows).
   */
  theme?: any | undefined;
  /**
   * When present, the URL for the poster or thumbnail for the item. When available for types like movie, it will be the poster graphic, but fall-back to the extracted media thumbnail.
   */
  thumb?: any | undefined;
  /**
   * Whene present, this is the string used for sorting the item. It's usually the title with any leading articles removed (e.g. “Simpsons”).
   */
  titleSort?: any | undefined;
  /**
   * In units of seconds since the epoch, returns the time at which the item was last changed (e.g. had its metadata updated).
   */
  updatedAt?: number | undefined;
  /**
   * When the user has rated an item, this contains the user rating
   */
  userRating?: number | undefined;
  /**
   * When a users has completed watched or listened to an item, this attribute contains the number of consumptions.
   */
  viewCount?: number | undefined;
  /**
   * For shows and seasons, contains the number of viewed episodes.
   */
  viewedLeafCount?: number | undefined;
  /**
   * When a user is in the process of viewing or listening to this item, this attribute contains the current offset, in units of milliseconds.
   */
  viewOffset?: number | undefined;
  writer?: Array<Tag> | undefined;
  /**
   * When present, the year associated with the item's release (e.g. release year for a movie).
   */
  year?: number | undefined;
  additionalProperties?: { [k: string]: any };
};

/**
 * `MediaContainer` is the root element of most Plex API responses. It serves as a generic container for various types of content (Metadata, Hubs, Directories, etc.) and includes pagination information (offset, size, totalSize) when applicable.
 *
 * @remarks
 * Common attributes: - identifier: Unique identifier for this container - size: Number of items in this response page - totalSize: Total number of items available (for pagination) - offset: Starting index of this page (for pagination)
 * The container often "hoists" common attributes from its children. For example, if all tracks in a container share the same album title, the `parentTitle` attribute may appear on the MediaContainer rather than being repeated on each track.
 */
export type MediaContainerWithDecisionMediaContainer = {
  identifier?: string | undefined;
  /**
   * The offset of where this container page starts among the total objects available. Also provided in the `X-Plex-Container-Start` header.
   *
   * @remarks
   */
  offset?: number | undefined;
  size?: number | undefined;
  /**
   * The total size of objects available. Also provided in the `X-Plex-Container-Total-Size` header.
   *
   * @remarks
   */
  totalSize?: number | undefined;
  /**
   * The maximum available bitrate when the decision was rendered.
   */
  availableBandwidth?: number | undefined;
  directPlayDecisionCode?: number | undefined;
  directPlayDecisionText?: string | undefined;
  /**
   * The overall decision. 1xxx are playback can succeed, 2xxx are a general error (such as insufficient bandwidth), 3xxx are errors in direct play, and 4xxx are errors in transcodes. Same codes are used in all.
   */
  generalDecisionCode?: number | undefined;
  generalDecisionText?: string | undefined;
  /**
   * The code indicating the status of evaluation of playback when client indicates `hasMDE=1`
   */
  mdeDecisionCode?: number | undefined;
  /**
   * Descriptive text for the above code
   */
  mdeDecisionText?: string | undefined;
  metadata?: Array<MediaContainerWithDecisionMetadatum> | undefined;
  transcodeDecisionCode?: number | undefined;
  transcodeDecisionText?: string | undefined;
};

/**
 * `MediaContainer` is commonly found as the root of a response and is a pretty generic container. Common attributes include `identifier` and things related to paging (`offset`, `size`, `totalSize`).
 *
 * @remarks
 *
 * It is also common for a `MediaContainer` to contain attributes "hoisted" from its children. If every element in the container would have had the same attribute, then that attribute can be present on the container instead of being repeated on every element. For example, an album's list of tracks might include `parentTitle` on the container since all of the tracks have the same album title. A container may have a `source` attribute when all of the items came from the same source. Generally speaking, when looking for an attribute on an item, if the attribute wasn't found then the container should be checked for that attribute as well.
 */
export type MediaContainerWithDecision = {
  mediaContainer?: MediaContainerWithDecisionMediaContainer | undefined;
};

/** @internal */
export const StreamDecision$inboundSchema: z.ZodNativeEnum<
  typeof StreamDecision
> = z.nativeEnum(StreamDecision);

/** @internal */
export const StreamDecision$outboundSchema: z.ZodNativeEnum<
  typeof StreamDecision
> = StreamDecision$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamDecision$ {
  /** @deprecated use `StreamDecision$inboundSchema` instead. */
  export const inboundSchema = StreamDecision$inboundSchema;
  /** @deprecated use `StreamDecision$outboundSchema` instead. */
  export const outboundSchema = StreamDecision$outboundSchema;
}

/** @internal */
export const MediaContainerWithDecisionLocation$inboundSchema: z.ZodNativeEnum<
  typeof MediaContainerWithDecisionLocation
> = z.nativeEnum(MediaContainerWithDecisionLocation);

/** @internal */
export const MediaContainerWithDecisionLocation$outboundSchema: z.ZodNativeEnum<
  typeof MediaContainerWithDecisionLocation
> = MediaContainerWithDecisionLocation$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaContainerWithDecisionLocation$ {
  /** @deprecated use `MediaContainerWithDecisionLocation$inboundSchema` instead. */
  export const inboundSchema = MediaContainerWithDecisionLocation$inboundSchema;
  /** @deprecated use `MediaContainerWithDecisionLocation$outboundSchema` instead. */
  export const outboundSchema =
    MediaContainerWithDecisionLocation$outboundSchema;
}

/** @internal */
export const MediaContainerWithDecisionStream$inboundSchema: z.ZodType<
  MediaContainerWithDecisionStream,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    default: z.boolean().optional(),
    audioChannelLayout: z.any().optional(),
    bitDepth: z.number().int().optional(),
    bitrate: z.number().int().optional(),
    canAutoSync: z.boolean().optional(),
    chromaLocation: z.any().optional(),
    chromaSubsampling: z.any().optional(),
    codec: z.any().optional(),
    colorPrimaries: z.any().optional(),
    colorRange: z.any().optional(),
    colorSpace: z.any().optional(),
    colorTrc: z.any().optional(),
    displayTitle: z.any().optional(),
    frameRate: z.number().optional(),
    hasScalingMatrix: z.any().optional(),
    height: z.number().int().optional(),
    id: z.number().int().optional(),
    index: z.number().int().optional(),
    key: z.any().optional(),
    language: z.any().optional(),
    languageCode: z.any().optional(),
    level: z.number().int().optional(),
    profile: z.any().optional(),
    refFrames: z.number().int().optional(),
    samplingRate: z.number().int().optional(),
    selected: z.boolean().optional(),
    streamIdentifier: z.number().int().optional(),
    streamType: z.number().int().optional(),
    width: z.number().int().optional(),
    decision: StreamDecision$inboundSchema.optional(),
    location: MediaContainerWithDecisionLocation$inboundSchema.optional(),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

/** @internal */
export type MediaContainerWithDecisionStream$Outbound = {
  default?: boolean | undefined;
  audioChannelLayout?: any | undefined;
  bitDepth?: number | undefined;
  bitrate?: number | undefined;
  canAutoSync?: boolean | undefined;
  chromaLocation?: any | undefined;
  chromaSubsampling?: any | undefined;
  codec?: any | undefined;
  colorPrimaries?: any | undefined;
  colorRange?: any | undefined;
  colorSpace?: any | undefined;
  colorTrc?: any | undefined;
  displayTitle?: any | undefined;
  frameRate?: number | undefined;
  hasScalingMatrix?: any | undefined;
  height?: number | undefined;
  id?: number | undefined;
  index?: number | undefined;
  key?: any | undefined;
  language?: any | undefined;
  languageCode?: any | undefined;
  level?: number | undefined;
  profile?: any | undefined;
  refFrames?: number | undefined;
  samplingRate?: number | undefined;
  selected?: boolean | undefined;
  streamIdentifier?: number | undefined;
  streamType?: number | undefined;
  width?: number | undefined;
  decision?: string | undefined;
  location?: string | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const MediaContainerWithDecisionStream$outboundSchema: z.ZodType<
  MediaContainerWithDecisionStream$Outbound,
  z.ZodTypeDef,
  MediaContainerWithDecisionStream
> = z.object({
  default: z.boolean().optional(),
  audioChannelLayout: z.any().optional(),
  bitDepth: z.number().int().optional(),
  bitrate: z.number().int().optional(),
  canAutoSync: z.boolean().optional(),
  chromaLocation: z.any().optional(),
  chromaSubsampling: z.any().optional(),
  codec: z.any().optional(),
  colorPrimaries: z.any().optional(),
  colorRange: z.any().optional(),
  colorSpace: z.any().optional(),
  colorTrc: z.any().optional(),
  displayTitle: z.any().optional(),
  frameRate: z.number().optional(),
  hasScalingMatrix: z.any().optional(),
  height: z.number().int().optional(),
  id: z.number().int().optional(),
  index: z.number().int().optional(),
  key: z.any().optional(),
  language: z.any().optional(),
  languageCode: z.any().optional(),
  level: z.number().int().optional(),
  profile: z.any().optional(),
  refFrames: z.number().int().optional(),
  samplingRate: z.number().int().optional(),
  selected: z.boolean().optional(),
  streamIdentifier: z.number().int().optional(),
  streamType: z.number().int().optional(),
  width: z.number().int().optional(),
  decision: StreamDecision$outboundSchema.optional(),
  location: MediaContainerWithDecisionLocation$outboundSchema.optional(),
  additionalProperties: z.record(z.any()),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaContainerWithDecisionStream$ {
  /** @deprecated use `MediaContainerWithDecisionStream$inboundSchema` instead. */
  export const inboundSchema = MediaContainerWithDecisionStream$inboundSchema;
  /** @deprecated use `MediaContainerWithDecisionStream$outboundSchema` instead. */
  export const outboundSchema = MediaContainerWithDecisionStream$outboundSchema;
  /** @deprecated use `MediaContainerWithDecisionStream$Outbound` instead. */
  export type Outbound = MediaContainerWithDecisionStream$Outbound;
}

export function mediaContainerWithDecisionStreamToJSON(
  mediaContainerWithDecisionStream: MediaContainerWithDecisionStream,
): string {
  return JSON.stringify(
    MediaContainerWithDecisionStream$outboundSchema.parse(
      mediaContainerWithDecisionStream,
    ),
  );
}

export function mediaContainerWithDecisionStreamFromJSON(
  jsonString: string,
): SafeParseResult<MediaContainerWithDecisionStream, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MediaContainerWithDecisionStream$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MediaContainerWithDecisionStream' from JSON`,
  );
}

/** @internal */
export const Decision$inboundSchema: z.ZodNativeEnum<typeof Decision> = z
  .nativeEnum(Decision);

/** @internal */
export const Decision$outboundSchema: z.ZodNativeEnum<typeof Decision> =
  Decision$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Decision$ {
  /** @deprecated use `Decision$inboundSchema` instead. */
  export const inboundSchema = Decision$inboundSchema;
  /** @deprecated use `Decision$outboundSchema` instead. */
  export const outboundSchema = Decision$outboundSchema;
}

/** @internal */
export const MediaContainerWithDecisionPart$inboundSchema: z.ZodType<
  MediaContainerWithDecisionPart,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    audioProfile: z.any().optional(),
    container: z.any().optional(),
    duration: z.number().int().optional(),
    file: z.any().optional(),
    has64bitOffsets: z.boolean().optional(),
    id: z.number().int().optional(),
    key: z.any().optional(),
    optimizedForStreaming: z.boolean().optional(),
    size: z.number().int().optional(),
    Stream: z.array(
      z.lazy(() => MediaContainerWithDecisionStream$inboundSchema),
    ).optional(),
    videoProfile: z.any().optional(),
    decision: Decision$inboundSchema.optional(),
    selected: z.boolean().optional(),
  }).catchall(z.any()),
  "additionalProperties",
  true,
).transform((v) => {
  return remap$(v, {
    "Stream": "stream",
  });
});

/** @internal */
export type MediaContainerWithDecisionPart$Outbound = {
  audioProfile?: any | undefined;
  container?: any | undefined;
  duration?: number | undefined;
  file?: any | undefined;
  has64bitOffsets?: boolean | undefined;
  id?: number | undefined;
  key?: any | undefined;
  optimizedForStreaming?: boolean | undefined;
  size?: number | undefined;
  Stream?: Array<MediaContainerWithDecisionStream$Outbound> | undefined;
  videoProfile?: any | undefined;
  decision?: string | undefined;
  selected?: boolean | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const MediaContainerWithDecisionPart$outboundSchema: z.ZodType<
  MediaContainerWithDecisionPart$Outbound,
  z.ZodTypeDef,
  MediaContainerWithDecisionPart
> = z.object({
  audioProfile: z.any().optional(),
  container: z.any().optional(),
  duration: z.number().int().optional(),
  file: z.any().optional(),
  has64bitOffsets: z.boolean().optional(),
  id: z.number().int().optional(),
  key: z.any().optional(),
  optimizedForStreaming: z.boolean().optional(),
  size: z.number().int().optional(),
  stream: z.array(z.lazy(() => MediaContainerWithDecisionStream$outboundSchema))
    .optional(),
  videoProfile: z.any().optional(),
  decision: Decision$outboundSchema.optional(),
  selected: z.boolean().optional(),
  additionalProperties: z.record(z.any()),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      stream: "Stream",
      additionalProperties: null,
    }),
  };
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaContainerWithDecisionPart$ {
  /** @deprecated use `MediaContainerWithDecisionPart$inboundSchema` instead. */
  export const inboundSchema = MediaContainerWithDecisionPart$inboundSchema;
  /** @deprecated use `MediaContainerWithDecisionPart$outboundSchema` instead. */
  export const outboundSchema = MediaContainerWithDecisionPart$outboundSchema;
  /** @deprecated use `MediaContainerWithDecisionPart$Outbound` instead. */
  export type Outbound = MediaContainerWithDecisionPart$Outbound;
}

export function mediaContainerWithDecisionPartToJSON(
  mediaContainerWithDecisionPart: MediaContainerWithDecisionPart,
): string {
  return JSON.stringify(
    MediaContainerWithDecisionPart$outboundSchema.parse(
      mediaContainerWithDecisionPart,
    ),
  );
}

export function mediaContainerWithDecisionPartFromJSON(
  jsonString: string,
): SafeParseResult<MediaContainerWithDecisionPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MediaContainerWithDecisionPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MediaContainerWithDecisionPart' from JSON`,
  );
}

/** @internal */
export const MediaContainerWithDecisionMedia$inboundSchema: z.ZodType<
  MediaContainerWithDecisionMedia,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    aspectRatio: z.number().optional(),
    audioChannels: z.number().int().optional(),
    audioCodec: z.any().optional(),
    audioProfile: z.any().optional(),
    bitrate: z.number().int().optional(),
    container: z.any().optional(),
    duration: z.number().int().optional(),
    has64bitOffsets: z.boolean().optional(),
    hasVoiceActivity: z.boolean().optional(),
    height: z.number().int().optional(),
    id: z.number().int().optional(),
    optimizedForStreaming: z.boolean().optional(),
    Part: z.array(z.lazy(() => MediaContainerWithDecisionPart$inboundSchema))
      .optional(),
    videoCodec: z.any().optional(),
    videoFrameRate: z.any().optional(),
    videoProfile: z.any().optional(),
    videoResolution: z.any().optional(),
    width: z.number().int().optional(),
    abr: z.boolean().optional(),
    resourceSession: z.string().optional(),
    selected: z.boolean().optional(),
  }).catchall(z.any()),
  "additionalProperties",
  true,
).transform((v) => {
  return remap$(v, {
    "Part": "part",
  });
});

/** @internal */
export type MediaContainerWithDecisionMedia$Outbound = {
  aspectRatio?: number | undefined;
  audioChannels?: number | undefined;
  audioCodec?: any | undefined;
  audioProfile?: any | undefined;
  bitrate?: number | undefined;
  container?: any | undefined;
  duration?: number | undefined;
  has64bitOffsets?: boolean | undefined;
  hasVoiceActivity?: boolean | undefined;
  height?: number | undefined;
  id?: number | undefined;
  optimizedForStreaming?: boolean | undefined;
  Part?: Array<MediaContainerWithDecisionPart$Outbound> | undefined;
  videoCodec?: any | undefined;
  videoFrameRate?: any | undefined;
  videoProfile?: any | undefined;
  videoResolution?: any | undefined;
  width?: number | undefined;
  abr?: boolean | undefined;
  resourceSession?: string | undefined;
  selected?: boolean | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const MediaContainerWithDecisionMedia$outboundSchema: z.ZodType<
  MediaContainerWithDecisionMedia$Outbound,
  z.ZodTypeDef,
  MediaContainerWithDecisionMedia
> = z.object({
  aspectRatio: z.number().optional(),
  audioChannels: z.number().int().optional(),
  audioCodec: z.any().optional(),
  audioProfile: z.any().optional(),
  bitrate: z.number().int().optional(),
  container: z.any().optional(),
  duration: z.number().int().optional(),
  has64bitOffsets: z.boolean().optional(),
  hasVoiceActivity: z.boolean().optional(),
  height: z.number().int().optional(),
  id: z.number().int().optional(),
  optimizedForStreaming: z.boolean().optional(),
  part: z.array(z.lazy(() => MediaContainerWithDecisionPart$outboundSchema))
    .optional(),
  videoCodec: z.any().optional(),
  videoFrameRate: z.any().optional(),
  videoProfile: z.any().optional(),
  videoResolution: z.any().optional(),
  width: z.number().int().optional(),
  abr: z.boolean().optional(),
  resourceSession: z.string().optional(),
  selected: z.boolean().optional(),
  additionalProperties: z.record(z.any()),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      part: "Part",
      additionalProperties: null,
    }),
  };
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaContainerWithDecisionMedia$ {
  /** @deprecated use `MediaContainerWithDecisionMedia$inboundSchema` instead. */
  export const inboundSchema = MediaContainerWithDecisionMedia$inboundSchema;
  /** @deprecated use `MediaContainerWithDecisionMedia$outboundSchema` instead. */
  export const outboundSchema = MediaContainerWithDecisionMedia$outboundSchema;
  /** @deprecated use `MediaContainerWithDecisionMedia$Outbound` instead. */
  export type Outbound = MediaContainerWithDecisionMedia$Outbound;
}

export function mediaContainerWithDecisionMediaToJSON(
  mediaContainerWithDecisionMedia: MediaContainerWithDecisionMedia,
): string {
  return JSON.stringify(
    MediaContainerWithDecisionMedia$outboundSchema.parse(
      mediaContainerWithDecisionMedia,
    ),
  );
}

export function mediaContainerWithDecisionMediaFromJSON(
  jsonString: string,
): SafeParseResult<MediaContainerWithDecisionMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MediaContainerWithDecisionMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MediaContainerWithDecisionMedia' from JSON`,
  );
}

/** @internal */
export const MediaContainerWithDecisionMetadatum$inboundSchema: z.ZodType<
  MediaContainerWithDecisionMetadatum,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    title: z.any().optional(),
    type: z.any().optional(),
    absoluteIndex: z.number().int().optional(),
    addedAt: z.number().int().optional(),
    art: z.any().optional(),
    audienceRating: z.number().optional(),
    audienceRatingImage: z.any().optional(),
    Autotag: z.array(Tag$inboundSchema).optional(),
    banner: z.any().optional(),
    chapterSource: z.any().optional(),
    composite: z.any().optional(),
    contentRating: z.any().optional(),
    Country: z.array(Tag$inboundSchema).optional(),
    Director: z.array(Tag$inboundSchema).optional(),
    duration: z.number().int().optional(),
    Filter: z.array(Filter$inboundSchema).optional(),
    Genre: z.array(Tag$inboundSchema).optional(),
    grandparentArt: z.string().optional(),
    grandparentHero: z.string().optional(),
    grandparentKey: z.string().optional(),
    grandparentRatingKey: z.string().optional(),
    grandparentTheme: z.string().optional(),
    grandparentThumb: z.string().optional(),
    grandparentTitle: z.string().optional(),
    Guid: z.array(Tag$inboundSchema).optional(),
    hero: z.any().optional(),
    Image: z.array(Image$inboundSchema).optional(),
    index: z.number().int().optional(),
    key: z.any().optional(),
    lastViewedAt: z.number().int().optional(),
    leafCount: z.number().int().optional(),
    Media: z.array(z.lazy(() => MediaContainerWithDecisionMedia$inboundSchema))
      .optional(),
    originallyAvailableAt: z.any().optional(),
    originalTitle: z.any().optional(),
    parentHero: z.string().optional(),
    parentIndex: z.number().int().optional(),
    parentKey: z.string().optional(),
    parentRatingKey: z.string().optional(),
    parentThumb: z.string().optional(),
    parentTitle: z.string().optional(),
    primaryExtraKey: z.any().optional(),
    prompt: z.string().optional(),
    rating: z.number().optional(),
    Rating: z.array(Tag$inboundSchema).optional(),
    ratingCount: z.number().int().optional(),
    ratingImage: z.any().optional(),
    ratingKey: z.any().optional(),
    Role: z.array(Tag$inboundSchema).optional(),
    search: z.boolean().optional(),
    secondary: z.boolean().optional(),
    skipChildren: z.boolean().optional(),
    skipParent: z.boolean().optional(),
    Sort: z.array(Sort$inboundSchema).optional(),
    studio: z.any().optional(),
    subtype: z.any().optional(),
    summary: z.any().optional(),
    tagline: z.any().optional(),
    theme: z.any().optional(),
    thumb: z.any().optional(),
    titleSort: z.any().optional(),
    updatedAt: z.number().int().optional(),
    userRating: z.number().optional(),
    viewCount: z.number().int().optional(),
    viewedLeafCount: z.number().int().optional(),
    viewOffset: z.number().int().optional(),
    Writer: z.array(Tag$inboundSchema).optional(),
    year: z.number().int().optional(),
  }).catchall(z.any()),
  "additionalProperties",
  true,
).transform((v) => {
  return remap$(v, {
    "Autotag": "autotag",
    "Country": "country",
    "Director": "director",
    "Filter": "filter",
    "Genre": "genre",
    "Guid": "guid",
    "Image": "image",
    "Media": "media",
    "Rating": "ratingArray",
    "Role": "role",
    "Sort": "sort",
    "Writer": "writer",
  });
});

/** @internal */
export type MediaContainerWithDecisionMetadatum$Outbound = {
  title?: any | undefined;
  type?: any | undefined;
  absoluteIndex?: number | undefined;
  addedAt?: number | undefined;
  art?: any | undefined;
  audienceRating?: number | undefined;
  audienceRatingImage?: any | undefined;
  Autotag?: Array<Tag$Outbound> | undefined;
  banner?: any | undefined;
  chapterSource?: any | undefined;
  composite?: any | undefined;
  contentRating?: any | undefined;
  Country?: Array<Tag$Outbound> | undefined;
  Director?: Array<Tag$Outbound> | undefined;
  duration?: number | undefined;
  Filter?: Array<Filter$Outbound> | undefined;
  Genre?: Array<Tag$Outbound> | undefined;
  grandparentArt?: string | undefined;
  grandparentHero?: string | undefined;
  grandparentKey?: string | undefined;
  grandparentRatingKey?: string | undefined;
  grandparentTheme?: string | undefined;
  grandparentThumb?: string | undefined;
  grandparentTitle?: string | undefined;
  Guid?: Array<Tag$Outbound> | undefined;
  hero?: any | undefined;
  Image?: Array<Image$Outbound> | undefined;
  index?: number | undefined;
  key?: any | undefined;
  lastViewedAt?: number | undefined;
  leafCount?: number | undefined;
  Media?: Array<MediaContainerWithDecisionMedia$Outbound> | undefined;
  originallyAvailableAt?: any | undefined;
  originalTitle?: any | undefined;
  parentHero?: string | undefined;
  parentIndex?: number | undefined;
  parentKey?: string | undefined;
  parentRatingKey?: string | undefined;
  parentThumb?: string | undefined;
  parentTitle?: string | undefined;
  primaryExtraKey?: any | undefined;
  prompt?: string | undefined;
  rating?: number | undefined;
  Rating?: Array<Tag$Outbound> | undefined;
  ratingCount?: number | undefined;
  ratingImage?: any | undefined;
  ratingKey?: any | undefined;
  Role?: Array<Tag$Outbound> | undefined;
  search?: boolean | undefined;
  secondary?: boolean | undefined;
  skipChildren?: boolean | undefined;
  skipParent?: boolean | undefined;
  Sort?: Array<Sort$Outbound> | undefined;
  studio?: any | undefined;
  subtype?: any | undefined;
  summary?: any | undefined;
  tagline?: any | undefined;
  theme?: any | undefined;
  thumb?: any | undefined;
  titleSort?: any | undefined;
  updatedAt?: number | undefined;
  userRating?: number | undefined;
  viewCount?: number | undefined;
  viewedLeafCount?: number | undefined;
  viewOffset?: number | undefined;
  Writer?: Array<Tag$Outbound> | undefined;
  year?: number | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const MediaContainerWithDecisionMetadatum$outboundSchema: z.ZodType<
  MediaContainerWithDecisionMetadatum$Outbound,
  z.ZodTypeDef,
  MediaContainerWithDecisionMetadatum
> = z.object({
  title: z.any().optional(),
  type: z.any().optional(),
  absoluteIndex: z.number().int().optional(),
  addedAt: z.number().int().optional(),
  art: z.any().optional(),
  audienceRating: z.number().optional(),
  audienceRatingImage: z.any().optional(),
  autotag: z.array(Tag$outboundSchema).optional(),
  banner: z.any().optional(),
  chapterSource: z.any().optional(),
  composite: z.any().optional(),
  contentRating: z.any().optional(),
  country: z.array(Tag$outboundSchema).optional(),
  director: z.array(Tag$outboundSchema).optional(),
  duration: z.number().int().optional(),
  filter: z.array(Filter$outboundSchema).optional(),
  genre: z.array(Tag$outboundSchema).optional(),
  grandparentArt: z.string().optional(),
  grandparentHero: z.string().optional(),
  grandparentKey: z.string().optional(),
  grandparentRatingKey: z.string().optional(),
  grandparentTheme: z.string().optional(),
  grandparentThumb: z.string().optional(),
  grandparentTitle: z.string().optional(),
  guid: z.array(Tag$outboundSchema).optional(),
  hero: z.any().optional(),
  image: z.array(Image$outboundSchema).optional(),
  index: z.number().int().optional(),
  key: z.any().optional(),
  lastViewedAt: z.number().int().optional(),
  leafCount: z.number().int().optional(),
  media: z.array(z.lazy(() => MediaContainerWithDecisionMedia$outboundSchema))
    .optional(),
  originallyAvailableAt: z.any().optional(),
  originalTitle: z.any().optional(),
  parentHero: z.string().optional(),
  parentIndex: z.number().int().optional(),
  parentKey: z.string().optional(),
  parentRatingKey: z.string().optional(),
  parentThumb: z.string().optional(),
  parentTitle: z.string().optional(),
  primaryExtraKey: z.any().optional(),
  prompt: z.string().optional(),
  rating: z.number().optional(),
  ratingArray: z.array(Tag$outboundSchema).optional(),
  ratingCount: z.number().int().optional(),
  ratingImage: z.any().optional(),
  ratingKey: z.any().optional(),
  role: z.array(Tag$outboundSchema).optional(),
  search: z.boolean().optional(),
  secondary: z.boolean().optional(),
  skipChildren: z.boolean().optional(),
  skipParent: z.boolean().optional(),
  sort: z.array(Sort$outboundSchema).optional(),
  studio: z.any().optional(),
  subtype: z.any().optional(),
  summary: z.any().optional(),
  tagline: z.any().optional(),
  theme: z.any().optional(),
  thumb: z.any().optional(),
  titleSort: z.any().optional(),
  updatedAt: z.number().int().optional(),
  userRating: z.number().optional(),
  viewCount: z.number().int().optional(),
  viewedLeafCount: z.number().int().optional(),
  viewOffset: z.number().int().optional(),
  writer: z.array(Tag$outboundSchema).optional(),
  year: z.number().int().optional(),
  additionalProperties: z.record(z.any()),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      autotag: "Autotag",
      country: "Country",
      director: "Director",
      filter: "Filter",
      genre: "Genre",
      guid: "Guid",
      image: "Image",
      media: "Media",
      ratingArray: "Rating",
      role: "Role",
      sort: "Sort",
      writer: "Writer",
      additionalProperties: null,
    }),
  };
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaContainerWithDecisionMetadatum$ {
  /** @deprecated use `MediaContainerWithDecisionMetadatum$inboundSchema` instead. */
  export const inboundSchema =
    MediaContainerWithDecisionMetadatum$inboundSchema;
  /** @deprecated use `MediaContainerWithDecisionMetadatum$outboundSchema` instead. */
  export const outboundSchema =
    MediaContainerWithDecisionMetadatum$outboundSchema;
  /** @deprecated use `MediaContainerWithDecisionMetadatum$Outbound` instead. */
  export type Outbound = MediaContainerWithDecisionMetadatum$Outbound;
}

export function mediaContainerWithDecisionMetadatumToJSON(
  mediaContainerWithDecisionMetadatum: MediaContainerWithDecisionMetadatum,
): string {
  return JSON.stringify(
    MediaContainerWithDecisionMetadatum$outboundSchema.parse(
      mediaContainerWithDecisionMetadatum,
    ),
  );
}

export function mediaContainerWithDecisionMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<MediaContainerWithDecisionMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      MediaContainerWithDecisionMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MediaContainerWithDecisionMetadatum' from JSON`,
  );
}

/** @internal */
export const MediaContainerWithDecisionMediaContainer$inboundSchema: z.ZodType<
  MediaContainerWithDecisionMediaContainer,
  z.ZodTypeDef,
  unknown
> = z.object({
  identifier: z.string().optional(),
  offset: z.number().int().optional(),
  size: z.number().int().optional(),
  totalSize: z.number().int().optional(),
  availableBandwidth: z.number().int().optional(),
  directPlayDecisionCode: z.number().int().optional(),
  directPlayDecisionText: z.string().optional(),
  generalDecisionCode: z.number().int().optional(),
  generalDecisionText: z.string().optional(),
  mdeDecisionCode: z.number().int().optional(),
  mdeDecisionText: z.string().optional(),
  Metadata: z.array(
    z.lazy(() => MediaContainerWithDecisionMetadatum$inboundSchema),
  ).optional(),
  transcodeDecisionCode: z.number().int().optional(),
  transcodeDecisionText: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "Metadata": "metadata",
  });
});

/** @internal */
export type MediaContainerWithDecisionMediaContainer$Outbound = {
  identifier?: string | undefined;
  offset?: number | undefined;
  size?: number | undefined;
  totalSize?: number | undefined;
  availableBandwidth?: number | undefined;
  directPlayDecisionCode?: number | undefined;
  directPlayDecisionText?: string | undefined;
  generalDecisionCode?: number | undefined;
  generalDecisionText?: string | undefined;
  mdeDecisionCode?: number | undefined;
  mdeDecisionText?: string | undefined;
  Metadata?: Array<MediaContainerWithDecisionMetadatum$Outbound> | undefined;
  transcodeDecisionCode?: number | undefined;
  transcodeDecisionText?: string | undefined;
};

/** @internal */
export const MediaContainerWithDecisionMediaContainer$outboundSchema: z.ZodType<
  MediaContainerWithDecisionMediaContainer$Outbound,
  z.ZodTypeDef,
  MediaContainerWithDecisionMediaContainer
> = z.object({
  identifier: z.string().optional(),
  offset: z.number().int().optional(),
  size: z.number().int().optional(),
  totalSize: z.number().int().optional(),
  availableBandwidth: z.number().int().optional(),
  directPlayDecisionCode: z.number().int().optional(),
  directPlayDecisionText: z.string().optional(),
  generalDecisionCode: z.number().int().optional(),
  generalDecisionText: z.string().optional(),
  mdeDecisionCode: z.number().int().optional(),
  mdeDecisionText: z.string().optional(),
  metadata: z.array(
    z.lazy(() => MediaContainerWithDecisionMetadatum$outboundSchema),
  ).optional(),
  transcodeDecisionCode: z.number().int().optional(),
  transcodeDecisionText: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    metadata: "Metadata",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaContainerWithDecisionMediaContainer$ {
  /** @deprecated use `MediaContainerWithDecisionMediaContainer$inboundSchema` instead. */
  export const inboundSchema =
    MediaContainerWithDecisionMediaContainer$inboundSchema;
  /** @deprecated use `MediaContainerWithDecisionMediaContainer$outboundSchema` instead. */
  export const outboundSchema =
    MediaContainerWithDecisionMediaContainer$outboundSchema;
  /** @deprecated use `MediaContainerWithDecisionMediaContainer$Outbound` instead. */
  export type Outbound = MediaContainerWithDecisionMediaContainer$Outbound;
}

export function mediaContainerWithDecisionMediaContainerToJSON(
  mediaContainerWithDecisionMediaContainer:
    MediaContainerWithDecisionMediaContainer,
): string {
  return JSON.stringify(
    MediaContainerWithDecisionMediaContainer$outboundSchema.parse(
      mediaContainerWithDecisionMediaContainer,
    ),
  );
}

export function mediaContainerWithDecisionMediaContainerFromJSON(
  jsonString: string,
): SafeParseResult<
  MediaContainerWithDecisionMediaContainer,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      MediaContainerWithDecisionMediaContainer$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'MediaContainerWithDecisionMediaContainer' from JSON`,
  );
}

/** @internal */
export const MediaContainerWithDecision$inboundSchema: z.ZodType<
  MediaContainerWithDecision,
  z.ZodTypeDef,
  unknown
> = z.object({
  MediaContainer: z.lazy(() =>
    MediaContainerWithDecisionMediaContainer$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "MediaContainer": "mediaContainer",
  });
});

/** @internal */
export type MediaContainerWithDecision$Outbound = {
  MediaContainer?:
    | MediaContainerWithDecisionMediaContainer$Outbound
    | undefined;
};

/** @internal */
export const MediaContainerWithDecision$outboundSchema: z.ZodType<
  MediaContainerWithDecision$Outbound,
  z.ZodTypeDef,
  MediaContainerWithDecision
> = z.object({
  mediaContainer: z.lazy(() =>
    MediaContainerWithDecisionMediaContainer$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    mediaContainer: "MediaContainer",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaContainerWithDecision$ {
  /** @deprecated use `MediaContainerWithDecision$inboundSchema` instead. */
  export const inboundSchema = MediaContainerWithDecision$inboundSchema;
  /** @deprecated use `MediaContainerWithDecision$outboundSchema` instead. */
  export const outboundSchema = MediaContainerWithDecision$outboundSchema;
  /** @deprecated use `MediaContainerWithDecision$Outbound` instead. */
  export type Outbound = MediaContainerWithDecision$Outbound;
}

export function mediaContainerWithDecisionToJSON(
  mediaContainerWithDecision: MediaContainerWithDecision,
): string {
  return JSON.stringify(
    MediaContainerWithDecision$outboundSchema.parse(mediaContainerWithDecision),
  );
}

export function mediaContainerWithDecisionFromJSON(
  jsonString: string,
): SafeParseResult<MediaContainerWithDecision, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MediaContainerWithDecision$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MediaContainerWithDecision' from JSON`,
  );
}
