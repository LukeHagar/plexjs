/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Metadata,
  Metadata$inboundSchema,
  Metadata$Outbound,
  Metadata$outboundSchema,
} from "./metadata.js";

export type SlashGetResponses200MediaContainer = {
  /**
   * The flavors of directory found here:
   *
   * @remarks
   *   - Primary: (e.g. all, On Deck) These are still used in some clients to provide "shortcuts" to subsets of media. However, with the exception of On Deck, all of them can be created by media queries, and the desire is to allow these to be customized by users.
   *   - Secondary: These are marked with `"secondary": true` and were used by old clients to provide nested menus allowing for primative (but structured) navigation.
   *   - Special: There is a By Folder entry which allows browsing the media by the underlying filesystem structure, and there's a completely obsolete entry marked `"search": true` which used to be used to allow clients to build search dialogs on the fly.
   */
  content?: string | undefined;
  allowSync?: boolean | undefined;
  art?: string | undefined;
  directory?: Array<Metadata> | undefined;
  identifier?: string | undefined;
  librarySectionID?: number | undefined;
  mediaTagPrefix?: string | undefined;
  mediaTagVersion?: number | undefined;
  size?: number | undefined;
  sortAsc?: boolean | undefined;
  thumb?: string | undefined;
  title1?: string | undefined;
  viewGroup?: string | undefined;
  viewMode?: number | undefined;
};

/**
 * OK
 */
export type SlashGetResponses200 = {
  mediaContainer?: SlashGetResponses200MediaContainer | undefined;
};

/** @internal */
export const SlashGetResponses200MediaContainer$inboundSchema: z.ZodType<
  SlashGetResponses200MediaContainer,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.string().optional(),
  allowSync: z.boolean().optional(),
  art: z.string().optional(),
  Directory: z.array(Metadata$inboundSchema).optional(),
  identifier: z.string().optional(),
  librarySectionID: z.number().int().optional(),
  mediaTagPrefix: z.string().optional(),
  mediaTagVersion: z.number().int().optional(),
  size: z.number().int().optional(),
  sortAsc: z.boolean().optional(),
  thumb: z.string().optional(),
  title1: z.string().optional(),
  viewGroup: z.string().optional(),
  viewMode: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    "Directory": "directory",
  });
});

/** @internal */
export type SlashGetResponses200MediaContainer$Outbound = {
  content?: string | undefined;
  allowSync?: boolean | undefined;
  art?: string | undefined;
  Directory?: Array<Metadata$Outbound> | undefined;
  identifier?: string | undefined;
  librarySectionID?: number | undefined;
  mediaTagPrefix?: string | undefined;
  mediaTagVersion?: number | undefined;
  size?: number | undefined;
  sortAsc?: boolean | undefined;
  thumb?: string | undefined;
  title1?: string | undefined;
  viewGroup?: string | undefined;
  viewMode?: number | undefined;
};

/** @internal */
export const SlashGetResponses200MediaContainer$outboundSchema: z.ZodType<
  SlashGetResponses200MediaContainer$Outbound,
  z.ZodTypeDef,
  SlashGetResponses200MediaContainer
> = z.object({
  content: z.string().optional(),
  allowSync: z.boolean().optional(),
  art: z.string().optional(),
  directory: z.array(Metadata$outboundSchema).optional(),
  identifier: z.string().optional(),
  librarySectionID: z.number().int().optional(),
  mediaTagPrefix: z.string().optional(),
  mediaTagVersion: z.number().int().optional(),
  size: z.number().int().optional(),
  sortAsc: z.boolean().optional(),
  thumb: z.string().optional(),
  title1: z.string().optional(),
  viewGroup: z.string().optional(),
  viewMode: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    directory: "Directory",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SlashGetResponses200MediaContainer$ {
  /** @deprecated use `SlashGetResponses200MediaContainer$inboundSchema` instead. */
  export const inboundSchema = SlashGetResponses200MediaContainer$inboundSchema;
  /** @deprecated use `SlashGetResponses200MediaContainer$outboundSchema` instead. */
  export const outboundSchema =
    SlashGetResponses200MediaContainer$outboundSchema;
  /** @deprecated use `SlashGetResponses200MediaContainer$Outbound` instead. */
  export type Outbound = SlashGetResponses200MediaContainer$Outbound;
}

export function slashGetResponses200MediaContainerToJSON(
  slashGetResponses200MediaContainer: SlashGetResponses200MediaContainer,
): string {
  return JSON.stringify(
    SlashGetResponses200MediaContainer$outboundSchema.parse(
      slashGetResponses200MediaContainer,
    ),
  );
}

export function slashGetResponses200MediaContainerFromJSON(
  jsonString: string,
): SafeParseResult<SlashGetResponses200MediaContainer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      SlashGetResponses200MediaContainer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SlashGetResponses200MediaContainer' from JSON`,
  );
}

/** @internal */
export const SlashGetResponses200$inboundSchema: z.ZodType<
  SlashGetResponses200,
  z.ZodTypeDef,
  unknown
> = z.object({
  MediaContainer: z.lazy(() => SlashGetResponses200MediaContainer$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "MediaContainer": "mediaContainer",
  });
});

/** @internal */
export type SlashGetResponses200$Outbound = {
  MediaContainer?: SlashGetResponses200MediaContainer$Outbound | undefined;
};

/** @internal */
export const SlashGetResponses200$outboundSchema: z.ZodType<
  SlashGetResponses200$Outbound,
  z.ZodTypeDef,
  SlashGetResponses200
> = z.object({
  mediaContainer: z.lazy(() =>
    SlashGetResponses200MediaContainer$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    mediaContainer: "MediaContainer",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SlashGetResponses200$ {
  /** @deprecated use `SlashGetResponses200$inboundSchema` instead. */
  export const inboundSchema = SlashGetResponses200$inboundSchema;
  /** @deprecated use `SlashGetResponses200$outboundSchema` instead. */
  export const outboundSchema = SlashGetResponses200$outboundSchema;
  /** @deprecated use `SlashGetResponses200$Outbound` instead. */
  export type Outbound = SlashGetResponses200$Outbound;
}

export function slashGetResponses200ToJSON(
  slashGetResponses200: SlashGetResponses200,
): string {
  return JSON.stringify(
    SlashGetResponses200$outboundSchema.parse(slashGetResponses200),
  );
}

export function slashGetResponses200FromJSON(
  jsonString: string,
): SafeParseResult<SlashGetResponses200, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SlashGetResponses200$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SlashGetResponses200' from JSON`,
  );
}
