/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The protocol used for the connection (http, https, etc)
 */
export enum PlexDeviceProtocol {
  Http = "http",
  Https = "https",
}

export type Connection = {
  /**
   * The protocol used for the connection (http, https, etc)
   */
  protocol: PlexDeviceProtocol;
  /**
   * The (ip) address or domain name used for the connection
   */
  address: string;
  /**
   * The port used for the connection
   */
  port: number;
  /**
   * The full URI of the connection
   */
  uri: string;
  /**
   * If the connection is local address
   */
  local: boolean;
  /**
   * If the connection is relayed through plex.direct
   */
  relay: boolean;
  /**
   * If the connection is using IPv6
   */
  iPv6: boolean;
};

export type PlexDevice = {
  name: string;
  product: string;
  productVersion: string;
  platform: string | null;
  platformVersion: string | null;
  device: string | null;
  clientIdentifier: string;
  createdAt: Date;
  lastSeenAt: Date;
  provides: string;
  /**
   * ownerId is null when the device is owned by the token used to send the request
   */
  ownerId: number | null;
  sourceTitle: string | null;
  publicAddress: string;
  accessToken: string;
  owned: boolean;
  home: boolean;
  synced: boolean;
  relay: boolean;
  presence: boolean;
  httpsRequired: boolean;
  publicAddressMatches: boolean;
  dnsRebindingProtection: boolean;
  natLoopbackSupported: boolean;
  connections: Array<Connection>;
};

/** @internal */
export const PlexDeviceProtocol$inboundSchema: z.ZodNativeEnum<
  typeof PlexDeviceProtocol
> = z.nativeEnum(PlexDeviceProtocol);

/** @internal */
export const Connection$inboundSchema: z.ZodType<
  Connection,
  z.ZodTypeDef,
  unknown
> = z.object({
  protocol: PlexDeviceProtocol$inboundSchema,
  address: z.string(),
  port: z.number().int(),
  uri: z.string(),
  local: z.boolean(),
  relay: z.boolean(),
  IPv6: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "IPv6": "iPv6",
  });
});

export function connectionFromJSON(
  jsonString: string,
): SafeParseResult<Connection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Connection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Connection' from JSON`,
  );
}

/** @internal */
export const PlexDevice$inboundSchema: z.ZodType<
  PlexDevice,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  product: z.string(),
  productVersion: z.string(),
  platform: z.nullable(z.string()),
  platformVersion: z.nullable(z.string()),
  device: z.nullable(z.string()),
  clientIdentifier: z.string(),
  createdAt: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  lastSeenAt: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  provides: z.string(),
  ownerId: z.nullable(z.number().int()),
  sourceTitle: z.nullable(z.string()),
  publicAddress: z.string(),
  accessToken: z.string(),
  owned: z.boolean(),
  home: z.boolean(),
  synced: z.boolean(),
  relay: z.boolean(),
  presence: z.boolean(),
  httpsRequired: z.boolean(),
  publicAddressMatches: z.boolean(),
  dnsRebindingProtection: z.boolean(),
  natLoopbackSupported: z.boolean(),
  connections: z.array(z.lazy(() => Connection$inboundSchema)),
});

export function plexDeviceFromJSON(
  jsonString: string,
): SafeParseResult<PlexDevice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PlexDevice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PlexDevice' from JSON`,
  );
}
