/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Metadata,
  Metadata$inboundSchema,
  Metadata$Outbound,
  Metadata$outboundSchema,
} from "./metadata.js";

export enum Status {
  Inactive = "inactive",
  Scheduled = "scheduled",
  Inprogress = "inprogress",
  Complete = "complete",
  Cancelled = "cancelled",
  Error = "error",
  Postprocessing = "postprocessing",
  Paused = "paused",
}

/**
 * A media grab opration represents a scheduled or active recording of media
 *
 * @remarks
 */
export type MediaGrabOperation = {
  currentSize?: number | undefined;
  grabberIdentifier?: string | undefined;
  grabberProtocol?: string | undefined;
  id?: string | undefined;
  key?: string | undefined;
  mediaIndex?: number | undefined;
  mediaSubscriptionID?: number | undefined;
  /**
   * Items in a library are referred to as "metadata items." These metadata items are distinct from "media items" which represent actual instances of media that can be consumed. Consider a TV library that has a single video file in it for a particular episode of a show. The library has a single media item, but it has three metadata items: one for the show, one for the season, and one for the episode. Consider a movie library that has two video files in it: the same movie, but two different resolutions. The library has a single metadata item for the movie, but that metadata item has two media items, one for each resolution. Additionally a "media item" will have one or more "media parts" where the the parts are intended to be watched together, such as a CD1 and CD2 parts of the same movie.
   *
   * @remarks
   *
   * Note that when a metadata item has multiple media items, those media items should be isomorphic. That is, a 4K version and 1080p version of a movie are different versions of the same movie. They have the same duration, same summary, same rating, etc. and they can generally be considered interchangeable. A theatrical release vs. director's cut vs. unrated version on the other hand would be separate metadata items.
   *
   * Metadata items can often live in a hierarchy with relationships between them.  For example, the metadata item for an episodes is associated with a season metadata item which is associated with a show metadata item.  A similar hierarchy exists with track, album, and artist and photos and photo album.  The relationships may be expressed via relative terms and absolute terms.  For example, "leaves" refer to metadata items which has associated media (there is no media for a season nor show).  A show will have "children" in the form of seasons and a season will have "children" in the form of episodes and episodes have "parent" in the form of a season which has a "parent" in the form of a show.  Similarly, a show has "grandchildren" in the form of episodse and an episode has a "grandparent" in the form of a show.
   */
  metadata?: Metadata | undefined;
  percent?: number | undefined;
  provider?: string | undefined;
  status?: Status | undefined;
};

/** @internal */
export const Status$inboundSchema: z.ZodNativeEnum<typeof Status> = z
  .nativeEnum(Status);

/** @internal */
export const Status$outboundSchema: z.ZodNativeEnum<typeof Status> =
  Status$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Status$ {
  /** @deprecated use `Status$inboundSchema` instead. */
  export const inboundSchema = Status$inboundSchema;
  /** @deprecated use `Status$outboundSchema` instead. */
  export const outboundSchema = Status$outboundSchema;
}

/** @internal */
export const MediaGrabOperation$inboundSchema: z.ZodType<
  MediaGrabOperation,
  z.ZodTypeDef,
  unknown
> = z.object({
  currentSize: z.number().int().optional(),
  grabberIdentifier: z.string().optional(),
  grabberProtocol: z.string().optional(),
  id: z.string().optional(),
  key: z.string().optional(),
  mediaIndex: z.number().int().optional(),
  mediaSubscriptionID: z.number().int().optional(),
  Metadata: Metadata$inboundSchema.optional(),
  percent: z.number().optional(),
  provider: z.string().optional(),
  status: Status$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "Metadata": "metadata",
  });
});

/** @internal */
export type MediaGrabOperation$Outbound = {
  currentSize?: number | undefined;
  grabberIdentifier?: string | undefined;
  grabberProtocol?: string | undefined;
  id?: string | undefined;
  key?: string | undefined;
  mediaIndex?: number | undefined;
  mediaSubscriptionID?: number | undefined;
  Metadata?: Metadata$Outbound | undefined;
  percent?: number | undefined;
  provider?: string | undefined;
  status?: string | undefined;
};

/** @internal */
export const MediaGrabOperation$outboundSchema: z.ZodType<
  MediaGrabOperation$Outbound,
  z.ZodTypeDef,
  MediaGrabOperation
> = z.object({
  currentSize: z.number().int().optional(),
  grabberIdentifier: z.string().optional(),
  grabberProtocol: z.string().optional(),
  id: z.string().optional(),
  key: z.string().optional(),
  mediaIndex: z.number().int().optional(),
  mediaSubscriptionID: z.number().int().optional(),
  metadata: Metadata$outboundSchema.optional(),
  percent: z.number().optional(),
  provider: z.string().optional(),
  status: Status$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    metadata: "Metadata",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaGrabOperation$ {
  /** @deprecated use `MediaGrabOperation$inboundSchema` instead. */
  export const inboundSchema = MediaGrabOperation$inboundSchema;
  /** @deprecated use `MediaGrabOperation$outboundSchema` instead. */
  export const outboundSchema = MediaGrabOperation$outboundSchema;
  /** @deprecated use `MediaGrabOperation$Outbound` instead. */
  export type Outbound = MediaGrabOperation$Outbound;
}

export function mediaGrabOperationToJSON(
  mediaGrabOperation: MediaGrabOperation,
): string {
  return JSON.stringify(
    MediaGrabOperation$outboundSchema.parse(mediaGrabOperation),
  );
}

export function mediaGrabOperationFromJSON(
  jsonString: string,
): SafeParseResult<MediaGrabOperation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MediaGrabOperation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MediaGrabOperation' from JSON`,
  );
}
