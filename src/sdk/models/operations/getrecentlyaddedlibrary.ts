/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The type of media to retrieve or filter by.
 *
 * @remarks
 * 1 = movie
 * 2 = show
 * 3 = season
 * 4 = episode
 * E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries
 */
export enum QueryParamType {
  Movie = 1,
  TvShow = 2,
  Season = 3,
  Episode = 4,
  Audio = 8,
  Album = 9,
  Track = 10,
}
/**
 * The type of media to retrieve or filter by.
 *
 * @remarks
 * 1 = movie
 * 2 = show
 * 3 = season
 * 4 = episode
 * E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries
 */
export type QueryParamTypeOpen = OpenEnum<typeof QueryParamType>;

/**
 * Adds the Meta object to the response
 *
 * @remarks
 */
export enum QueryParamIncludeMeta {
  Disable = 0,
  Enable = 1,
}

export type GetRecentlyAddedLibraryRequest = {
  contentDirectoryID?: number | undefined;
  pinnedContentDirectoryID?: Array<number> | undefined;
  /**
   * The library section ID for filtering content.
   */
  sectionID?: number | undefined;
  /**
   * The type of media to retrieve or filter by.
   *
   * @remarks
   * 1 = movie
   * 2 = show
   * 3 = season
   * 4 = episode
   * E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries
   */
  type: QueryParamTypeOpen;
  /**
   * Adds the Meta object to the response
   *
   * @remarks
   */
  includeMeta?: QueryParamIncludeMeta | undefined;
  /**
   * The index of the first item to return. If not specified, the first item will be returned.
   *
   * @remarks
   * If the number of items exceeds the limit, the response will be paginated.
   * By default this is 0
   */
  xPlexContainerStart?: number | undefined;
  /**
   * The number of items to return. If not specified, all items will be returned.
   *
   * @remarks
   * If the number of items exceeds the limit, the response will be paginated.
   * By default this is 50
   */
  xPlexContainerSize?: number | undefined;
};

export type GetRecentlyAddedLibraryFilter = {
  filter: string;
  filterType: string;
  key: string;
  title: string;
  type: string;
  advanced?: boolean | undefined;
};

/**
 * The direction of the sort. Can be either `asc` or `desc`.
 *
 * @remarks
 */
export enum ActiveDirection {
  Ascending = "asc",
  Descending = "desc",
}

/**
 * The direction of the sort. Can be either `asc` or `desc`.
 *
 * @remarks
 */
export enum DefaultDirection {
  Ascending = "asc",
  Descending = "desc",
}

export type Sort = {
  default?: string | undefined;
  active?: boolean | undefined;
  /**
   * The direction of the sort. Can be either `asc` or `desc`.
   *
   * @remarks
   */
  activeDirection?: ActiveDirection | undefined;
  /**
   * The direction of the sort. Can be either `asc` or `desc`.
   *
   * @remarks
   */
  defaultDirection?: DefaultDirection | undefined;
  descKey?: string | undefined;
  firstCharacterKey?: string | undefined;
  key: string;
  title: string;
};

export type Field = {
  key: string;
  title: string;
  type: string;
  subType?: string | undefined;
};

export type GetRecentlyAddedLibraryType = {
  key: string;
  type: string;
  subtype?: string | undefined;
  title: string;
  active: boolean;
  filter?: Array<GetRecentlyAddedLibraryFilter> | undefined;
  sort?: Array<Sort> | undefined;
  field?: Array<Field> | undefined;
};

export type Operator = {
  key: string;
  title: string;
};

export type FieldType = {
  type: string;
  operator: Array<Operator>;
};

export type GetRecentlyAddedLibraryPart = {
  id?: number | undefined;
  key?: string | undefined;
  duration?: number | undefined;
  file?: string | undefined;
  size?: number | undefined;
  container?: string | undefined;
  has64bitOffsets?: boolean | undefined;
  hasThumbnail?: number | undefined;
  optimizedForStreaming?: boolean | number | undefined;
  videoProfile?: string | undefined;
};

export type GetRecentlyAddedLibraryMedia = {
  id?: number | undefined;
  duration?: number | undefined;
  bitrate?: number | undefined;
  width?: number | undefined;
  height?: number | undefined;
  aspectRatio?: number | undefined;
  audioChannels?: number | undefined;
  audioCodec?: string | undefined;
  videoCodec?: string | undefined;
  videoResolution?: string | undefined;
  container?: string | undefined;
  videoFrameRate?: string | undefined;
  optimizedForStreaming?: boolean | number | undefined;
  has64bitOffsets?: boolean | undefined;
  videoProfile?: string | undefined;
  part?: Array<GetRecentlyAddedLibraryPart> | undefined;
};

export type GetRecentlyAddedLibraryGenre = {
  tag?: string | undefined;
};

export type GetRecentlyAddedLibraryDirector = {
  tag?: string | undefined;
};

export type GetRecentlyAddedLibraryWriter = {
  tag?: string | undefined;
};

export type GetRecentlyAddedLibraryCountry = {
  tag?: string | undefined;
};

export type GetRecentlyAddedLibraryRole = {
  tag?: string | undefined;
};

export type GetRecentlyAddedLibraryMetadata = {
  allowSync?: boolean | undefined;
  librarySectionID?: number | undefined;
  librarySectionTitle?: string | undefined;
  librarySectionUUID?: string | undefined;
  ratingKey?: number | undefined;
  key?: string | undefined;
  guid?: string | undefined;
  studio?: string | undefined;
  type?: string | undefined;
  title?: string | undefined;
  contentRating?: string | undefined;
  summary?: string | undefined;
  rating?: number | undefined;
  audienceRating?: number | undefined;
  year?: number | undefined;
  tagline?: string | undefined;
  thumb?: string | undefined;
  art?: string | undefined;
  duration?: number | undefined;
  originallyAvailableAt?: string | undefined;
  addedAt?: number | undefined;
  updatedAt?: number | undefined;
  audienceRatingImage?: string | undefined;
  chapterSource?: string | undefined;
  primaryExtraKey?: string | undefined;
  ratingImage?: string | undefined;
  media?: Array<GetRecentlyAddedLibraryMedia> | undefined;
  genre?: Array<GetRecentlyAddedLibraryGenre> | undefined;
  director?: Array<GetRecentlyAddedLibraryDirector> | undefined;
  writer?: Array<GetRecentlyAddedLibraryWriter> | undefined;
  country?: Array<GetRecentlyAddedLibraryCountry> | undefined;
  role?: Array<GetRecentlyAddedLibraryRole> | undefined;
};

/**
 * The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.
 *
 * @remarks
 */
export type GetRecentlyAddedLibraryMediaContainer = {
  type?: Array<GetRecentlyAddedLibraryType> | undefined;
  fieldType?: Array<FieldType> | undefined;
  size?: number | undefined;
  allowSync?: boolean | undefined;
  identifier?: string | undefined;
  mediaTagPrefix?: string | undefined;
  mediaTagVersion?: number | undefined;
  mixedParents?: boolean | undefined;
  metadata?: Array<GetRecentlyAddedLibraryMetadata> | undefined;
};

/**
 * The recently added content
 */
export type GetRecentlyAddedLibraryResponseBody = {
  mediaContainer?: GetRecentlyAddedLibraryMediaContainer | undefined;
};

export type GetRecentlyAddedLibraryResponse = {
  /**
   * HTTP response content type for this operation
   */
  contentType: string;
  /**
   * HTTP response status code for this operation
   */
  statusCode: number;
  /**
   * Raw HTTP response; suitable for custom response parsing
   */
  rawResponse: Response;
  /**
   * The recently added content
   */
  object?: GetRecentlyAddedLibraryResponseBody | undefined;
};

/** @internal */
export const QueryParamType$inboundSchema: z.ZodType<
  QueryParamTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(QueryParamType),
    z.number().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const QueryParamType$outboundSchema: z.ZodType<
  QueryParamTypeOpen,
  z.ZodTypeDef,
  QueryParamTypeOpen
> = z.union([
  z.nativeEnum(QueryParamType),
  z.number().and(z.custom<Unrecognized<number>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueryParamType$ {
  /** @deprecated use `QueryParamType$inboundSchema` instead. */
  export const inboundSchema = QueryParamType$inboundSchema;
  /** @deprecated use `QueryParamType$outboundSchema` instead. */
  export const outboundSchema = QueryParamType$outboundSchema;
}

/** @internal */
export const QueryParamIncludeMeta$inboundSchema: z.ZodNativeEnum<
  typeof QueryParamIncludeMeta
> = z.nativeEnum(QueryParamIncludeMeta);

/** @internal */
export const QueryParamIncludeMeta$outboundSchema: z.ZodNativeEnum<
  typeof QueryParamIncludeMeta
> = QueryParamIncludeMeta$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueryParamIncludeMeta$ {
  /** @deprecated use `QueryParamIncludeMeta$inboundSchema` instead. */
  export const inboundSchema = QueryParamIncludeMeta$inboundSchema;
  /** @deprecated use `QueryParamIncludeMeta$outboundSchema` instead. */
  export const outboundSchema = QueryParamIncludeMeta$outboundSchema;
}

/** @internal */
export const GetRecentlyAddedLibraryRequest$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  contentDirectoryID: z.number().int().optional(),
  pinnedContentDirectoryID: z.array(z.number().int()).optional(),
  sectionID: z.number().int().optional(),
  type: QueryParamType$inboundSchema,
  includeMeta: QueryParamIncludeMeta$inboundSchema,
  "X-Plex-Container-Start": z.number().int().default(0),
  "X-Plex-Container-Size": z.number().int().default(50),
}).transform((v) => {
  return remap$(v, {
    "X-Plex-Container-Start": "xPlexContainerStart",
    "X-Plex-Container-Size": "xPlexContainerSize",
  });
});

/** @internal */
export type GetRecentlyAddedLibraryRequest$Outbound = {
  contentDirectoryID?: number | undefined;
  pinnedContentDirectoryID?: Array<number> | undefined;
  sectionID?: number | undefined;
  type: number;
  includeMeta: number;
  "X-Plex-Container-Start": number;
  "X-Plex-Container-Size": number;
};

/** @internal */
export const GetRecentlyAddedLibraryRequest$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryRequest$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryRequest
> = z.object({
  contentDirectoryID: z.number().int().optional(),
  pinnedContentDirectoryID: z.array(z.number().int()).optional(),
  sectionID: z.number().int().optional(),
  type: QueryParamType$outboundSchema,
  includeMeta: QueryParamIncludeMeta$outboundSchema.default(
    QueryParamIncludeMeta.Disable,
  ),
  xPlexContainerStart: z.number().int().default(0),
  xPlexContainerSize: z.number().int().default(50),
}).transform((v) => {
  return remap$(v, {
    xPlexContainerStart: "X-Plex-Container-Start",
    xPlexContainerSize: "X-Plex-Container-Size",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryRequest$ {
  /** @deprecated use `GetRecentlyAddedLibraryRequest$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedLibraryRequest$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryRequest$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedLibraryRequest$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryRequest$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryRequest$Outbound;
}

export function getRecentlyAddedLibraryRequestToJSON(
  getRecentlyAddedLibraryRequest: GetRecentlyAddedLibraryRequest,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryRequest$outboundSchema.parse(
      getRecentlyAddedLibraryRequest,
    ),
  );
}

export function getRecentlyAddedLibraryRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedLibraryRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryRequest' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryFilter$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryFilter,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: z.string(),
  filterType: z.string(),
  key: z.string(),
  title: z.string(),
  type: z.string(),
  advanced: z.boolean().optional(),
});

/** @internal */
export type GetRecentlyAddedLibraryFilter$Outbound = {
  filter: string;
  filterType: string;
  key: string;
  title: string;
  type: string;
  advanced?: boolean | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryFilter$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryFilter$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryFilter
> = z.object({
  filter: z.string(),
  filterType: z.string(),
  key: z.string(),
  title: z.string(),
  type: z.string(),
  advanced: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryFilter$ {
  /** @deprecated use `GetRecentlyAddedLibraryFilter$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedLibraryFilter$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryFilter$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedLibraryFilter$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryFilter$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryFilter$Outbound;
}

export function getRecentlyAddedLibraryFilterToJSON(
  getRecentlyAddedLibraryFilter: GetRecentlyAddedLibraryFilter,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryFilter$outboundSchema.parse(
      getRecentlyAddedLibraryFilter,
    ),
  );
}

export function getRecentlyAddedLibraryFilterFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedLibraryFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryFilter' from JSON`,
  );
}

/** @internal */
export const ActiveDirection$inboundSchema: z.ZodNativeEnum<
  typeof ActiveDirection
> = z.nativeEnum(ActiveDirection);

/** @internal */
export const ActiveDirection$outboundSchema: z.ZodNativeEnum<
  typeof ActiveDirection
> = ActiveDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ActiveDirection$ {
  /** @deprecated use `ActiveDirection$inboundSchema` instead. */
  export const inboundSchema = ActiveDirection$inboundSchema;
  /** @deprecated use `ActiveDirection$outboundSchema` instead. */
  export const outboundSchema = ActiveDirection$outboundSchema;
}

/** @internal */
export const DefaultDirection$inboundSchema: z.ZodNativeEnum<
  typeof DefaultDirection
> = z.nativeEnum(DefaultDirection);

/** @internal */
export const DefaultDirection$outboundSchema: z.ZodNativeEnum<
  typeof DefaultDirection
> = DefaultDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultDirection$ {
  /** @deprecated use `DefaultDirection$inboundSchema` instead. */
  export const inboundSchema = DefaultDirection$inboundSchema;
  /** @deprecated use `DefaultDirection$outboundSchema` instead. */
  export const outboundSchema = DefaultDirection$outboundSchema;
}

/** @internal */
export const Sort$inboundSchema: z.ZodType<Sort, z.ZodTypeDef, unknown> = z
  .object({
    default: z.string().optional(),
    active: z.boolean().optional(),
    activeDirection: ActiveDirection$inboundSchema.default(
      ActiveDirection.Ascending,
    ),
    defaultDirection: DefaultDirection$inboundSchema.default(
      DefaultDirection.Ascending,
    ),
    descKey: z.string().optional(),
    firstCharacterKey: z.string().optional(),
    key: z.string(),
    title: z.string(),
  });

/** @internal */
export type Sort$Outbound = {
  default?: string | undefined;
  active?: boolean | undefined;
  activeDirection: string;
  defaultDirection: string;
  descKey?: string | undefined;
  firstCharacterKey?: string | undefined;
  key: string;
  title: string;
};

/** @internal */
export const Sort$outboundSchema: z.ZodType<Sort$Outbound, z.ZodTypeDef, Sort> =
  z.object({
    default: z.string().optional(),
    active: z.boolean().optional(),
    activeDirection: ActiveDirection$outboundSchema.default(
      ActiveDirection.Ascending,
    ),
    defaultDirection: DefaultDirection$outboundSchema.default(
      DefaultDirection.Ascending,
    ),
    descKey: z.string().optional(),
    firstCharacterKey: z.string().optional(),
    key: z.string(),
    title: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Sort$ {
  /** @deprecated use `Sort$inboundSchema` instead. */
  export const inboundSchema = Sort$inboundSchema;
  /** @deprecated use `Sort$outboundSchema` instead. */
  export const outboundSchema = Sort$outboundSchema;
  /** @deprecated use `Sort$Outbound` instead. */
  export type Outbound = Sort$Outbound;
}

export function sortToJSON(sort: Sort): string {
  return JSON.stringify(Sort$outboundSchema.parse(sort));
}

export function sortFromJSON(
  jsonString: string,
): SafeParseResult<Sort, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Sort$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Sort' from JSON`,
  );
}

/** @internal */
export const Field$inboundSchema: z.ZodType<Field, z.ZodTypeDef, unknown> = z
  .object({
    key: z.string(),
    title: z.string(),
    type: z.string(),
    subType: z.string().optional(),
  });

/** @internal */
export type Field$Outbound = {
  key: string;
  title: string;
  type: string;
  subType?: string | undefined;
};

/** @internal */
export const Field$outboundSchema: z.ZodType<
  Field$Outbound,
  z.ZodTypeDef,
  Field
> = z.object({
  key: z.string(),
  title: z.string(),
  type: z.string(),
  subType: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Field$ {
  /** @deprecated use `Field$inboundSchema` instead. */
  export const inboundSchema = Field$inboundSchema;
  /** @deprecated use `Field$outboundSchema` instead. */
  export const outboundSchema = Field$outboundSchema;
  /** @deprecated use `Field$Outbound` instead. */
  export type Outbound = Field$Outbound;
}

export function fieldToJSON(field: Field): string {
  return JSON.stringify(Field$outboundSchema.parse(field));
}

export function fieldFromJSON(
  jsonString: string,
): SafeParseResult<Field, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Field$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Field' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryType$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryType,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  type: z.string(),
  subtype: z.string().optional(),
  title: z.string(),
  active: z.boolean(),
  Filter: z.array(z.lazy(() => GetRecentlyAddedLibraryFilter$inboundSchema))
    .optional(),
  Sort: z.array(z.lazy(() => Sort$inboundSchema)).optional(),
  Field: z.array(z.lazy(() => Field$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "Filter": "filter",
    "Sort": "sort",
    "Field": "field",
  });
});

/** @internal */
export type GetRecentlyAddedLibraryType$Outbound = {
  key: string;
  type: string;
  subtype?: string | undefined;
  title: string;
  active: boolean;
  Filter?: Array<GetRecentlyAddedLibraryFilter$Outbound> | undefined;
  Sort?: Array<Sort$Outbound> | undefined;
  Field?: Array<Field$Outbound> | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryType$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryType$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryType
> = z.object({
  key: z.string(),
  type: z.string(),
  subtype: z.string().optional(),
  title: z.string(),
  active: z.boolean(),
  filter: z.array(z.lazy(() => GetRecentlyAddedLibraryFilter$outboundSchema))
    .optional(),
  sort: z.array(z.lazy(() => Sort$outboundSchema)).optional(),
  field: z.array(z.lazy(() => Field$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    filter: "Filter",
    sort: "Sort",
    field: "Field",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryType$ {
  /** @deprecated use `GetRecentlyAddedLibraryType$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedLibraryType$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryType$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedLibraryType$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryType$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryType$Outbound;
}

export function getRecentlyAddedLibraryTypeToJSON(
  getRecentlyAddedLibraryType: GetRecentlyAddedLibraryType,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryType$outboundSchema.parse(
      getRecentlyAddedLibraryType,
    ),
  );
}

export function getRecentlyAddedLibraryTypeFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedLibraryType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryType' from JSON`,
  );
}

/** @internal */
export const Operator$inboundSchema: z.ZodType<
  Operator,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  title: z.string(),
});

/** @internal */
export type Operator$Outbound = {
  key: string;
  title: string;
};

/** @internal */
export const Operator$outboundSchema: z.ZodType<
  Operator$Outbound,
  z.ZodTypeDef,
  Operator
> = z.object({
  key: z.string(),
  title: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Operator$ {
  /** @deprecated use `Operator$inboundSchema` instead. */
  export const inboundSchema = Operator$inboundSchema;
  /** @deprecated use `Operator$outboundSchema` instead. */
  export const outboundSchema = Operator$outboundSchema;
  /** @deprecated use `Operator$Outbound` instead. */
  export type Outbound = Operator$Outbound;
}

export function operatorToJSON(operator: Operator): string {
  return JSON.stringify(Operator$outboundSchema.parse(operator));
}

export function operatorFromJSON(
  jsonString: string,
): SafeParseResult<Operator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Operator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Operator' from JSON`,
  );
}

/** @internal */
export const FieldType$inboundSchema: z.ZodType<
  FieldType,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string(),
  Operator: z.array(z.lazy(() => Operator$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "Operator": "operator",
  });
});

/** @internal */
export type FieldType$Outbound = {
  type: string;
  Operator: Array<Operator$Outbound>;
};

/** @internal */
export const FieldType$outboundSchema: z.ZodType<
  FieldType$Outbound,
  z.ZodTypeDef,
  FieldType
> = z.object({
  type: z.string(),
  operator: z.array(z.lazy(() => Operator$outboundSchema)),
}).transform((v) => {
  return remap$(v, {
    operator: "Operator",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FieldType$ {
  /** @deprecated use `FieldType$inboundSchema` instead. */
  export const inboundSchema = FieldType$inboundSchema;
  /** @deprecated use `FieldType$outboundSchema` instead. */
  export const outboundSchema = FieldType$outboundSchema;
  /** @deprecated use `FieldType$Outbound` instead. */
  export type Outbound = FieldType$Outbound;
}

export function fieldTypeToJSON(fieldType: FieldType): string {
  return JSON.stringify(FieldType$outboundSchema.parse(fieldType));
}

export function fieldTypeFromJSON(
  jsonString: string,
): SafeParseResult<FieldType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FieldType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FieldType' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryPart$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().optional(),
  key: z.string().optional(),
  duration: z.number().optional(),
  file: z.string().optional(),
  size: z.number().optional(),
  container: z.string().optional(),
  has64bitOffsets: z.boolean().optional(),
  hasThumbnail: z.number().optional(),
  optimizedForStreaming: z.union([z.boolean(), z.number()]).optional(),
  videoProfile: z.string().optional(),
});

/** @internal */
export type GetRecentlyAddedLibraryPart$Outbound = {
  id?: number | undefined;
  key?: string | undefined;
  duration?: number | undefined;
  file?: string | undefined;
  size?: number | undefined;
  container?: string | undefined;
  has64bitOffsets?: boolean | undefined;
  hasThumbnail?: number | undefined;
  optimizedForStreaming?: boolean | number | undefined;
  videoProfile?: string | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryPart$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryPart$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryPart
> = z.object({
  id: z.number().optional(),
  key: z.string().optional(),
  duration: z.number().optional(),
  file: z.string().optional(),
  size: z.number().optional(),
  container: z.string().optional(),
  has64bitOffsets: z.boolean().optional(),
  hasThumbnail: z.number().optional(),
  optimizedForStreaming: z.union([z.boolean(), z.number()]).optional(),
  videoProfile: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryPart$ {
  /** @deprecated use `GetRecentlyAddedLibraryPart$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedLibraryPart$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryPart$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedLibraryPart$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryPart$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryPart$Outbound;
}

export function getRecentlyAddedLibraryPartToJSON(
  getRecentlyAddedLibraryPart: GetRecentlyAddedLibraryPart,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryPart$outboundSchema.parse(
      getRecentlyAddedLibraryPart,
    ),
  );
}

export function getRecentlyAddedLibraryPartFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedLibraryPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryPart' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryMedia$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryMedia,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().optional(),
  duration: z.number().optional(),
  bitrate: z.number().optional(),
  width: z.number().optional(),
  height: z.number().optional(),
  aspectRatio: z.number().optional(),
  audioChannels: z.number().optional(),
  audioCodec: z.string().optional(),
  videoCodec: z.string().optional(),
  videoResolution: z.string().optional(),
  container: z.string().optional(),
  videoFrameRate: z.string().optional(),
  optimizedForStreaming: z.union([z.boolean(), z.number()]).optional(),
  has64bitOffsets: z.boolean().optional(),
  videoProfile: z.string().optional(),
  Part: z.array(z.lazy(() => GetRecentlyAddedLibraryPart$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "Part": "part",
  });
});

/** @internal */
export type GetRecentlyAddedLibraryMedia$Outbound = {
  id?: number | undefined;
  duration?: number | undefined;
  bitrate?: number | undefined;
  width?: number | undefined;
  height?: number | undefined;
  aspectRatio?: number | undefined;
  audioChannels?: number | undefined;
  audioCodec?: string | undefined;
  videoCodec?: string | undefined;
  videoResolution?: string | undefined;
  container?: string | undefined;
  videoFrameRate?: string | undefined;
  optimizedForStreaming?: boolean | number | undefined;
  has64bitOffsets?: boolean | undefined;
  videoProfile?: string | undefined;
  Part?: Array<GetRecentlyAddedLibraryPart$Outbound> | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryMedia$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryMedia$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryMedia
> = z.object({
  id: z.number().optional(),
  duration: z.number().optional(),
  bitrate: z.number().optional(),
  width: z.number().optional(),
  height: z.number().optional(),
  aspectRatio: z.number().optional(),
  audioChannels: z.number().optional(),
  audioCodec: z.string().optional(),
  videoCodec: z.string().optional(),
  videoResolution: z.string().optional(),
  container: z.string().optional(),
  videoFrameRate: z.string().optional(),
  optimizedForStreaming: z.union([z.boolean(), z.number()]).optional(),
  has64bitOffsets: z.boolean().optional(),
  videoProfile: z.string().optional(),
  part: z.array(z.lazy(() => GetRecentlyAddedLibraryPart$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    part: "Part",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryMedia$ {
  /** @deprecated use `GetRecentlyAddedLibraryMedia$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedLibraryMedia$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryMedia$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedLibraryMedia$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryMedia$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryMedia$Outbound;
}

export function getRecentlyAddedLibraryMediaToJSON(
  getRecentlyAddedLibraryMedia: GetRecentlyAddedLibraryMedia,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryMedia$outboundSchema.parse(
      getRecentlyAddedLibraryMedia,
    ),
  );
}

export function getRecentlyAddedLibraryMediaFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedLibraryMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryMedia' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryGenre$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryGenre,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
});

/** @internal */
export type GetRecentlyAddedLibraryGenre$Outbound = {
  tag?: string | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryGenre$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryGenre$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryGenre
> = z.object({
  tag: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryGenre$ {
  /** @deprecated use `GetRecentlyAddedLibraryGenre$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedLibraryGenre$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryGenre$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedLibraryGenre$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryGenre$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryGenre$Outbound;
}

export function getRecentlyAddedLibraryGenreToJSON(
  getRecentlyAddedLibraryGenre: GetRecentlyAddedLibraryGenre,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryGenre$outboundSchema.parse(
      getRecentlyAddedLibraryGenre,
    ),
  );
}

export function getRecentlyAddedLibraryGenreFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryGenre, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedLibraryGenre$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryGenre' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryDirector$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryDirector,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
});

/** @internal */
export type GetRecentlyAddedLibraryDirector$Outbound = {
  tag?: string | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryDirector$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryDirector$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryDirector
> = z.object({
  tag: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryDirector$ {
  /** @deprecated use `GetRecentlyAddedLibraryDirector$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedLibraryDirector$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryDirector$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedLibraryDirector$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryDirector$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryDirector$Outbound;
}

export function getRecentlyAddedLibraryDirectorToJSON(
  getRecentlyAddedLibraryDirector: GetRecentlyAddedLibraryDirector,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryDirector$outboundSchema.parse(
      getRecentlyAddedLibraryDirector,
    ),
  );
}

export function getRecentlyAddedLibraryDirectorFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryDirector, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedLibraryDirector$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryDirector' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryWriter$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryWriter,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
});

/** @internal */
export type GetRecentlyAddedLibraryWriter$Outbound = {
  tag?: string | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryWriter$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryWriter$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryWriter
> = z.object({
  tag: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryWriter$ {
  /** @deprecated use `GetRecentlyAddedLibraryWriter$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedLibraryWriter$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryWriter$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedLibraryWriter$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryWriter$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryWriter$Outbound;
}

export function getRecentlyAddedLibraryWriterToJSON(
  getRecentlyAddedLibraryWriter: GetRecentlyAddedLibraryWriter,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryWriter$outboundSchema.parse(
      getRecentlyAddedLibraryWriter,
    ),
  );
}

export function getRecentlyAddedLibraryWriterFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryWriter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedLibraryWriter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryWriter' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryCountry$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryCountry,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
});

/** @internal */
export type GetRecentlyAddedLibraryCountry$Outbound = {
  tag?: string | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryCountry$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryCountry$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryCountry
> = z.object({
  tag: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryCountry$ {
  /** @deprecated use `GetRecentlyAddedLibraryCountry$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedLibraryCountry$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryCountry$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedLibraryCountry$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryCountry$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryCountry$Outbound;
}

export function getRecentlyAddedLibraryCountryToJSON(
  getRecentlyAddedLibraryCountry: GetRecentlyAddedLibraryCountry,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryCountry$outboundSchema.parse(
      getRecentlyAddedLibraryCountry,
    ),
  );
}

export function getRecentlyAddedLibraryCountryFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryCountry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedLibraryCountry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryCountry' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryRole$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryRole,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string().optional(),
});

/** @internal */
export type GetRecentlyAddedLibraryRole$Outbound = {
  tag?: string | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryRole$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryRole$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryRole
> = z.object({
  tag: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryRole$ {
  /** @deprecated use `GetRecentlyAddedLibraryRole$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedLibraryRole$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryRole$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedLibraryRole$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryRole$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryRole$Outbound;
}

export function getRecentlyAddedLibraryRoleToJSON(
  getRecentlyAddedLibraryRole: GetRecentlyAddedLibraryRole,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryRole$outboundSchema.parse(
      getRecentlyAddedLibraryRole,
    ),
  );
}

export function getRecentlyAddedLibraryRoleFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedLibraryRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryRole' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryMetadata$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  allowSync: z.boolean().optional(),
  librarySectionID: z.number().optional(),
  librarySectionTitle: z.string().optional(),
  librarySectionUUID: z.string().optional(),
  ratingKey: z.number().optional(),
  key: z.string().optional(),
  guid: z.string().optional(),
  studio: z.string().optional(),
  type: z.string().optional(),
  title: z.string().optional(),
  contentRating: z.string().optional(),
  summary: z.string().optional(),
  rating: z.number().optional(),
  audienceRating: z.number().optional(),
  year: z.number().optional(),
  tagline: z.string().optional(),
  thumb: z.string().optional(),
  art: z.string().optional(),
  duration: z.number().optional(),
  originallyAvailableAt: z.string().optional(),
  addedAt: z.number().optional(),
  updatedAt: z.number().optional(),
  audienceRatingImage: z.string().optional(),
  chapterSource: z.string().optional(),
  primaryExtraKey: z.string().optional(),
  ratingImage: z.string().optional(),
  Media: z.array(z.lazy(() => GetRecentlyAddedLibraryMedia$inboundSchema))
    .optional(),
  Genre: z.array(z.lazy(() => GetRecentlyAddedLibraryGenre$inboundSchema))
    .optional(),
  Director: z.array(z.lazy(() => GetRecentlyAddedLibraryDirector$inboundSchema))
    .optional(),
  Writer: z.array(z.lazy(() => GetRecentlyAddedLibraryWriter$inboundSchema))
    .optional(),
  Country: z.array(z.lazy(() => GetRecentlyAddedLibraryCountry$inboundSchema))
    .optional(),
  Role: z.array(z.lazy(() => GetRecentlyAddedLibraryRole$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "Media": "media",
    "Genre": "genre",
    "Director": "director",
    "Writer": "writer",
    "Country": "country",
    "Role": "role",
  });
});

/** @internal */
export type GetRecentlyAddedLibraryMetadata$Outbound = {
  allowSync?: boolean | undefined;
  librarySectionID?: number | undefined;
  librarySectionTitle?: string | undefined;
  librarySectionUUID?: string | undefined;
  ratingKey?: number | undefined;
  key?: string | undefined;
  guid?: string | undefined;
  studio?: string | undefined;
  type?: string | undefined;
  title?: string | undefined;
  contentRating?: string | undefined;
  summary?: string | undefined;
  rating?: number | undefined;
  audienceRating?: number | undefined;
  year?: number | undefined;
  tagline?: string | undefined;
  thumb?: string | undefined;
  art?: string | undefined;
  duration?: number | undefined;
  originallyAvailableAt?: string | undefined;
  addedAt?: number | undefined;
  updatedAt?: number | undefined;
  audienceRatingImage?: string | undefined;
  chapterSource?: string | undefined;
  primaryExtraKey?: string | undefined;
  ratingImage?: string | undefined;
  Media?: Array<GetRecentlyAddedLibraryMedia$Outbound> | undefined;
  Genre?: Array<GetRecentlyAddedLibraryGenre$Outbound> | undefined;
  Director?: Array<GetRecentlyAddedLibraryDirector$Outbound> | undefined;
  Writer?: Array<GetRecentlyAddedLibraryWriter$Outbound> | undefined;
  Country?: Array<GetRecentlyAddedLibraryCountry$Outbound> | undefined;
  Role?: Array<GetRecentlyAddedLibraryRole$Outbound> | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryMetadata$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryMetadata$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryMetadata
> = z.object({
  allowSync: z.boolean().optional(),
  librarySectionID: z.number().optional(),
  librarySectionTitle: z.string().optional(),
  librarySectionUUID: z.string().optional(),
  ratingKey: z.number().optional(),
  key: z.string().optional(),
  guid: z.string().optional(),
  studio: z.string().optional(),
  type: z.string().optional(),
  title: z.string().optional(),
  contentRating: z.string().optional(),
  summary: z.string().optional(),
  rating: z.number().optional(),
  audienceRating: z.number().optional(),
  year: z.number().optional(),
  tagline: z.string().optional(),
  thumb: z.string().optional(),
  art: z.string().optional(),
  duration: z.number().optional(),
  originallyAvailableAt: z.string().optional(),
  addedAt: z.number().optional(),
  updatedAt: z.number().optional(),
  audienceRatingImage: z.string().optional(),
  chapterSource: z.string().optional(),
  primaryExtraKey: z.string().optional(),
  ratingImage: z.string().optional(),
  media: z.array(z.lazy(() => GetRecentlyAddedLibraryMedia$outboundSchema))
    .optional(),
  genre: z.array(z.lazy(() => GetRecentlyAddedLibraryGenre$outboundSchema))
    .optional(),
  director: z.array(
    z.lazy(() => GetRecentlyAddedLibraryDirector$outboundSchema),
  ).optional(),
  writer: z.array(z.lazy(() => GetRecentlyAddedLibraryWriter$outboundSchema))
    .optional(),
  country: z.array(z.lazy(() => GetRecentlyAddedLibraryCountry$outboundSchema))
    .optional(),
  role: z.array(z.lazy(() => GetRecentlyAddedLibraryRole$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    media: "Media",
    genre: "Genre",
    director: "Director",
    writer: "Writer",
    country: "Country",
    role: "Role",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryMetadata$ {
  /** @deprecated use `GetRecentlyAddedLibraryMetadata$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedLibraryMetadata$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryMetadata$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedLibraryMetadata$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryMetadata$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryMetadata$Outbound;
}

export function getRecentlyAddedLibraryMetadataToJSON(
  getRecentlyAddedLibraryMetadata: GetRecentlyAddedLibraryMetadata,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryMetadata$outboundSchema.parse(
      getRecentlyAddedLibraryMetadata,
    ),
  );
}

export function getRecentlyAddedLibraryMetadataFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedLibraryMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryMetadata' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryMediaContainer$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryMediaContainer,
  z.ZodTypeDef,
  unknown
> = z.object({
  Type: z.array(z.lazy(() => GetRecentlyAddedLibraryType$inboundSchema))
    .optional(),
  FieldType: z.array(z.lazy(() => FieldType$inboundSchema)).optional(),
  size: z.number().optional(),
  allowSync: z.boolean().optional(),
  identifier: z.string().optional(),
  mediaTagPrefix: z.string().optional(),
  mediaTagVersion: z.number().optional(),
  mixedParents: z.boolean().optional(),
  Metadata: z.array(z.lazy(() => GetRecentlyAddedLibraryMetadata$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "Type": "type",
    "FieldType": "fieldType",
    "Metadata": "metadata",
  });
});

/** @internal */
export type GetRecentlyAddedLibraryMediaContainer$Outbound = {
  Type?: Array<GetRecentlyAddedLibraryType$Outbound> | undefined;
  FieldType?: Array<FieldType$Outbound> | undefined;
  size?: number | undefined;
  allowSync?: boolean | undefined;
  identifier?: string | undefined;
  mediaTagPrefix?: string | undefined;
  mediaTagVersion?: number | undefined;
  mixedParents?: boolean | undefined;
  Metadata?: Array<GetRecentlyAddedLibraryMetadata$Outbound> | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryMediaContainer$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryMediaContainer$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryMediaContainer
> = z.object({
  type: z.array(z.lazy(() => GetRecentlyAddedLibraryType$outboundSchema))
    .optional(),
  fieldType: z.array(z.lazy(() => FieldType$outboundSchema)).optional(),
  size: z.number().optional(),
  allowSync: z.boolean().optional(),
  identifier: z.string().optional(),
  mediaTagPrefix: z.string().optional(),
  mediaTagVersion: z.number().optional(),
  mixedParents: z.boolean().optional(),
  metadata: z.array(
    z.lazy(() => GetRecentlyAddedLibraryMetadata$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    type: "Type",
    fieldType: "FieldType",
    metadata: "Metadata",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryMediaContainer$ {
  /** @deprecated use `GetRecentlyAddedLibraryMediaContainer$inboundSchema` instead. */
  export const inboundSchema =
    GetRecentlyAddedLibraryMediaContainer$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryMediaContainer$outboundSchema` instead. */
  export const outboundSchema =
    GetRecentlyAddedLibraryMediaContainer$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryMediaContainer$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryMediaContainer$Outbound;
}

export function getRecentlyAddedLibraryMediaContainerToJSON(
  getRecentlyAddedLibraryMediaContainer: GetRecentlyAddedLibraryMediaContainer,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryMediaContainer$outboundSchema.parse(
      getRecentlyAddedLibraryMediaContainer,
    ),
  );
}

export function getRecentlyAddedLibraryMediaContainerFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryMediaContainer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetRecentlyAddedLibraryMediaContainer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryMediaContainer' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryResponseBody$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  MediaContainer: z.lazy(() =>
    GetRecentlyAddedLibraryMediaContainer$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "MediaContainer": "mediaContainer",
  });
});

/** @internal */
export type GetRecentlyAddedLibraryResponseBody$Outbound = {
  MediaContainer?: GetRecentlyAddedLibraryMediaContainer$Outbound | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryResponseBody$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryResponseBody$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryResponseBody
> = z.object({
  mediaContainer: z.lazy(() =>
    GetRecentlyAddedLibraryMediaContainer$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    mediaContainer: "MediaContainer",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryResponseBody$ {
  /** @deprecated use `GetRecentlyAddedLibraryResponseBody$inboundSchema` instead. */
  export const inboundSchema =
    GetRecentlyAddedLibraryResponseBody$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryResponseBody$outboundSchema` instead. */
  export const outboundSchema =
    GetRecentlyAddedLibraryResponseBody$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryResponseBody$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryResponseBody$Outbound;
}

export function getRecentlyAddedLibraryResponseBodyToJSON(
  getRecentlyAddedLibraryResponseBody: GetRecentlyAddedLibraryResponseBody,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryResponseBody$outboundSchema.parse(
      getRecentlyAddedLibraryResponseBody,
    ),
  );
}

export function getRecentlyAddedLibraryResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetRecentlyAddedLibraryResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryResponseBody' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedLibraryResponse$inboundSchema: z.ZodType<
  GetRecentlyAddedLibraryResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  ContentType: z.string(),
  StatusCode: z.number().int(),
  RawResponse: z.instanceof(Response),
  object: z.lazy(() => GetRecentlyAddedLibraryResponseBody$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "ContentType": "contentType",
    "StatusCode": "statusCode",
    "RawResponse": "rawResponse",
  });
});

/** @internal */
export type GetRecentlyAddedLibraryResponse$Outbound = {
  ContentType: string;
  StatusCode: number;
  RawResponse: never;
  object?: GetRecentlyAddedLibraryResponseBody$Outbound | undefined;
};

/** @internal */
export const GetRecentlyAddedLibraryResponse$outboundSchema: z.ZodType<
  GetRecentlyAddedLibraryResponse$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedLibraryResponse
> = z.object({
  contentType: z.string(),
  statusCode: z.number().int(),
  rawResponse: z.instanceof(Response).transform(() => {
    throw new Error("Response cannot be serialized");
  }),
  object: z.lazy(() => GetRecentlyAddedLibraryResponseBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    contentType: "ContentType",
    statusCode: "StatusCode",
    rawResponse: "RawResponse",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedLibraryResponse$ {
  /** @deprecated use `GetRecentlyAddedLibraryResponse$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedLibraryResponse$inboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryResponse$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedLibraryResponse$outboundSchema;
  /** @deprecated use `GetRecentlyAddedLibraryResponse$Outbound` instead. */
  export type Outbound = GetRecentlyAddedLibraryResponse$Outbound;
}

export function getRecentlyAddedLibraryResponseToJSON(
  getRecentlyAddedLibraryResponse: GetRecentlyAddedLibraryResponse,
): string {
  return JSON.stringify(
    GetRecentlyAddedLibraryResponse$outboundSchema.parse(
      getRecentlyAddedLibraryResponse,
    ),
  );
}

export function getRecentlyAddedLibraryResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedLibraryResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedLibraryResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedLibraryResponse' from JSON`,
  );
}