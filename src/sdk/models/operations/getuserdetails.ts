/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { remap as remap$ } from "../../../lib/primitives.js";
import * as z from "zod";

export const GetUserDetailsServerList = ["https://plex.tv/api/v2"] as const;

export type GetUserDetailsRequest = {
    /**
     * Plex Authentication Token
     */
    xPlexToken: string;
};

/**
 * Your current mailing list status
 */
export enum MailingListStatus {
    Active = "active",
    Unsubscribed = "unsubscribed",
}

/**
 * The auto-select subtitle mode (0 = Manually selected, 1 = Shown with foreign audio, 2 = Always enabled)
 */
export enum AutoSelectSubtitle {
    Zero = "0",
    One = "1",
}

/**
 * The subtitles for the deaf or hard-of-hearing (SDH) searches mode (0 = Prefer non-SDH subtitles, 1 = Prefer SDH subtitles, 2 = Only show SDH subtitles, 3 = Only shown non-SDH subtitles)
 */
export enum DefaultSubtitleAccessibility {
    Zero = "0",
    One = "1",
}

/**
 * The forced subtitles searches mode (0 = Prefer non-forced subtitles, 1 = Prefer forced subtitles, 2 = Only show forced subtitles, 3 = Only show non-forced subtitles)
 */
export enum DefaultSubtitleForced {
    Zero = "0",
    One = "1",
}

export enum WatchedIndicator {
    Zero = "0",
    One = "1",
}

export enum MediaReviewsVisibility {
    Zero = 0,
    One = 1,
}

export type UserProfile = {
    /**
     * If the account has automatically select audio and subtitle tracks enabled
     */
    autoSelectAudio?: boolean | undefined;
    /**
     * The preferred audio language for the account
     */
    defaultAudioLanguage: string | null;
    /**
     * The preferred subtitle language for the account
     */
    defaultSubtitleLanguage: string | null;
    /**
     * The auto-select subtitle mode (0 = Manually selected, 1 = Shown with foreign audio, 2 = Always enabled)
     */
    autoSelectSubtitle?: AutoSelectSubtitle | undefined;
    /**
     * The subtitles for the deaf or hard-of-hearing (SDH) searches mode (0 = Prefer non-SDH subtitles, 1 = Prefer SDH subtitles, 2 = Only show SDH subtitles, 3 = Only shown non-SDH subtitles)
     */
    defaultSubtitleAccessibility?: DefaultSubtitleAccessibility | undefined;
    /**
     * The forced subtitles searches mode (0 = Prefer non-forced subtitles, 1 = Prefer forced subtitles, 2 = Only show forced subtitles, 3 = Only show non-forced subtitles)
     */
    defaultSubtitleForced?: DefaultSubtitleForced | undefined;
    watchedIndicator?: WatchedIndicator | undefined;
    mediaReviewsVisibility?: MediaReviewsVisibility | undefined;
};

export enum GetUserDetailsStatus {
    Online = "online",
    Offline = "offline",
}

export type Services = {
    identifier: string;
    endpoint: string;
    token: string | null;
    secret: string | null;
    status: GetUserDetailsStatus;
};

export enum Features {
    AndroidDolbyVision = "Android - Dolby Vision",
    AndroidPiP = "Android - PiP",
    CUSunset = "CU Sunset",
    HRKEnableEUR = "HRK_enable_EUR",
    TREBLEShowFeatures = "TREBLE-show-features",
    AdCountdownTimer = "ad-countdown-timer",
    AdaptiveBitrate = "adaptive_bitrate",
    AmazonLoopDebug = "amazon-loop-debug",
    AvodAdAnalysis = "avod-ad-analysis",
    AvodNewMedia = "avod-new-media",
    BlacklistGetSignin = "blacklist_get_signin",
    ClientRadioStations = "client-radio-stations",
    CloudflareTurnstileRequired = "cloudflare-turnstile-required",
    Collections = "collections",
    CommentsAndRepliesPushNotifications = "comments_and_replies_push_notifications",
    CommunityAccessPlexTv = "community_access_plex_tv",
    CompanionsSonos = "companions_sonos",
    CustomHomeRemoval = "custom-home-removal",
    DisableHomeUserFriendships = "disable_home_user_friendships",
    DisableSharingFriendships = "disable_sharing_friendships",
    DrmSupport = "drm_support",
    ExcludeRestrictions = "exclude restrictions",
    FederatedAuth = "federated-auth",
    FriendRequestPushNotifications = "friend_request_push_notifications",
    GuidedUpgrade = "guided-upgrade",
    Home = "home",
    IncreasePasswordComplexity = "increase-password-complexity",
    Ios14PrivacyBanner = "ios14-privacy-banner",
    IterableNotificationTokens = "iterable-notification-tokens",
    KeepPaymentMethod = "keep-payment-method",
    KevinBacon = "kevin-bacon",
    KoreaConsent = "korea-consent",
    LeIsrgRootX1 = "le_isrg_root_x1",
    LetsEncrypt = "lets_encrypt",
    LightningDvrPivot = "lightning-dvr-pivot",
    LiveTvSupportIncompleteSegments = "live-tv-support-incomplete-segments",
    Livetv = "livetv",
    MetadataSearch = "metadata_search",
    NewPlexPassPrices = "new_plex_pass_prices",
    NewsProviderSunsetModal = "news-provider-sunset-modal",
    PhotosFavorites = "photos-favorites",
    PhotosMetadataEdition = "photos-metadata-edition",
    PmsHealth = "pms_health",
    Radio = "radio",
    RateLimitClientToken = "rate-limit-client-token",
    ScrobblingServicePlexTv = "scrobbling-service-plex-tv",
    SharedServerNotification = "shared_server_notification",
    SharedSourceNotification = "shared_source_notification",
    SigninWithApple = "signin_with_apple",
    SpringServeAdProvider = "spring_serve_ad_provider",
    TranscoderCache = "transcoder_cache",
    TunerSharing = "tuner-sharing",
    TwoFactorAuthentication = "two-factor-authentication",
    Unsupportedtuners = "unsupportedtuners",
    Upgrade3ds2 = "upgrade-3ds2",
    VodSchema = "vod-schema",
    VodCloudflare = "vod_cloudflare",
    WatchTogetherInvite = "watch-together-invite",
    WebServerDashboard = "web_server_dashboard",
}

/**
 * String representation of subscriptionActive
 */
export enum GetUserDetailsAuthenticationStatus {
    Inactive = "Inactive",
    Active = "Active",
}

/**
 * If the account’s Plex Pass subscription is active
 */
export type Subscription = {
    /**
     * List of features allowed on your Plex Pass subscription
     */
    features?: Array<Features> | undefined;
    /**
     * If the account's Plex Pass subscription is active
     */
    active?: boolean | undefined;
    /**
     * Date the account subscribed to Plex Pass
     */
    subscribedAt?: string | null | undefined;
    /**
     * String representation of subscriptionActive
     */
    status?: GetUserDetailsAuthenticationStatus | undefined;
    /**
     * Payment service used for your Plex Pass subscription
     */
    paymentService?: string | null | undefined;
    /**
     * Name of Plex Pass subscription plan
     */
    plan?: string | null | undefined;
};

export enum GetUserDetailsFeatures {
    AndroidDolbyVision = "Android - Dolby Vision",
    AndroidPiP = "Android - PiP",
    CUSunset = "CU Sunset",
    HRKEnableEUR = "HRK_enable_EUR",
    TREBLEShowFeatures = "TREBLE-show-features",
    AdCountdownTimer = "ad-countdown-timer",
    AdaptiveBitrate = "adaptive_bitrate",
    AmazonLoopDebug = "amazon-loop-debug",
    AvodAdAnalysis = "avod-ad-analysis",
    AvodNewMedia = "avod-new-media",
    BlacklistGetSignin = "blacklist_get_signin",
    ClientRadioStations = "client-radio-stations",
    CloudflareTurnstileRequired = "cloudflare-turnstile-required",
    Collections = "collections",
    CommentsAndRepliesPushNotifications = "comments_and_replies_push_notifications",
    CommunityAccessPlexTv = "community_access_plex_tv",
    CompanionsSonos = "companions_sonos",
    CustomHomeRemoval = "custom-home-removal",
    DisableHomeUserFriendships = "disable_home_user_friendships",
    DisableSharingFriendships = "disable_sharing_friendships",
    DrmSupport = "drm_support",
    ExcludeRestrictions = "exclude restrictions",
    FederatedAuth = "federated-auth",
    FriendRequestPushNotifications = "friend_request_push_notifications",
    GuidedUpgrade = "guided-upgrade",
    Home = "home",
    IncreasePasswordComplexity = "increase-password-complexity",
    Ios14PrivacyBanner = "ios14-privacy-banner",
    IterableNotificationTokens = "iterable-notification-tokens",
    KeepPaymentMethod = "keep-payment-method",
    KevinBacon = "kevin-bacon",
    KoreaConsent = "korea-consent",
    LeIsrgRootX1 = "le_isrg_root_x1",
    LetsEncrypt = "lets_encrypt",
    LightningDvrPivot = "lightning-dvr-pivot",
    LiveTvSupportIncompleteSegments = "live-tv-support-incomplete-segments",
    Livetv = "livetv",
    MetadataSearch = "metadata_search",
    NewPlexPassPrices = "new_plex_pass_prices",
    NewsProviderSunsetModal = "news-provider-sunset-modal",
    PhotosFavorites = "photos-favorites",
    PhotosMetadataEdition = "photos-metadata-edition",
    PmsHealth = "pms_health",
    Radio = "radio",
    RateLimitClientToken = "rate-limit-client-token",
    ScrobblingServicePlexTv = "scrobbling-service-plex-tv",
    SharedServerNotification = "shared_server_notification",
    SharedSourceNotification = "shared_source_notification",
    SigninWithApple = "signin_with_apple",
    SpringServeAdProvider = "spring_serve_ad_provider",
    TranscoderCache = "transcoder_cache",
    TunerSharing = "tuner-sharing",
    TwoFactorAuthentication = "two-factor-authentication",
    Unsupportedtuners = "unsupportedtuners",
    Upgrade3ds2 = "upgrade-3ds2",
    VodSchema = "vod-schema",
    VodCloudflare = "vod_cloudflare",
    WatchTogetherInvite = "watch-together-invite",
    WebServerDashboard = "web_server_dashboard",
}

/**
 * String representation of subscriptionActive
 */
export enum GetUserDetailsAuthenticationResponseStatus {
    Inactive = "Inactive",
    Active = "Active",
}

export type GetUserDetailsSubscription = {
    /**
     * List of features allowed on your Plex Pass subscription
     */
    features?: Array<GetUserDetailsFeatures> | undefined;
    /**
     * If the account's Plex Pass subscription is active
     */
    active?: boolean | undefined;
    /**
     * Date the account subscribed to Plex Pass
     */
    subscribedAt?: string | null | undefined;
    /**
     * String representation of subscriptionActive
     */
    status?: GetUserDetailsAuthenticationResponseStatus | undefined;
    /**
     * Payment service used for your Plex Pass subscription
     */
    paymentService?: string | null | undefined;
    /**
     * Name of Plex Pass subscription plan
     */
    plan?: string | null | undefined;
};

/**
 * Logged in user details
 */
export type GetUserDetailsUserPlexAccount = {
    /**
     * Unknown
     */
    adsConsent: boolean | null;
    /**
     * Unknown
     */
    adsConsentReminderAt: Date | null;
    /**
     * Unknown
     */
    adsConsentSetAt: Date | null;
    /**
     * Unknown
     */
    anonymous?: boolean | null | undefined;
    /**
     * The account token
     */
    authToken: string;
    /**
     * If the two-factor authentication backup codes have been created
     */
    backupCodesCreated?: boolean | undefined;
    /**
     * If the account has been confirmed
     */
    confirmed?: boolean | undefined;
    /**
     * The account country
     */
    country: string;
    /**
     * The account email address
     */
    email: string;
    /**
     * If login with email only is enabled
     */
    emailOnlyAuth?: boolean | undefined;
    /**
     * If experimental features are enabled
     */
    experimentalFeatures?: boolean | undefined;
    /**
     * Your account full name
     */
    friendlyName: string;
    /**
     * List of devices your allowed to use with this account
     */
    entitlements: Array<string>;
    /**
     * If the account is a Plex Home guest user
     */
    guest?: boolean | undefined;
    /**
     * If the account has a password
     */
    hasPassword?: boolean | undefined;
    /**
     * If the account is a Plex Home user
     */
    home?: boolean | undefined;
    /**
     * If the account is the Plex Home admin
     */
    homeAdmin?: boolean | undefined;
    /**
     * The number of accounts in the Plex Home
     */
    homeSize: number;
    /**
     * The Plex account ID
     */
    id: number;
    /**
     * Unix epoch datetime the account joined Plex
     */
    joinedAt: number;
    /**
     * The account locale
     */
    locale: string | null;
    /**
     * If you are subscribed to the Plex newsletter
     */
    mailingListActive?: boolean | undefined;
    /**
     * Your current mailing list status
     */
    mailingListStatus: MailingListStatus;
    /**
     * The maximum number of accounts allowed in the Plex Home
     */
    maxHomeSize: number;
    /**
     * [Might be removed] The hashed Plex Home PIN
     *
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    pin?: string | undefined;
    profile: UserProfile;
    /**
     * If the account has a Plex Home PIN enabled
     */
    protected?: boolean | undefined;
    /**
     * Unix epoch datetime the authtoken expires
     */
    rememberExpiresAt: number;
    /**
     * If the account is a Plex Home managed user
     */
    restricted?: boolean | undefined;
    /**
     * [Might be removed] List of account roles. Plexpass membership listed here
     */
    roles?: Array<string> | undefined;
    /**
     * Unknown
     */
    scrobbleTypes: string;
    services: Array<Services>;
    /**
     * If the account’s Plex Pass subscription is active
     */
    subscription: Subscription;
    /**
     * Description of the Plex Pass subscription
     */
    subscriptionDescription: string | null;
    subscriptions: Array<GetUserDetailsSubscription>;
    /**
     * URL of the account thumbnail
     */
    thumb: string;
    /**
     * The title of the account (username or friendly name)
     */
    title: string;
    /**
     * If two-factor authentication is enabled
     */
    twoFactorEnabled?: boolean | undefined;
    /**
     * The account username
     */
    username: string;
    /**
     * The account UUID
     */
    uuid: string;
};

export type GetUserDetailsResponse = {
    /**
     * HTTP response content type for this operation
     */
    contentType: string;
    /**
     * HTTP response status code for this operation
     */
    statusCode: number;
    /**
     * Raw HTTP response; suitable for custom response parsing
     */
    rawResponse: Response;
    /**
     * Logged in user details
     */
    userPlexAccount?: GetUserDetailsUserPlexAccount | undefined;
};

/** @internal */
export const GetUserDetailsRequest$inboundSchema: z.ZodType<
    GetUserDetailsRequest,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        "X-Plex-Token": z.string(),
    })
    .transform((v) => {
        return remap$(v, {
            "X-Plex-Token": "xPlexToken",
        });
    });

/** @internal */
export type GetUserDetailsRequest$Outbound = {
    "X-Plex-Token": string;
};

/** @internal */
export const GetUserDetailsRequest$outboundSchema: z.ZodType<
    GetUserDetailsRequest$Outbound,
    z.ZodTypeDef,
    GetUserDetailsRequest
> = z
    .object({
        xPlexToken: z.string(),
    })
    .transform((v) => {
        return remap$(v, {
            xPlexToken: "X-Plex-Token",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsRequest$ {
    /** @deprecated use `GetUserDetailsRequest$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsRequest$inboundSchema;
    /** @deprecated use `GetUserDetailsRequest$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsRequest$outboundSchema;
    /** @deprecated use `GetUserDetailsRequest$Outbound` instead. */
    export type Outbound = GetUserDetailsRequest$Outbound;
}

/** @internal */
export const MailingListStatus$inboundSchema: z.ZodNativeEnum<typeof MailingListStatus> =
    z.nativeEnum(MailingListStatus);

/** @internal */
export const MailingListStatus$outboundSchema: z.ZodNativeEnum<typeof MailingListStatus> =
    MailingListStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MailingListStatus$ {
    /** @deprecated use `MailingListStatus$inboundSchema` instead. */
    export const inboundSchema = MailingListStatus$inboundSchema;
    /** @deprecated use `MailingListStatus$outboundSchema` instead. */
    export const outboundSchema = MailingListStatus$outboundSchema;
}

/** @internal */
export const AutoSelectSubtitle$inboundSchema: z.ZodNativeEnum<typeof AutoSelectSubtitle> =
    z.nativeEnum(AutoSelectSubtitle);

/** @internal */
export const AutoSelectSubtitle$outboundSchema: z.ZodNativeEnum<typeof AutoSelectSubtitle> =
    AutoSelectSubtitle$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AutoSelectSubtitle$ {
    /** @deprecated use `AutoSelectSubtitle$inboundSchema` instead. */
    export const inboundSchema = AutoSelectSubtitle$inboundSchema;
    /** @deprecated use `AutoSelectSubtitle$outboundSchema` instead. */
    export const outboundSchema = AutoSelectSubtitle$outboundSchema;
}

/** @internal */
export const DefaultSubtitleAccessibility$inboundSchema: z.ZodNativeEnum<
    typeof DefaultSubtitleAccessibility
> = z.nativeEnum(DefaultSubtitleAccessibility);

/** @internal */
export const DefaultSubtitleAccessibility$outboundSchema: z.ZodNativeEnum<
    typeof DefaultSubtitleAccessibility
> = DefaultSubtitleAccessibility$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultSubtitleAccessibility$ {
    /** @deprecated use `DefaultSubtitleAccessibility$inboundSchema` instead. */
    export const inboundSchema = DefaultSubtitleAccessibility$inboundSchema;
    /** @deprecated use `DefaultSubtitleAccessibility$outboundSchema` instead. */
    export const outboundSchema = DefaultSubtitleAccessibility$outboundSchema;
}

/** @internal */
export const DefaultSubtitleForced$inboundSchema: z.ZodNativeEnum<typeof DefaultSubtitleForced> =
    z.nativeEnum(DefaultSubtitleForced);

/** @internal */
export const DefaultSubtitleForced$outboundSchema: z.ZodNativeEnum<typeof DefaultSubtitleForced> =
    DefaultSubtitleForced$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultSubtitleForced$ {
    /** @deprecated use `DefaultSubtitleForced$inboundSchema` instead. */
    export const inboundSchema = DefaultSubtitleForced$inboundSchema;
    /** @deprecated use `DefaultSubtitleForced$outboundSchema` instead. */
    export const outboundSchema = DefaultSubtitleForced$outboundSchema;
}

/** @internal */
export const WatchedIndicator$inboundSchema: z.ZodNativeEnum<typeof WatchedIndicator> =
    z.nativeEnum(WatchedIndicator);

/** @internal */
export const WatchedIndicator$outboundSchema: z.ZodNativeEnum<typeof WatchedIndicator> =
    WatchedIndicator$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WatchedIndicator$ {
    /** @deprecated use `WatchedIndicator$inboundSchema` instead. */
    export const inboundSchema = WatchedIndicator$inboundSchema;
    /** @deprecated use `WatchedIndicator$outboundSchema` instead. */
    export const outboundSchema = WatchedIndicator$outboundSchema;
}

/** @internal */
export const MediaReviewsVisibility$inboundSchema: z.ZodNativeEnum<typeof MediaReviewsVisibility> =
    z.nativeEnum(MediaReviewsVisibility);

/** @internal */
export const MediaReviewsVisibility$outboundSchema: z.ZodNativeEnum<typeof MediaReviewsVisibility> =
    MediaReviewsVisibility$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaReviewsVisibility$ {
    /** @deprecated use `MediaReviewsVisibility$inboundSchema` instead. */
    export const inboundSchema = MediaReviewsVisibility$inboundSchema;
    /** @deprecated use `MediaReviewsVisibility$outboundSchema` instead. */
    export const outboundSchema = MediaReviewsVisibility$outboundSchema;
}

/** @internal */
export const UserProfile$inboundSchema: z.ZodType<UserProfile, z.ZodTypeDef, unknown> = z.object({
    autoSelectAudio: z.boolean().default(true),
    defaultAudioLanguage: z.nullable(z.string()),
    defaultSubtitleLanguage: z.nullable(z.string()),
    autoSelectSubtitle: AutoSelectSubtitle$inboundSchema.optional(),
    defaultSubtitleAccessibility: DefaultSubtitleAccessibility$inboundSchema.optional(),
    defaultSubtitleForced: DefaultSubtitleForced$inboundSchema.optional(),
    watchedIndicator: WatchedIndicator$inboundSchema.optional(),
    mediaReviewsVisibility: MediaReviewsVisibility$inboundSchema.optional(),
});

/** @internal */
export type UserProfile$Outbound = {
    autoSelectAudio: boolean;
    defaultAudioLanguage: string | null;
    defaultSubtitleLanguage: string | null;
    autoSelectSubtitle?: string | undefined;
    defaultSubtitleAccessibility?: string | undefined;
    defaultSubtitleForced?: string | undefined;
    watchedIndicator?: string | undefined;
    mediaReviewsVisibility?: number | undefined;
};

/** @internal */
export const UserProfile$outboundSchema: z.ZodType<
    UserProfile$Outbound,
    z.ZodTypeDef,
    UserProfile
> = z.object({
    autoSelectAudio: z.boolean().default(true),
    defaultAudioLanguage: z.nullable(z.string()),
    defaultSubtitleLanguage: z.nullable(z.string()),
    autoSelectSubtitle: AutoSelectSubtitle$outboundSchema.optional(),
    defaultSubtitleAccessibility: DefaultSubtitleAccessibility$outboundSchema.optional(),
    defaultSubtitleForced: DefaultSubtitleForced$outboundSchema.optional(),
    watchedIndicator: WatchedIndicator$outboundSchema.optional(),
    mediaReviewsVisibility: MediaReviewsVisibility$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserProfile$ {
    /** @deprecated use `UserProfile$inboundSchema` instead. */
    export const inboundSchema = UserProfile$inboundSchema;
    /** @deprecated use `UserProfile$outboundSchema` instead. */
    export const outboundSchema = UserProfile$outboundSchema;
    /** @deprecated use `UserProfile$Outbound` instead. */
    export type Outbound = UserProfile$Outbound;
}

/** @internal */
export const GetUserDetailsStatus$inboundSchema: z.ZodNativeEnum<typeof GetUserDetailsStatus> =
    z.nativeEnum(GetUserDetailsStatus);

/** @internal */
export const GetUserDetailsStatus$outboundSchema: z.ZodNativeEnum<typeof GetUserDetailsStatus> =
    GetUserDetailsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsStatus$ {
    /** @deprecated use `GetUserDetailsStatus$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsStatus$inboundSchema;
    /** @deprecated use `GetUserDetailsStatus$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsStatus$outboundSchema;
}

/** @internal */
export const Services$inboundSchema: z.ZodType<Services, z.ZodTypeDef, unknown> = z.object({
    identifier: z.string(),
    endpoint: z.string(),
    token: z.nullable(z.string()),
    secret: z.nullable(z.string()),
    status: GetUserDetailsStatus$inboundSchema,
});

/** @internal */
export type Services$Outbound = {
    identifier: string;
    endpoint: string;
    token: string | null;
    secret: string | null;
    status: string;
};

/** @internal */
export const Services$outboundSchema: z.ZodType<Services$Outbound, z.ZodTypeDef, Services> =
    z.object({
        identifier: z.string(),
        endpoint: z.string(),
        token: z.nullable(z.string()),
        secret: z.nullable(z.string()),
        status: GetUserDetailsStatus$outboundSchema,
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Services$ {
    /** @deprecated use `Services$inboundSchema` instead. */
    export const inboundSchema = Services$inboundSchema;
    /** @deprecated use `Services$outboundSchema` instead. */
    export const outboundSchema = Services$outboundSchema;
    /** @deprecated use `Services$Outbound` instead. */
    export type Outbound = Services$Outbound;
}

/** @internal */
export const Features$inboundSchema: z.ZodNativeEnum<typeof Features> = z.nativeEnum(Features);

/** @internal */
export const Features$outboundSchema: z.ZodNativeEnum<typeof Features> = Features$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Features$ {
    /** @deprecated use `Features$inboundSchema` instead. */
    export const inboundSchema = Features$inboundSchema;
    /** @deprecated use `Features$outboundSchema` instead. */
    export const outboundSchema = Features$outboundSchema;
}

/** @internal */
export const GetUserDetailsAuthenticationStatus$inboundSchema: z.ZodNativeEnum<
    typeof GetUserDetailsAuthenticationStatus
> = z.nativeEnum(GetUserDetailsAuthenticationStatus);

/** @internal */
export const GetUserDetailsAuthenticationStatus$outboundSchema: z.ZodNativeEnum<
    typeof GetUserDetailsAuthenticationStatus
> = GetUserDetailsAuthenticationStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsAuthenticationStatus$ {
    /** @deprecated use `GetUserDetailsAuthenticationStatus$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsAuthenticationStatus$inboundSchema;
    /** @deprecated use `GetUserDetailsAuthenticationStatus$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsAuthenticationStatus$outboundSchema;
}

/** @internal */
export const Subscription$inboundSchema: z.ZodType<Subscription, z.ZodTypeDef, unknown> = z.object({
    features: z.array(Features$inboundSchema).optional(),
    active: z.boolean().optional(),
    subscribedAt: z.nullable(z.string()).optional(),
    status: GetUserDetailsAuthenticationStatus$inboundSchema.optional(),
    paymentService: z.nullable(z.string()).optional(),
    plan: z.nullable(z.string()).optional(),
});

/** @internal */
export type Subscription$Outbound = {
    features?: Array<string> | undefined;
    active?: boolean | undefined;
    subscribedAt?: string | null | undefined;
    status?: string | undefined;
    paymentService?: string | null | undefined;
    plan?: string | null | undefined;
};

/** @internal */
export const Subscription$outboundSchema: z.ZodType<
    Subscription$Outbound,
    z.ZodTypeDef,
    Subscription
> = z.object({
    features: z.array(Features$outboundSchema).optional(),
    active: z.boolean().optional(),
    subscribedAt: z.nullable(z.string()).optional(),
    status: GetUserDetailsAuthenticationStatus$outboundSchema.optional(),
    paymentService: z.nullable(z.string()).optional(),
    plan: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Subscription$ {
    /** @deprecated use `Subscription$inboundSchema` instead. */
    export const inboundSchema = Subscription$inboundSchema;
    /** @deprecated use `Subscription$outboundSchema` instead. */
    export const outboundSchema = Subscription$outboundSchema;
    /** @deprecated use `Subscription$Outbound` instead. */
    export type Outbound = Subscription$Outbound;
}

/** @internal */
export const GetUserDetailsFeatures$inboundSchema: z.ZodNativeEnum<typeof GetUserDetailsFeatures> =
    z.nativeEnum(GetUserDetailsFeatures);

/** @internal */
export const GetUserDetailsFeatures$outboundSchema: z.ZodNativeEnum<typeof GetUserDetailsFeatures> =
    GetUserDetailsFeatures$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsFeatures$ {
    /** @deprecated use `GetUserDetailsFeatures$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsFeatures$inboundSchema;
    /** @deprecated use `GetUserDetailsFeatures$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsFeatures$outboundSchema;
}

/** @internal */
export const GetUserDetailsAuthenticationResponseStatus$inboundSchema: z.ZodNativeEnum<
    typeof GetUserDetailsAuthenticationResponseStatus
> = z.nativeEnum(GetUserDetailsAuthenticationResponseStatus);

/** @internal */
export const GetUserDetailsAuthenticationResponseStatus$outboundSchema: z.ZodNativeEnum<
    typeof GetUserDetailsAuthenticationResponseStatus
> = GetUserDetailsAuthenticationResponseStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsAuthenticationResponseStatus$ {
    /** @deprecated use `GetUserDetailsAuthenticationResponseStatus$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsAuthenticationResponseStatus$inboundSchema;
    /** @deprecated use `GetUserDetailsAuthenticationResponseStatus$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsAuthenticationResponseStatus$outboundSchema;
}

/** @internal */
export const GetUserDetailsSubscription$inboundSchema: z.ZodType<
    GetUserDetailsSubscription,
    z.ZodTypeDef,
    unknown
> = z.object({
    features: z.array(GetUserDetailsFeatures$inboundSchema).optional(),
    active: z.boolean().optional(),
    subscribedAt: z.nullable(z.string()).optional(),
    status: GetUserDetailsAuthenticationResponseStatus$inboundSchema.optional(),
    paymentService: z.nullable(z.string()).optional(),
    plan: z.nullable(z.string()).optional(),
});

/** @internal */
export type GetUserDetailsSubscription$Outbound = {
    features?: Array<string> | undefined;
    active?: boolean | undefined;
    subscribedAt?: string | null | undefined;
    status?: string | undefined;
    paymentService?: string | null | undefined;
    plan?: string | null | undefined;
};

/** @internal */
export const GetUserDetailsSubscription$outboundSchema: z.ZodType<
    GetUserDetailsSubscription$Outbound,
    z.ZodTypeDef,
    GetUserDetailsSubscription
> = z.object({
    features: z.array(GetUserDetailsFeatures$outboundSchema).optional(),
    active: z.boolean().optional(),
    subscribedAt: z.nullable(z.string()).optional(),
    status: GetUserDetailsAuthenticationResponseStatus$outboundSchema.optional(),
    paymentService: z.nullable(z.string()).optional(),
    plan: z.nullable(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsSubscription$ {
    /** @deprecated use `GetUserDetailsSubscription$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsSubscription$inboundSchema;
    /** @deprecated use `GetUserDetailsSubscription$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsSubscription$outboundSchema;
    /** @deprecated use `GetUserDetailsSubscription$Outbound` instead. */
    export type Outbound = GetUserDetailsSubscription$Outbound;
}

/** @internal */
export const GetUserDetailsUserPlexAccount$inboundSchema: z.ZodType<
    GetUserDetailsUserPlexAccount,
    z.ZodTypeDef,
    unknown
> = z.object({
    adsConsent: z.nullable(z.boolean()),
    adsConsentReminderAt: z.nullable(
        z
            .string()
            .datetime({ offset: true })
            .transform((v) => new Date(v))
    ),
    adsConsentSetAt: z.nullable(
        z
            .string()
            .datetime({ offset: true })
            .transform((v) => new Date(v))
    ),
    anonymous: z.nullable(z.boolean().default(false)),
    authToken: z.string(),
    backupCodesCreated: z.boolean().default(false),
    confirmed: z.boolean().default(false),
    country: z.string(),
    email: z.string(),
    emailOnlyAuth: z.boolean().default(false),
    experimentalFeatures: z.boolean().default(false),
    friendlyName: z.string(),
    entitlements: z.array(z.string()),
    guest: z.boolean().default(false),
    hasPassword: z.boolean().default(true),
    home: z.boolean().default(false),
    homeAdmin: z.boolean().default(false),
    homeSize: z.number().int(),
    id: z.number().int(),
    joinedAt: z.number().int(),
    locale: z.nullable(z.string()),
    mailingListActive: z.boolean().default(false),
    mailingListStatus: MailingListStatus$inboundSchema,
    maxHomeSize: z.number().int(),
    pin: z.string().optional(),
    profile: z.lazy(() => UserProfile$inboundSchema),
    protected: z.boolean().default(false),
    rememberExpiresAt: z.number().int(),
    restricted: z.boolean().default(false),
    roles: z.array(z.string()).optional(),
    scrobbleTypes: z.string(),
    services: z.array(z.lazy(() => Services$inboundSchema)),
    subscription: z.lazy(() => Subscription$inboundSchema),
    subscriptionDescription: z.nullable(z.string()),
    subscriptions: z.array(z.lazy(() => GetUserDetailsSubscription$inboundSchema)),
    thumb: z.string(),
    title: z.string(),
    twoFactorEnabled: z.boolean().default(false),
    username: z.string(),
    uuid: z.string(),
});

/** @internal */
export type GetUserDetailsUserPlexAccount$Outbound = {
    adsConsent: boolean | null;
    adsConsentReminderAt: string | null;
    adsConsentSetAt: string | null;
    anonymous: boolean | null;
    authToken: string;
    backupCodesCreated: boolean;
    confirmed: boolean;
    country: string;
    email: string;
    emailOnlyAuth: boolean;
    experimentalFeatures: boolean;
    friendlyName: string;
    entitlements: Array<string>;
    guest: boolean;
    hasPassword: boolean;
    home: boolean;
    homeAdmin: boolean;
    homeSize: number;
    id: number;
    joinedAt: number;
    locale: string | null;
    mailingListActive: boolean;
    mailingListStatus: string;
    maxHomeSize: number;
    pin?: string | undefined;
    profile: UserProfile$Outbound;
    protected: boolean;
    rememberExpiresAt: number;
    restricted: boolean;
    roles?: Array<string> | undefined;
    scrobbleTypes: string;
    services: Array<Services$Outbound>;
    subscription: Subscription$Outbound;
    subscriptionDescription: string | null;
    subscriptions: Array<GetUserDetailsSubscription$Outbound>;
    thumb: string;
    title: string;
    twoFactorEnabled: boolean;
    username: string;
    uuid: string;
};

/** @internal */
export const GetUserDetailsUserPlexAccount$outboundSchema: z.ZodType<
    GetUserDetailsUserPlexAccount$Outbound,
    z.ZodTypeDef,
    GetUserDetailsUserPlexAccount
> = z.object({
    adsConsent: z.nullable(z.boolean()),
    adsConsentReminderAt: z.nullable(z.date().transform((v) => v.toISOString())),
    adsConsentSetAt: z.nullable(z.date().transform((v) => v.toISOString())),
    anonymous: z.nullable(z.boolean().default(false)),
    authToken: z.string(),
    backupCodesCreated: z.boolean().default(false),
    confirmed: z.boolean().default(false),
    country: z.string(),
    email: z.string(),
    emailOnlyAuth: z.boolean().default(false),
    experimentalFeatures: z.boolean().default(false),
    friendlyName: z.string(),
    entitlements: z.array(z.string()),
    guest: z.boolean().default(false),
    hasPassword: z.boolean().default(true),
    home: z.boolean().default(false),
    homeAdmin: z.boolean().default(false),
    homeSize: z.number().int(),
    id: z.number().int(),
    joinedAt: z.number().int(),
    locale: z.nullable(z.string()),
    mailingListActive: z.boolean().default(false),
    mailingListStatus: MailingListStatus$outboundSchema,
    maxHomeSize: z.number().int(),
    pin: z.string().optional(),
    profile: z.lazy(() => UserProfile$outboundSchema),
    protected: z.boolean().default(false),
    rememberExpiresAt: z.number().int(),
    restricted: z.boolean().default(false),
    roles: z.array(z.string()).optional(),
    scrobbleTypes: z.string(),
    services: z.array(z.lazy(() => Services$outboundSchema)),
    subscription: z.lazy(() => Subscription$outboundSchema),
    subscriptionDescription: z.nullable(z.string()),
    subscriptions: z.array(z.lazy(() => GetUserDetailsSubscription$outboundSchema)),
    thumb: z.string(),
    title: z.string(),
    twoFactorEnabled: z.boolean().default(false),
    username: z.string(),
    uuid: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsUserPlexAccount$ {
    /** @deprecated use `GetUserDetailsUserPlexAccount$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsUserPlexAccount$inboundSchema;
    /** @deprecated use `GetUserDetailsUserPlexAccount$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsUserPlexAccount$outboundSchema;
    /** @deprecated use `GetUserDetailsUserPlexAccount$Outbound` instead. */
    export type Outbound = GetUserDetailsUserPlexAccount$Outbound;
}

/** @internal */
export const GetUserDetailsResponse$inboundSchema: z.ZodType<
    GetUserDetailsResponse,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        ContentType: z.string(),
        StatusCode: z.number().int(),
        RawResponse: z.instanceof(Response),
        UserPlexAccount: z.lazy(() => GetUserDetailsUserPlexAccount$inboundSchema).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            ContentType: "contentType",
            StatusCode: "statusCode",
            RawResponse: "rawResponse",
            UserPlexAccount: "userPlexAccount",
        });
    });

/** @internal */
export type GetUserDetailsResponse$Outbound = {
    ContentType: string;
    StatusCode: number;
    RawResponse: never;
    UserPlexAccount?: GetUserDetailsUserPlexAccount$Outbound | undefined;
};

/** @internal */
export const GetUserDetailsResponse$outboundSchema: z.ZodType<
    GetUserDetailsResponse$Outbound,
    z.ZodTypeDef,
    GetUserDetailsResponse
> = z
    .object({
        contentType: z.string(),
        statusCode: z.number().int(),
        rawResponse: z.instanceof(Response).transform(() => {
            throw new Error("Response cannot be serialized");
        }),
        userPlexAccount: z.lazy(() => GetUserDetailsUserPlexAccount$outboundSchema).optional(),
    })
    .transform((v) => {
        return remap$(v, {
            contentType: "ContentType",
            statusCode: "StatusCode",
            rawResponse: "RawResponse",
            userPlexAccount: "UserPlexAccount",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetUserDetailsResponse$ {
    /** @deprecated use `GetUserDetailsResponse$inboundSchema` instead. */
    export const inboundSchema = GetUserDetailsResponse$inboundSchema;
    /** @deprecated use `GetUserDetailsResponse$outboundSchema` instead. */
    export const outboundSchema = GetUserDetailsResponse$outboundSchema;
    /** @deprecated use `GetUserDetailsResponse$Outbound` instead. */
    export type Outbound = GetUserDetailsResponse$Outbound;
}
