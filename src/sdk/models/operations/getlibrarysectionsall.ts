/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { RFCDate } from "../../types/rfcdate.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The type of media to retrieve or filter by.
 *
 * @remarks
 * 1 = movie
 * 2 = show
 * 3 = season
 * 4 = episode
 * E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries
 */
export enum GetLibrarySectionsAllQueryParamType {
  Movie = 1,
  TvShow = 2,
  Season = 3,
  Episode = 4,
  Artist = 5,
  Album = 6,
  Track = 7,
  PhotoAlbum = 8,
  Photo = 9,
}
/**
 * The type of media to retrieve or filter by.
 *
 * @remarks
 * 1 = movie
 * 2 = show
 * 3 = season
 * 4 = episode
 * E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries
 */
export type GetLibrarySectionsAllQueryParamTypeOpen = OpenEnum<
  typeof GetLibrarySectionsAllQueryParamType
>;

/**
 * Adds the Meta object to the response
 *
 * @remarks
 */
export enum GetLibrarySectionsAllQueryParamIncludeMeta {
  Disable = 0,
  Enable = 1,
}

/**
 * Adds the Guid object to the response
 *
 * @remarks
 */
export enum QueryParamIncludeGuids {
  Disable = 0,
  Enable = 1,
}

export enum IncludeAdvanced {
  Disable = 0,
  Enable = 1,
}

export enum QueryParamIncludeCollections {
  Disable = 0,
  Enable = 1,
}

export enum QueryParamIncludeExternalMedia {
  Disable = 0,
  Enable = 1,
}

export type GetLibrarySectionsAllRequest = {
  /**
   * The unique key of the Plex library.
   *
   * @remarks
   * Note: This is unique in the context of the Plex server.
   */
  sectionKey: number;
  /**
   * The type of media to retrieve or filter by.
   *
   * @remarks
   * 1 = movie
   * 2 = show
   * 3 = season
   * 4 = episode
   * E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries
   */
  type: GetLibrarySectionsAllQueryParamTypeOpen;
  /**
   * Adds the Meta object to the response
   *
   * @remarks
   */
  includeMeta?: GetLibrarySectionsAllQueryParamIncludeMeta | undefined;
  /**
   * Adds the Guid object to the response
   *
   * @remarks
   */
  includeGuids?: QueryParamIncludeGuids | undefined;
  includeAdvanced?: IncludeAdvanced | undefined;
  includeCollections?: QueryParamIncludeCollections | undefined;
  includeExternalMedia?: QueryParamIncludeExternalMedia | undefined;
  /**
   * The index of the first item to return. If not specified, the first item will be returned.
   *
   * @remarks
   * If the number of items exceeds the limit, the response will be paginated.
   * By default this is 0
   */
  xPlexContainerStart?: number | undefined;
  /**
   * The number of items to return. If not specified, all items will be returned.
   *
   * @remarks
   * If the number of items exceeds the limit, the response will be paginated.
   * By default this is 50
   */
  xPlexContainerSize?: number | undefined;
};

export type GetLibrarySectionsAllFilter = {
  filter: string;
  filterType: string;
  key: string;
  title: string;
  type: string;
  advanced?: boolean | undefined;
};

/**
 * The direction of the sort. Can be either `asc` or `desc`.
 *
 * @remarks
 */
export enum GetLibrarySectionsAllActiveDirection {
  Ascending = "asc",
  Descending = "desc",
}

/**
 * The direction of the sort. Can be either `asc` or `desc`.
 *
 * @remarks
 */
export enum GetLibrarySectionsAllDefaultDirection {
  Ascending = "asc",
  Descending = "desc",
}

export type GetLibrarySectionsAllSort = {
  default?: string | undefined;
  active?: boolean | undefined;
  /**
   * The direction of the sort. Can be either `asc` or `desc`.
   *
   * @remarks
   */
  activeDirection?: GetLibrarySectionsAllActiveDirection | undefined;
  /**
   * The direction of the sort. Can be either `asc` or `desc`.
   *
   * @remarks
   */
  defaultDirection?: GetLibrarySectionsAllDefaultDirection | undefined;
  descKey?: string | undefined;
  firstCharacterKey?: string | undefined;
  key: string;
  title: string;
};

export type GetLibrarySectionsAllField = {
  key: string;
  title: string;
  type: string;
  subType?: string | undefined;
};

export type GetLibrarySectionsAllType = {
  key: string;
  type: string;
  subtype?: string | undefined;
  title: string;
  active: boolean;
  filter?: Array<GetLibrarySectionsAllFilter> | undefined;
  sort?: Array<GetLibrarySectionsAllSort> | undefined;
  field?: Array<GetLibrarySectionsAllField> | undefined;
};

export type GetLibrarySectionsAllOperator = {
  key: string;
  title: string;
};

export type GetLibrarySectionsAllFieldType = {
  type: string;
  operator: Array<GetLibrarySectionsAllOperator>;
};

/**
 * The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.
 *
 * @remarks
 */
export type GetLibrarySectionsAllMeta = {
  type?: Array<GetLibrarySectionsAllType> | undefined;
  fieldType?: Array<GetLibrarySectionsAllFieldType> | undefined;
};

/**
 * The type of media content in the Plex library. This can represent videos, music, or photos.
 *
 * @remarks
 */
export enum GetLibrarySectionsAllLibraryType {
  Movie = "movie",
  TvShow = "show",
  Season = "season",
  Episode = "episode",
  Artist = "artist",
  Album = "album",
  Track = "track",
  PhotoAlbum = "photoalbum",
  Photo = "photo",
  Collection = "collection",
}
/**
 * The type of media content in the Plex library. This can represent videos, music, or photos.
 *
 * @remarks
 */
export type GetLibrarySectionsAllLibraryTypeOpen = OpenEnum<
  typeof GetLibrarySectionsAllLibraryType
>;

export enum GetLibrarySectionsAllLibraryResponseType {
  CoverPoster = "coverPoster",
  Background = "background",
  Snapshot = "snapshot",
  ClearLogo = "clearLogo",
}
export type GetLibrarySectionsAllLibraryResponseTypeOpen = OpenEnum<
  typeof GetLibrarySectionsAllLibraryResponseType
>;

export type GetLibrarySectionsAllImage = {
  alt: string;
  type: GetLibrarySectionsAllLibraryResponseTypeOpen;
  url: string;
};

export type GetLibrarySectionsAllUltraBlurColors = {
  topLeft: string;
  topRight: string;
  bottomRight: string;
  bottomLeft: string;
};

export type GetLibrarySectionsAllGuids = {
  /**
   * The unique identifier for the Guid. Can be prefixed with imdb://, tmdb://, tvdb://
   *
   * @remarks
   */
  id: string;
};

export enum OptimizedForStreaming1 {
  Zero = 0,
  One = 1,
}

/**
 * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
 */
export type GetLibrarySectionsAllOptimizedForStreaming =
  | OptimizedForStreaming1
  | boolean;

export enum GetLibrarySectionsAllOptimizedForStreaming1 {
  Zero = 0,
  One = 1,
}

/**
 * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
 */
export type GetLibrarySectionsAllLibraryOptimizedForStreaming =
  | GetLibrarySectionsAllOptimizedForStreaming1
  | boolean;

/**
 * Indicates if the part has a thumbnail.
 */
export enum GetLibrarySectionsAllHasThumbnail {
  False = "0",
  True = "1",
}

/**
 * Stream type:
 *
 * @remarks
 *   - 1 = video
 *   - 2 = audio
 *   - 3 = subtitle
 */
export enum GetLibrarySectionsAllStreamType {
  Video = 1,
  Audio = 2,
  Subtitle = 3,
}
/**
 * Stream type:
 *
 * @remarks
 *   - 1 = video
 *   - 2 = audio
 *   - 3 = subtitle
 */
export type GetLibrarySectionsAllStreamTypeOpen = OpenEnum<
  typeof GetLibrarySectionsAllStreamType
>;

export type GetLibrarySectionsAllStream = {
  /**
   * Unique stream identifier.
   */
  id: number;
  /**
   * Stream type:
   *
   * @remarks
   *   - 1 = video
   *   - 2 = audio
   *   - 3 = subtitle
   */
  streamType: GetLibrarySectionsAllStreamTypeOpen;
  /**
   * Format of the stream (e.g., srt).
   */
  format?: string | undefined;
  /**
   * Indicates if this stream is default.
   */
  default?: boolean | undefined;
  /**
   * Codec used by the stream.
   */
  codec: string;
  /**
   * Index of the stream.
   */
  index?: number | undefined;
  /**
   * Bitrate of the stream.
   */
  bitrate?: number | undefined;
  /**
   * Language of the stream.
   */
  language?: string | undefined;
  /**
   * Language tag (e.g., en).
   */
  languageTag?: string | undefined;
  /**
   * ISO language code.
   */
  languageCode?: string | undefined;
  /**
   * Indicates whether header compression is enabled.
   */
  headerCompression?: boolean | undefined;
  /**
   * Dolby Vision BL compatibility ID.
   */
  doviblCompatID?: number | undefined;
  /**
   * Indicates if Dolby Vision BL is present.
   */
  doviblPresent?: boolean | undefined;
  /**
   * Indicates if Dolby Vision EL is present.
   */
  dovielPresent?: boolean | undefined;
  /**
   * Dolby Vision level.
   */
  doviLevel?: number | undefined;
  /**
   * Indicates if Dolby Vision is present.
   */
  doviPresent?: boolean | undefined;
  /**
   * Dolby Vision profile.
   */
  doviProfile?: number | undefined;
  /**
   * Indicates if Dolby Vision RPU is present.
   */
  dovirpuPresent?: boolean | undefined;
  /**
   * Dolby Vision version.
   */
  doviVersion?: string | undefined;
  /**
   * Bit depth of the video stream.
   */
  bitDepth?: number | undefined;
  /**
   * Chroma sample location.
   */
  chromaLocation?: string | undefined;
  /**
   * Chroma subsampling format.
   */
  chromaSubsampling?: string | undefined;
  /**
   * Coded video height.
   */
  codedHeight?: number | undefined;
  /**
   * Coded video width.
   */
  codedWidth?: number | undefined;
  closedCaptions?: boolean | undefined;
  /**
   * Color primaries used.
   */
  colorPrimaries?: string | undefined;
  /**
   * Color range (e.g., tv).
   */
  colorRange?: string | undefined;
  /**
   * Color space.
   */
  colorSpace?: string | undefined;
  /**
   * Color transfer characteristics.
   */
  colorTrc?: string | undefined;
  /**
   * Frame rate of the stream.
   */
  frameRate?: number | undefined;
  /**
   * Key to access this stream part.
   */
  key?: string | undefined;
  /**
   * Height of the video stream.
   */
  height?: number | undefined;
  /**
   * Video level.
   */
  level?: number | undefined;
  /**
   * Indicates if this is the original stream.
   */
  original?: boolean | undefined;
  hasScalingMatrix?: boolean | undefined;
  /**
   * Video profile.
   */
  profile?: string | undefined;
  scanType?: string | undefined;
  embeddedInVideo?: string | undefined;
  /**
   * Number of reference frames.
   */
  refFrames?: number | undefined;
  /**
   * Width of the video stream.
   */
  width?: number | undefined;
  /**
   * Display title for the stream.
   */
  displayTitle: string;
  /**
   * Extended display title for the stream.
   */
  extendedDisplayTitle: string;
  /**
   * Indicates if this stream is selected (applicable for audio streams).
   */
  selected?: boolean | undefined;
  forced?: boolean | undefined;
  /**
   * Number of audio channels (for audio streams).
   */
  channels?: number | undefined;
  /**
   * Audio channel layout.
   */
  audioChannelLayout?: string | undefined;
  /**
   * Sampling rate for the audio stream.
   */
  samplingRate?: number | undefined;
  /**
   * Indicates if the stream can auto-sync.
   */
  canAutoSync?: boolean | undefined;
  /**
   * Indicates if the stream is for the hearing impaired.
   */
  hearingImpaired?: boolean | undefined;
  /**
   * Indicates if the stream is a dub.
   */
  dub?: boolean | undefined;
  /**
   * Optional title for the stream (e.g., language variant).
   */
  title?: string | undefined;
};

export type GetLibrarySectionsAllPart = {
  /**
   * Indicates if the part is accessible.
   */
  accessible?: boolean | undefined;
  /**
   * Indicates if the part exists.
   */
  exists?: boolean | undefined;
  /**
   * Unique part identifier.
   */
  id: number;
  /**
   * Key to access this part.
   */
  key: string;
  indexes?: string | undefined;
  /**
   * Duration of the part in milliseconds.
   */
  duration?: number | undefined;
  /**
   * File path for the part.
   */
  file: string;
  /**
   * File size in bytes.
   */
  size: number;
  packetLength?: number | undefined;
  /**
   * Container format of the part.
   */
  container?: string | undefined;
  /**
   * Video profile for the part.
   */
  videoProfile?: string | undefined;
  /**
   * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
   */
  audioProfile?: string | undefined;
  has64bitOffsets?: boolean | undefined;
  /**
   * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
   */
  optimizedForStreaming?:
    | GetLibrarySectionsAllOptimizedForStreaming1
    | boolean
    | undefined;
  hasThumbnail?: GetLibrarySectionsAllHasThumbnail | undefined;
  /**
   * An array of streams for this part.
   */
  stream?: Array<GetLibrarySectionsAllStream> | undefined;
};

export type GetLibrarySectionsAllMedia = {
  /**
   * Unique media identifier.
   */
  id: number;
  /**
   * Duration of the media in milliseconds.
   */
  duration?: number | undefined;
  /**
   * Bitrate in bits per second.
   */
  bitrate?: number | undefined;
  /**
   * Video width in pixels.
   */
  width?: number | undefined;
  /**
   * Video height in pixels.
   */
  height?: number | undefined;
  /**
   * Aspect ratio of the video.
   */
  aspectRatio?: number | undefined;
  /**
   * Number of audio channels.
   */
  audioChannels?: number | undefined;
  displayOffset?: number | undefined;
  /**
   * Audio codec used.
   */
  audioCodec?: string | undefined;
  /**
   * Video codec used.
   */
  videoCodec?: string | undefined;
  /**
   * Video resolution (e.g., 4k).
   */
  videoResolution?: string | undefined;
  /**
   * File container type.
   */
  container?: string | undefined;
  /**
   * Frame rate of the video. Values found include NTSC, PAL, 24p
   *
   * @remarks
   */
  videoFrameRate?: string | undefined;
  /**
   * Video profile (e.g., main 10).
   */
  videoProfile?: string | undefined;
  /**
   * Indicates whether voice activity is detected.
   */
  hasVoiceActivity?: boolean | undefined;
  /**
   * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
   */
  audioProfile?: string | undefined;
  /**
   * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
   */
  optimizedForStreaming?: OptimizedForStreaming1 | boolean | undefined;
  has64bitOffsets?: boolean | undefined;
  /**
   * An array of parts for this media item.
   */
  part?: Array<GetLibrarySectionsAllPart> | undefined;
};

export type GetLibrarySectionsAllGenre = {
  /**
   * The genre name of this media-item
   *
   * @remarks
   */
  tag: string;
};

export type GetLibrarySectionsAllCountry = {
  /**
   * The country of origin of this media item
   */
  tag: string;
};

export type GetLibrarySectionsAllDirector = {
  /**
   * The role of Director
   */
  tag: string;
};

export type GetLibrarySectionsAllWriter = {
  /**
   * The role of Writer
   */
  tag: string;
};

export type GetLibrarySectionsAllRole = {
  /**
   * The display tag for the actor (typically the actor's name).
   */
  tag: string;
};

export type GetLibrarySectionsAllCollection = {
  /**
   * The user-made collection this media item belongs to
   */
  tag: string;
};

/**
 * Unknown
 *
 * @remarks
 */
export type GetLibrarySectionsAllMetadata = {
  /**
   * The rating key (Media ID) of this media item. Note: Although this is always an integer, it is represented as a string in the API.
   */
  ratingKey: string;
  /**
   * The unique key for the media item.
   */
  key: string;
  /**
   * The globally unique identifier for the media item.
   */
  guid: string;
  /**
   * A URL‚Äêfriendly version of the media title.
   */
  slug: string;
  /**
   * The studio that produced the media item.
   */
  studio?: string | undefined;
  type: GetLibrarySectionsAllLibraryTypeOpen;
  /**
   * The title of the media item.
   */
  title: string;
  /**
   * The sort title used for ordering media items.
   */
  titleSort: string;
  /**
   * The content rating for the media item.
   */
  contentRating?: string | undefined;
  /**
   * A synopsis of the media item.
   */
  summary: string;
  /**
   * The critic rating for the media item.
   */
  rating: number;
  /**
   * The audience rating for the media item.
   */
  audienceRating: number;
  /**
   * The release year of the media item.
   */
  year?: number | undefined;
  /**
   * A brief tagline for the media item.
   */
  tagline: string;
  /**
   * The thumbnail image URL for the media item.
   */
  thumb: string;
  /**
   * The art image URL for the media item.
   */
  art: string;
  /**
   * The theme URL for the media item.
   */
  theme: string;
  /**
   * The index position of the media item.
   */
  index: number;
  /**
   * The number of leaf items (end nodes) under this media item.
   */
  leafCount?: number | undefined;
  /**
   * The number of leaf items that have been viewed.
   */
  viewedLeafCount?: number | undefined;
  /**
   * The number of child items associated with this media item.
   */
  childCount: number;
  /**
   * The total number of seasons (for TV shows).
   */
  seasonCount: number;
  /**
   * The duration of the media item in milliseconds.
   */
  duration: number;
  /**
   * The original release date of the media item.
   */
  originallyAvailableAt: RFCDate;
  addedAt: number;
  /**
   * Unix epoch datetime in seconds
   */
  updatedAt?: number | undefined;
  /**
   * The URL for the audience rating image.
   */
  audienceRatingImage?: string | undefined;
  /**
   * The source from which chapter data is derived.
   */
  chapterSource?: string | undefined;
  /**
   * The primary extra key associated with this media item.
   */
  primaryExtraKey?: string | undefined;
  /**
   * The original title of the media item (if different).
   */
  originalTitle?: string | undefined;
  /**
   * The rating key of the parent media item.
   */
  parentRatingKey?: string | undefined;
  /**
   * The rating key of the grandparent media item.
   */
  grandparentRatingKey?: string | undefined;
  /**
   * The GUID of the parent media item.
   */
  parentGuid?: string | undefined;
  /**
   * The GUID of the grandparent media item.
   */
  grandparentGuid?: string | undefined;
  /**
   * The slug for the grandparent media item.
   */
  grandparentSlug?: string | undefined;
  /**
   * The key of the grandparent media item.
   */
  grandparentKey?: string | undefined;
  /**
   * The key of the parent media item.
   */
  parentKey?: string | undefined;
  /**
   * The title of the grandparent media item.
   */
  grandparentTitle?: string | undefined;
  /**
   * The thumbnail URL for the grandparent media item.
   */
  grandparentThumb?: string | undefined;
  /**
   * The theme URL for the grandparent media item.
   */
  grandparentTheme?: string | undefined;
  /**
   * The art URL for the grandparent media item.
   */
  grandparentArt?: string | undefined;
  /**
   * The title of the parent media item.
   */
  parentTitle?: string | undefined;
  /**
   * The index position of the parent media item.
   */
  parentIndex?: number | undefined;
  /**
   * The thumbnail URL for the parent media item.
   */
  parentThumb?: string | undefined;
  /**
   * The URL for the rating image.
   */
  ratingImage?: string | undefined;
  /**
   * The number of times this media item has been viewed.
   */
  viewCount?: number | undefined;
  /**
   * The current playback offset (in milliseconds).
   */
  viewOffset?: number | undefined;
  /**
   * The number of times this media item has been skipped.
   */
  skipCount?: number | undefined;
  /**
   * A classification that further describes the type of media item. For example, 'clip' indicates that the item is a short video clip.
   */
  subtype?: string | undefined;
  /**
   * The Unix timestamp representing the last time the item was rated.
   */
  lastRatedAt?: number | undefined;
  /**
   * The accuracy of the creation timestamp. This value indicates the format(s) provided (for example, 'epoch,local' means both epoch and local time formats are available).
   */
  createdAtAccuracy?: string | undefined;
  /**
   * The time zone offset for the creation timestamp, represented as a string. This offset indicates the difference from UTC.
   */
  createdAtTZOffset?: string | undefined;
  /**
   * Unix timestamp for when the media item was last viewed.
   */
  lastViewedAt?: number | undefined;
  /**
   * The rating provided by a user for the item. This value is expressed as a decimal number.
   */
  userRating?: number | undefined;
  image?: Array<GetLibrarySectionsAllImage> | undefined;
  ultraBlurColors?: GetLibrarySectionsAllUltraBlurColors | undefined;
  guids?: Array<GetLibrarySectionsAllGuids> | undefined;
  media?: Array<GetLibrarySectionsAllMedia> | undefined;
  genre?: Array<GetLibrarySectionsAllGenre> | undefined;
  country?: Array<GetLibrarySectionsAllCountry> | undefined;
  director?: Array<GetLibrarySectionsAllDirector> | undefined;
  writer?: Array<GetLibrarySectionsAllWriter> | undefined;
  role?: Array<GetLibrarySectionsAllRole> | undefined;
  collection?: Array<GetLibrarySectionsAllCollection> | undefined;
};

export type GetLibrarySectionsAllMediaContainer = {
  /**
   * Number of media items returned in this response.
   */
  size: number;
  /**
   * Total number of media items in the library.
   */
  totalSize: number;
  /**
   * Offset value for pagination.
   */
  offset: number;
  /**
   * Indicates whether syncing is allowed.
   */
  allowSync: boolean;
  /**
   * URL for the background artwork of the media container.
   */
  art: string;
  /**
   * The content type or mode.
   */
  content: string;
  /**
   * An plugin identifier for the media container.
   */
  identifier: string;
  /**
   * The unique identifier for the library section.
   */
  librarySectionID: number;
  /**
   * The title of the library section.
   */
  librarySectionTitle: string;
  /**
   * The universally unique identifier for the library section.
   */
  librarySectionUUID?: string | undefined;
  /**
   * The prefix used for media tag resource paths.
   */
  mediaTagPrefix: string;
  /**
   * The version number for media tags.
   */
  mediaTagVersion: number;
  /**
   * URL for the thumbnail image of the media container.
   */
  thumb: string;
  /**
   * Specifies whether caching is disabled.
   */
  nocache: boolean;
  /**
   * The primary title of the media container.
   */
  title1: string;
  /**
   * The secondary title of the media container.
   */
  title2: string;
  /**
   * Identifier for the view group layout.
   */
  viewGroup: string;
  /**
   * The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.
   *
   * @remarks
   */
  meta?: GetLibrarySectionsAllMeta | undefined;
  /**
   * An array of metadata items.
   */
  metadata?: Array<GetLibrarySectionsAllMetadata> | undefined;
};

/**
 * Successful response containing media container data.
 */
export type GetLibrarySectionsAllResponseBody = {
  mediaContainer?: GetLibrarySectionsAllMediaContainer | undefined;
};

export type GetLibrarySectionsAllResponse = {
  /**
   * HTTP response content type for this operation
   */
  contentType: string;
  /**
   * HTTP response status code for this operation
   */
  statusCode: number;
  /**
   * Raw HTTP response; suitable for custom response parsing
   */
  rawResponse: Response;
  /**
   * Successful response containing media container data.
   */
  object?: GetLibrarySectionsAllResponseBody | undefined;
};

/** @internal */
export const GetLibrarySectionsAllQueryParamType$inboundSchema: z.ZodType<
  GetLibrarySectionsAllQueryParamTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetLibrarySectionsAllQueryParamType),
    z.number().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetLibrarySectionsAllQueryParamType$outboundSchema: z.ZodType<
  GetLibrarySectionsAllQueryParamTypeOpen,
  z.ZodTypeDef,
  GetLibrarySectionsAllQueryParamTypeOpen
> = z.union([
  z.nativeEnum(GetLibrarySectionsAllQueryParamType),
  z.number().and(z.custom<Unrecognized<number>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllQueryParamType$ {
  /** @deprecated use `GetLibrarySectionsAllQueryParamType$inboundSchema` instead. */
  export const inboundSchema =
    GetLibrarySectionsAllQueryParamType$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllQueryParamType$outboundSchema` instead. */
  export const outboundSchema =
    GetLibrarySectionsAllQueryParamType$outboundSchema;
}

/** @internal */
export const GetLibrarySectionsAllQueryParamIncludeMeta$inboundSchema:
  z.ZodNativeEnum<typeof GetLibrarySectionsAllQueryParamIncludeMeta> = z
    .nativeEnum(GetLibrarySectionsAllQueryParamIncludeMeta);

/** @internal */
export const GetLibrarySectionsAllQueryParamIncludeMeta$outboundSchema:
  z.ZodNativeEnum<typeof GetLibrarySectionsAllQueryParamIncludeMeta> =
    GetLibrarySectionsAllQueryParamIncludeMeta$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllQueryParamIncludeMeta$ {
  /** @deprecated use `GetLibrarySectionsAllQueryParamIncludeMeta$inboundSchema` instead. */
  export const inboundSchema =
    GetLibrarySectionsAllQueryParamIncludeMeta$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllQueryParamIncludeMeta$outboundSchema` instead. */
  export const outboundSchema =
    GetLibrarySectionsAllQueryParamIncludeMeta$outboundSchema;
}

/** @internal */
export const QueryParamIncludeGuids$inboundSchema: z.ZodNativeEnum<
  typeof QueryParamIncludeGuids
> = z.nativeEnum(QueryParamIncludeGuids);

/** @internal */
export const QueryParamIncludeGuids$outboundSchema: z.ZodNativeEnum<
  typeof QueryParamIncludeGuids
> = QueryParamIncludeGuids$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueryParamIncludeGuids$ {
  /** @deprecated use `QueryParamIncludeGuids$inboundSchema` instead. */
  export const inboundSchema = QueryParamIncludeGuids$inboundSchema;
  /** @deprecated use `QueryParamIncludeGuids$outboundSchema` instead. */
  export const outboundSchema = QueryParamIncludeGuids$outboundSchema;
}

/** @internal */
export const IncludeAdvanced$inboundSchema: z.ZodNativeEnum<
  typeof IncludeAdvanced
> = z.nativeEnum(IncludeAdvanced);

/** @internal */
export const IncludeAdvanced$outboundSchema: z.ZodNativeEnum<
  typeof IncludeAdvanced
> = IncludeAdvanced$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IncludeAdvanced$ {
  /** @deprecated use `IncludeAdvanced$inboundSchema` instead. */
  export const inboundSchema = IncludeAdvanced$inboundSchema;
  /** @deprecated use `IncludeAdvanced$outboundSchema` instead. */
  export const outboundSchema = IncludeAdvanced$outboundSchema;
}

/** @internal */
export const QueryParamIncludeCollections$inboundSchema: z.ZodNativeEnum<
  typeof QueryParamIncludeCollections
> = z.nativeEnum(QueryParamIncludeCollections);

/** @internal */
export const QueryParamIncludeCollections$outboundSchema: z.ZodNativeEnum<
  typeof QueryParamIncludeCollections
> = QueryParamIncludeCollections$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueryParamIncludeCollections$ {
  /** @deprecated use `QueryParamIncludeCollections$inboundSchema` instead. */
  export const inboundSchema = QueryParamIncludeCollections$inboundSchema;
  /** @deprecated use `QueryParamIncludeCollections$outboundSchema` instead. */
  export const outboundSchema = QueryParamIncludeCollections$outboundSchema;
}

/** @internal */
export const QueryParamIncludeExternalMedia$inboundSchema: z.ZodNativeEnum<
  typeof QueryParamIncludeExternalMedia
> = z.nativeEnum(QueryParamIncludeExternalMedia);

/** @internal */
export const QueryParamIncludeExternalMedia$outboundSchema: z.ZodNativeEnum<
  typeof QueryParamIncludeExternalMedia
> = QueryParamIncludeExternalMedia$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueryParamIncludeExternalMedia$ {
  /** @deprecated use `QueryParamIncludeExternalMedia$inboundSchema` instead. */
  export const inboundSchema = QueryParamIncludeExternalMedia$inboundSchema;
  /** @deprecated use `QueryParamIncludeExternalMedia$outboundSchema` instead. */
  export const outboundSchema = QueryParamIncludeExternalMedia$outboundSchema;
}

/** @internal */
export const GetLibrarySectionsAllRequest$inboundSchema: z.ZodType<
  GetLibrarySectionsAllRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  sectionKey: z.number().int(),
  type: GetLibrarySectionsAllQueryParamType$inboundSchema,
  includeMeta: GetLibrarySectionsAllQueryParamIncludeMeta$inboundSchema,
  includeGuids: QueryParamIncludeGuids$inboundSchema,
  includeAdvanced: IncludeAdvanced$inboundSchema,
  includeCollections: QueryParamIncludeCollections$inboundSchema,
  includeExternalMedia: QueryParamIncludeExternalMedia$inboundSchema,
  "X-Plex-Container-Start": z.number().int().default(0),
  "X-Plex-Container-Size": z.number().int().default(50),
}).transform((v) => {
  return remap$(v, {
    "X-Plex-Container-Start": "xPlexContainerStart",
    "X-Plex-Container-Size": "xPlexContainerSize",
  });
});

/** @internal */
export type GetLibrarySectionsAllRequest$Outbound = {
  sectionKey: number;
  type: number;
  includeMeta: number;
  includeGuids: number;
  includeAdvanced: number;
  includeCollections: number;
  includeExternalMedia: number;
  "X-Plex-Container-Start": number;
  "X-Plex-Container-Size": number;
};

/** @internal */
export const GetLibrarySectionsAllRequest$outboundSchema: z.ZodType<
  GetLibrarySectionsAllRequest$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllRequest
> = z.object({
  sectionKey: z.number().int(),
  type: GetLibrarySectionsAllQueryParamType$outboundSchema,
  includeMeta: GetLibrarySectionsAllQueryParamIncludeMeta$outboundSchema
    .default(GetLibrarySectionsAllQueryParamIncludeMeta.Disable),
  includeGuids: QueryParamIncludeGuids$outboundSchema.default(
    QueryParamIncludeGuids.Disable,
  ),
  includeAdvanced: IncludeAdvanced$outboundSchema.default(
    IncludeAdvanced.Disable,
  ),
  includeCollections: QueryParamIncludeCollections$outboundSchema.default(
    QueryParamIncludeCollections.Disable,
  ),
  includeExternalMedia: QueryParamIncludeExternalMedia$outboundSchema.default(
    QueryParamIncludeExternalMedia.Disable,
  ),
  xPlexContainerStart: z.number().int().default(0),
  xPlexContainerSize: z.number().int().default(50),
}).transform((v) => {
  return remap$(v, {
    xPlexContainerStart: "X-Plex-Container-Start",
    xPlexContainerSize: "X-Plex-Container-Size",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllRequest$ {
  /** @deprecated use `GetLibrarySectionsAllRequest$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllRequest$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllRequest$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllRequest$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllRequest$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllRequest$Outbound;
}

export function getLibrarySectionsAllRequestToJSON(
  getLibrarySectionsAllRequest: GetLibrarySectionsAllRequest,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllRequest$outboundSchema.parse(
      getLibrarySectionsAllRequest,
    ),
  );
}

export function getLibrarySectionsAllRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllRequest' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllFilter$inboundSchema: z.ZodType<
  GetLibrarySectionsAllFilter,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: z.string(),
  filterType: z.string(),
  key: z.string(),
  title: z.string(),
  type: z.string(),
  advanced: z.boolean().optional(),
});

/** @internal */
export type GetLibrarySectionsAllFilter$Outbound = {
  filter: string;
  filterType: string;
  key: string;
  title: string;
  type: string;
  advanced?: boolean | undefined;
};

/** @internal */
export const GetLibrarySectionsAllFilter$outboundSchema: z.ZodType<
  GetLibrarySectionsAllFilter$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllFilter
> = z.object({
  filter: z.string(),
  filterType: z.string(),
  key: z.string(),
  title: z.string(),
  type: z.string(),
  advanced: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllFilter$ {
  /** @deprecated use `GetLibrarySectionsAllFilter$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllFilter$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllFilter$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllFilter$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllFilter$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllFilter$Outbound;
}

export function getLibrarySectionsAllFilterToJSON(
  getLibrarySectionsAllFilter: GetLibrarySectionsAllFilter,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllFilter$outboundSchema.parse(
      getLibrarySectionsAllFilter,
    ),
  );
}

export function getLibrarySectionsAllFilterFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllFilter' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllActiveDirection$inboundSchema:
  z.ZodNativeEnum<typeof GetLibrarySectionsAllActiveDirection> = z.nativeEnum(
    GetLibrarySectionsAllActiveDirection,
  );

/** @internal */
export const GetLibrarySectionsAllActiveDirection$outboundSchema:
  z.ZodNativeEnum<typeof GetLibrarySectionsAllActiveDirection> =
    GetLibrarySectionsAllActiveDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllActiveDirection$ {
  /** @deprecated use `GetLibrarySectionsAllActiveDirection$inboundSchema` instead. */
  export const inboundSchema =
    GetLibrarySectionsAllActiveDirection$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllActiveDirection$outboundSchema` instead. */
  export const outboundSchema =
    GetLibrarySectionsAllActiveDirection$outboundSchema;
}

/** @internal */
export const GetLibrarySectionsAllDefaultDirection$inboundSchema:
  z.ZodNativeEnum<typeof GetLibrarySectionsAllDefaultDirection> = z.nativeEnum(
    GetLibrarySectionsAllDefaultDirection,
  );

/** @internal */
export const GetLibrarySectionsAllDefaultDirection$outboundSchema:
  z.ZodNativeEnum<typeof GetLibrarySectionsAllDefaultDirection> =
    GetLibrarySectionsAllDefaultDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllDefaultDirection$ {
  /** @deprecated use `GetLibrarySectionsAllDefaultDirection$inboundSchema` instead. */
  export const inboundSchema =
    GetLibrarySectionsAllDefaultDirection$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllDefaultDirection$outboundSchema` instead. */
  export const outboundSchema =
    GetLibrarySectionsAllDefaultDirection$outboundSchema;
}

/** @internal */
export const GetLibrarySectionsAllSort$inboundSchema: z.ZodType<
  GetLibrarySectionsAllSort,
  z.ZodTypeDef,
  unknown
> = z.object({
  default: z.string().optional(),
  active: z.boolean().optional(),
  activeDirection: GetLibrarySectionsAllActiveDirection$inboundSchema.default(
    GetLibrarySectionsAllActiveDirection.Ascending,
  ),
  defaultDirection: GetLibrarySectionsAllDefaultDirection$inboundSchema.default(
    GetLibrarySectionsAllDefaultDirection.Ascending,
  ),
  descKey: z.string().optional(),
  firstCharacterKey: z.string().optional(),
  key: z.string(),
  title: z.string(),
});

/** @internal */
export type GetLibrarySectionsAllSort$Outbound = {
  default?: string | undefined;
  active?: boolean | undefined;
  activeDirection: string;
  defaultDirection: string;
  descKey?: string | undefined;
  firstCharacterKey?: string | undefined;
  key: string;
  title: string;
};

/** @internal */
export const GetLibrarySectionsAllSort$outboundSchema: z.ZodType<
  GetLibrarySectionsAllSort$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllSort
> = z.object({
  default: z.string().optional(),
  active: z.boolean().optional(),
  activeDirection: GetLibrarySectionsAllActiveDirection$outboundSchema.default(
    GetLibrarySectionsAllActiveDirection.Ascending,
  ),
  defaultDirection: GetLibrarySectionsAllDefaultDirection$outboundSchema
    .default(GetLibrarySectionsAllDefaultDirection.Ascending),
  descKey: z.string().optional(),
  firstCharacterKey: z.string().optional(),
  key: z.string(),
  title: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllSort$ {
  /** @deprecated use `GetLibrarySectionsAllSort$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllSort$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllSort$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllSort$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllSort$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllSort$Outbound;
}

export function getLibrarySectionsAllSortToJSON(
  getLibrarySectionsAllSort: GetLibrarySectionsAllSort,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllSort$outboundSchema.parse(getLibrarySectionsAllSort),
  );
}

export function getLibrarySectionsAllSortFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllSort, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllSort$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllSort' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllField$inboundSchema: z.ZodType<
  GetLibrarySectionsAllField,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  title: z.string(),
  type: z.string(),
  subType: z.string().optional(),
});

/** @internal */
export type GetLibrarySectionsAllField$Outbound = {
  key: string;
  title: string;
  type: string;
  subType?: string | undefined;
};

/** @internal */
export const GetLibrarySectionsAllField$outboundSchema: z.ZodType<
  GetLibrarySectionsAllField$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllField
> = z.object({
  key: z.string(),
  title: z.string(),
  type: z.string(),
  subType: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllField$ {
  /** @deprecated use `GetLibrarySectionsAllField$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllField$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllField$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllField$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllField$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllField$Outbound;
}

export function getLibrarySectionsAllFieldToJSON(
  getLibrarySectionsAllField: GetLibrarySectionsAllField,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllField$outboundSchema.parse(getLibrarySectionsAllField),
  );
}

export function getLibrarySectionsAllFieldFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllField, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllField$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllField' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllType$inboundSchema: z.ZodType<
  GetLibrarySectionsAllType,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  type: z.string(),
  subtype: z.string().optional(),
  title: z.string(),
  active: z.boolean(),
  Filter: z.array(z.lazy(() => GetLibrarySectionsAllFilter$inboundSchema))
    .optional(),
  Sort: z.array(z.lazy(() => GetLibrarySectionsAllSort$inboundSchema))
    .optional(),
  Field: z.array(z.lazy(() => GetLibrarySectionsAllField$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "Filter": "filter",
    "Sort": "sort",
    "Field": "field",
  });
});

/** @internal */
export type GetLibrarySectionsAllType$Outbound = {
  key: string;
  type: string;
  subtype?: string | undefined;
  title: string;
  active: boolean;
  Filter?: Array<GetLibrarySectionsAllFilter$Outbound> | undefined;
  Sort?: Array<GetLibrarySectionsAllSort$Outbound> | undefined;
  Field?: Array<GetLibrarySectionsAllField$Outbound> | undefined;
};

/** @internal */
export const GetLibrarySectionsAllType$outboundSchema: z.ZodType<
  GetLibrarySectionsAllType$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllType
> = z.object({
  key: z.string(),
  type: z.string(),
  subtype: z.string().optional(),
  title: z.string(),
  active: z.boolean(),
  filter: z.array(z.lazy(() => GetLibrarySectionsAllFilter$outboundSchema))
    .optional(),
  sort: z.array(z.lazy(() => GetLibrarySectionsAllSort$outboundSchema))
    .optional(),
  field: z.array(z.lazy(() => GetLibrarySectionsAllField$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    filter: "Filter",
    sort: "Sort",
    field: "Field",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllType$ {
  /** @deprecated use `GetLibrarySectionsAllType$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllType$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllType$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllType$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllType$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllType$Outbound;
}

export function getLibrarySectionsAllTypeToJSON(
  getLibrarySectionsAllType: GetLibrarySectionsAllType,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllType$outboundSchema.parse(getLibrarySectionsAllType),
  );
}

export function getLibrarySectionsAllTypeFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllType' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllOperator$inboundSchema: z.ZodType<
  GetLibrarySectionsAllOperator,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  title: z.string(),
});

/** @internal */
export type GetLibrarySectionsAllOperator$Outbound = {
  key: string;
  title: string;
};

/** @internal */
export const GetLibrarySectionsAllOperator$outboundSchema: z.ZodType<
  GetLibrarySectionsAllOperator$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllOperator
> = z.object({
  key: z.string(),
  title: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllOperator$ {
  /** @deprecated use `GetLibrarySectionsAllOperator$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllOperator$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllOperator$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllOperator$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllOperator$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllOperator$Outbound;
}

export function getLibrarySectionsAllOperatorToJSON(
  getLibrarySectionsAllOperator: GetLibrarySectionsAllOperator,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllOperator$outboundSchema.parse(
      getLibrarySectionsAllOperator,
    ),
  );
}

export function getLibrarySectionsAllOperatorFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllOperator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllOperator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllOperator' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllFieldType$inboundSchema: z.ZodType<
  GetLibrarySectionsAllFieldType,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string(),
  Operator: z.array(z.lazy(() => GetLibrarySectionsAllOperator$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "Operator": "operator",
  });
});

/** @internal */
export type GetLibrarySectionsAllFieldType$Outbound = {
  type: string;
  Operator: Array<GetLibrarySectionsAllOperator$Outbound>;
};

/** @internal */
export const GetLibrarySectionsAllFieldType$outboundSchema: z.ZodType<
  GetLibrarySectionsAllFieldType$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllFieldType
> = z.object({
  type: z.string(),
  operator: z.array(z.lazy(() => GetLibrarySectionsAllOperator$outboundSchema)),
}).transform((v) => {
  return remap$(v, {
    operator: "Operator",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllFieldType$ {
  /** @deprecated use `GetLibrarySectionsAllFieldType$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllFieldType$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllFieldType$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllFieldType$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllFieldType$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllFieldType$Outbound;
}

export function getLibrarySectionsAllFieldTypeToJSON(
  getLibrarySectionsAllFieldType: GetLibrarySectionsAllFieldType,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllFieldType$outboundSchema.parse(
      getLibrarySectionsAllFieldType,
    ),
  );
}

export function getLibrarySectionsAllFieldTypeFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllFieldType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllFieldType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllFieldType' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllMeta$inboundSchema: z.ZodType<
  GetLibrarySectionsAllMeta,
  z.ZodTypeDef,
  unknown
> = z.object({
  Type: z.array(z.lazy(() => GetLibrarySectionsAllType$inboundSchema))
    .optional(),
  FieldType: z.array(z.lazy(() => GetLibrarySectionsAllFieldType$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "Type": "type",
    "FieldType": "fieldType",
  });
});

/** @internal */
export type GetLibrarySectionsAllMeta$Outbound = {
  Type?: Array<GetLibrarySectionsAllType$Outbound> | undefined;
  FieldType?: Array<GetLibrarySectionsAllFieldType$Outbound> | undefined;
};

/** @internal */
export const GetLibrarySectionsAllMeta$outboundSchema: z.ZodType<
  GetLibrarySectionsAllMeta$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllMeta
> = z.object({
  type: z.array(z.lazy(() => GetLibrarySectionsAllType$outboundSchema))
    .optional(),
  fieldType: z.array(
    z.lazy(() => GetLibrarySectionsAllFieldType$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    type: "Type",
    fieldType: "FieldType",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllMeta$ {
  /** @deprecated use `GetLibrarySectionsAllMeta$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllMeta$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllMeta$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllMeta$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllMeta$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllMeta$Outbound;
}

export function getLibrarySectionsAllMetaToJSON(
  getLibrarySectionsAllMeta: GetLibrarySectionsAllMeta,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllMeta$outboundSchema.parse(getLibrarySectionsAllMeta),
  );
}

export function getLibrarySectionsAllMetaFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllMeta, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllMeta$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllMeta' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllLibraryType$inboundSchema: z.ZodType<
  GetLibrarySectionsAllLibraryTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetLibrarySectionsAllLibraryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetLibrarySectionsAllLibraryType$outboundSchema: z.ZodType<
  GetLibrarySectionsAllLibraryTypeOpen,
  z.ZodTypeDef,
  GetLibrarySectionsAllLibraryTypeOpen
> = z.union([
  z.nativeEnum(GetLibrarySectionsAllLibraryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllLibraryType$ {
  /** @deprecated use `GetLibrarySectionsAllLibraryType$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllLibraryType$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllLibraryType$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllLibraryType$outboundSchema;
}

/** @internal */
export const GetLibrarySectionsAllLibraryResponseType$inboundSchema: z.ZodType<
  GetLibrarySectionsAllLibraryResponseTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetLibrarySectionsAllLibraryResponseType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetLibrarySectionsAllLibraryResponseType$outboundSchema: z.ZodType<
  GetLibrarySectionsAllLibraryResponseTypeOpen,
  z.ZodTypeDef,
  GetLibrarySectionsAllLibraryResponseTypeOpen
> = z.union([
  z.nativeEnum(GetLibrarySectionsAllLibraryResponseType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllLibraryResponseType$ {
  /** @deprecated use `GetLibrarySectionsAllLibraryResponseType$inboundSchema` instead. */
  export const inboundSchema =
    GetLibrarySectionsAllLibraryResponseType$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllLibraryResponseType$outboundSchema` instead. */
  export const outboundSchema =
    GetLibrarySectionsAllLibraryResponseType$outboundSchema;
}

/** @internal */
export const GetLibrarySectionsAllImage$inboundSchema: z.ZodType<
  GetLibrarySectionsAllImage,
  z.ZodTypeDef,
  unknown
> = z.object({
  alt: z.string(),
  type: GetLibrarySectionsAllLibraryResponseType$inboundSchema,
  url: z.string(),
});

/** @internal */
export type GetLibrarySectionsAllImage$Outbound = {
  alt: string;
  type: string;
  url: string;
};

/** @internal */
export const GetLibrarySectionsAllImage$outboundSchema: z.ZodType<
  GetLibrarySectionsAllImage$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllImage
> = z.object({
  alt: z.string(),
  type: GetLibrarySectionsAllLibraryResponseType$outboundSchema,
  url: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllImage$ {
  /** @deprecated use `GetLibrarySectionsAllImage$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllImage$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllImage$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllImage$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllImage$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllImage$Outbound;
}

export function getLibrarySectionsAllImageToJSON(
  getLibrarySectionsAllImage: GetLibrarySectionsAllImage,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllImage$outboundSchema.parse(getLibrarySectionsAllImage),
  );
}

export function getLibrarySectionsAllImageFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllImage' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllUltraBlurColors$inboundSchema: z.ZodType<
  GetLibrarySectionsAllUltraBlurColors,
  z.ZodTypeDef,
  unknown
> = z.object({
  topLeft: z.string(),
  topRight: z.string(),
  bottomRight: z.string(),
  bottomLeft: z.string(),
});

/** @internal */
export type GetLibrarySectionsAllUltraBlurColors$Outbound = {
  topLeft: string;
  topRight: string;
  bottomRight: string;
  bottomLeft: string;
};

/** @internal */
export const GetLibrarySectionsAllUltraBlurColors$outboundSchema: z.ZodType<
  GetLibrarySectionsAllUltraBlurColors$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllUltraBlurColors
> = z.object({
  topLeft: z.string(),
  topRight: z.string(),
  bottomRight: z.string(),
  bottomLeft: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllUltraBlurColors$ {
  /** @deprecated use `GetLibrarySectionsAllUltraBlurColors$inboundSchema` instead. */
  export const inboundSchema =
    GetLibrarySectionsAllUltraBlurColors$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllUltraBlurColors$outboundSchema` instead. */
  export const outboundSchema =
    GetLibrarySectionsAllUltraBlurColors$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllUltraBlurColors$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllUltraBlurColors$Outbound;
}

export function getLibrarySectionsAllUltraBlurColorsToJSON(
  getLibrarySectionsAllUltraBlurColors: GetLibrarySectionsAllUltraBlurColors,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllUltraBlurColors$outboundSchema.parse(
      getLibrarySectionsAllUltraBlurColors,
    ),
  );
}

export function getLibrarySectionsAllUltraBlurColorsFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllUltraBlurColors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetLibrarySectionsAllUltraBlurColors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllUltraBlurColors' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllGuids$inboundSchema: z.ZodType<
  GetLibrarySectionsAllGuids,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

/** @internal */
export type GetLibrarySectionsAllGuids$Outbound = {
  id: string;
};

/** @internal */
export const GetLibrarySectionsAllGuids$outboundSchema: z.ZodType<
  GetLibrarySectionsAllGuids$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllGuids
> = z.object({
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllGuids$ {
  /** @deprecated use `GetLibrarySectionsAllGuids$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllGuids$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllGuids$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllGuids$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllGuids$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllGuids$Outbound;
}

export function getLibrarySectionsAllGuidsToJSON(
  getLibrarySectionsAllGuids: GetLibrarySectionsAllGuids,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllGuids$outboundSchema.parse(getLibrarySectionsAllGuids),
  );
}

export function getLibrarySectionsAllGuidsFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllGuids, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllGuids$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllGuids' from JSON`,
  );
}

/** @internal */
export const OptimizedForStreaming1$inboundSchema: z.ZodNativeEnum<
  typeof OptimizedForStreaming1
> = z.nativeEnum(OptimizedForStreaming1);

/** @internal */
export const OptimizedForStreaming1$outboundSchema: z.ZodNativeEnum<
  typeof OptimizedForStreaming1
> = OptimizedForStreaming1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OptimizedForStreaming1$ {
  /** @deprecated use `OptimizedForStreaming1$inboundSchema` instead. */
  export const inboundSchema = OptimizedForStreaming1$inboundSchema;
  /** @deprecated use `OptimizedForStreaming1$outboundSchema` instead. */
  export const outboundSchema = OptimizedForStreaming1$outboundSchema;
}

/** @internal */
export const GetLibrarySectionsAllOptimizedForStreaming$inboundSchema:
  z.ZodType<GetLibrarySectionsAllOptimizedForStreaming, z.ZodTypeDef, unknown> =
    z.union([OptimizedForStreaming1$inboundSchema, z.boolean()]);

/** @internal */
export type GetLibrarySectionsAllOptimizedForStreaming$Outbound =
  | number
  | boolean;

/** @internal */
export const GetLibrarySectionsAllOptimizedForStreaming$outboundSchema:
  z.ZodType<
    GetLibrarySectionsAllOptimizedForStreaming$Outbound,
    z.ZodTypeDef,
    GetLibrarySectionsAllOptimizedForStreaming
  > = z.union([OptimizedForStreaming1$outboundSchema, z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllOptimizedForStreaming$ {
  /** @deprecated use `GetLibrarySectionsAllOptimizedForStreaming$inboundSchema` instead. */
  export const inboundSchema =
    GetLibrarySectionsAllOptimizedForStreaming$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllOptimizedForStreaming$outboundSchema` instead. */
  export const outboundSchema =
    GetLibrarySectionsAllOptimizedForStreaming$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllOptimizedForStreaming$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllOptimizedForStreaming$Outbound;
}

export function getLibrarySectionsAllOptimizedForStreamingToJSON(
  getLibrarySectionsAllOptimizedForStreaming:
    GetLibrarySectionsAllOptimizedForStreaming,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllOptimizedForStreaming$outboundSchema.parse(
      getLibrarySectionsAllOptimizedForStreaming,
    ),
  );
}

export function getLibrarySectionsAllOptimizedForStreamingFromJSON(
  jsonString: string,
): SafeParseResult<
  GetLibrarySectionsAllOptimizedForStreaming,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetLibrarySectionsAllOptimizedForStreaming$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetLibrarySectionsAllOptimizedForStreaming' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllOptimizedForStreaming1$inboundSchema:
  z.ZodNativeEnum<typeof GetLibrarySectionsAllOptimizedForStreaming1> = z
    .nativeEnum(GetLibrarySectionsAllOptimizedForStreaming1);

/** @internal */
export const GetLibrarySectionsAllOptimizedForStreaming1$outboundSchema:
  z.ZodNativeEnum<typeof GetLibrarySectionsAllOptimizedForStreaming1> =
    GetLibrarySectionsAllOptimizedForStreaming1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllOptimizedForStreaming1$ {
  /** @deprecated use `GetLibrarySectionsAllOptimizedForStreaming1$inboundSchema` instead. */
  export const inboundSchema =
    GetLibrarySectionsAllOptimizedForStreaming1$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllOptimizedForStreaming1$outboundSchema` instead. */
  export const outboundSchema =
    GetLibrarySectionsAllOptimizedForStreaming1$outboundSchema;
}

/** @internal */
export const GetLibrarySectionsAllLibraryOptimizedForStreaming$inboundSchema:
  z.ZodType<
    GetLibrarySectionsAllLibraryOptimizedForStreaming,
    z.ZodTypeDef,
    unknown
  > = z.union([
    GetLibrarySectionsAllOptimizedForStreaming1$inboundSchema,
    z.boolean(),
  ]);

/** @internal */
export type GetLibrarySectionsAllLibraryOptimizedForStreaming$Outbound =
  | number
  | boolean;

/** @internal */
export const GetLibrarySectionsAllLibraryOptimizedForStreaming$outboundSchema:
  z.ZodType<
    GetLibrarySectionsAllLibraryOptimizedForStreaming$Outbound,
    z.ZodTypeDef,
    GetLibrarySectionsAllLibraryOptimizedForStreaming
  > = z.union([
    GetLibrarySectionsAllOptimizedForStreaming1$outboundSchema,
    z.boolean(),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllLibraryOptimizedForStreaming$ {
  /** @deprecated use `GetLibrarySectionsAllLibraryOptimizedForStreaming$inboundSchema` instead. */
  export const inboundSchema =
    GetLibrarySectionsAllLibraryOptimizedForStreaming$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllLibraryOptimizedForStreaming$outboundSchema` instead. */
  export const outboundSchema =
    GetLibrarySectionsAllLibraryOptimizedForStreaming$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllLibraryOptimizedForStreaming$Outbound` instead. */
  export type Outbound =
    GetLibrarySectionsAllLibraryOptimizedForStreaming$Outbound;
}

export function getLibrarySectionsAllLibraryOptimizedForStreamingToJSON(
  getLibrarySectionsAllLibraryOptimizedForStreaming:
    GetLibrarySectionsAllLibraryOptimizedForStreaming,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllLibraryOptimizedForStreaming$outboundSchema.parse(
      getLibrarySectionsAllLibraryOptimizedForStreaming,
    ),
  );
}

export function getLibrarySectionsAllLibraryOptimizedForStreamingFromJSON(
  jsonString: string,
): SafeParseResult<
  GetLibrarySectionsAllLibraryOptimizedForStreaming,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetLibrarySectionsAllLibraryOptimizedForStreaming$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetLibrarySectionsAllLibraryOptimizedForStreaming' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllHasThumbnail$inboundSchema: z.ZodNativeEnum<
  typeof GetLibrarySectionsAllHasThumbnail
> = z.nativeEnum(GetLibrarySectionsAllHasThumbnail);

/** @internal */
export const GetLibrarySectionsAllHasThumbnail$outboundSchema: z.ZodNativeEnum<
  typeof GetLibrarySectionsAllHasThumbnail
> = GetLibrarySectionsAllHasThumbnail$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllHasThumbnail$ {
  /** @deprecated use `GetLibrarySectionsAllHasThumbnail$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllHasThumbnail$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllHasThumbnail$outboundSchema` instead. */
  export const outboundSchema =
    GetLibrarySectionsAllHasThumbnail$outboundSchema;
}

/** @internal */
export const GetLibrarySectionsAllStreamType$inboundSchema: z.ZodType<
  GetLibrarySectionsAllStreamTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetLibrarySectionsAllStreamType),
    z.number().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetLibrarySectionsAllStreamType$outboundSchema: z.ZodType<
  GetLibrarySectionsAllStreamTypeOpen,
  z.ZodTypeDef,
  GetLibrarySectionsAllStreamTypeOpen
> = z.union([
  z.nativeEnum(GetLibrarySectionsAllStreamType),
  z.number().and(z.custom<Unrecognized<number>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllStreamType$ {
  /** @deprecated use `GetLibrarySectionsAllStreamType$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllStreamType$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllStreamType$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllStreamType$outboundSchema;
}

/** @internal */
export const GetLibrarySectionsAllStream$inboundSchema: z.ZodType<
  GetLibrarySectionsAllStream,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  streamType: GetLibrarySectionsAllStreamType$inboundSchema,
  format: z.string().optional(),
  default: z.boolean().optional(),
  codec: z.string(),
  index: z.number().int().optional(),
  bitrate: z.number().int().optional(),
  language: z.string().optional(),
  languageTag: z.string().optional(),
  languageCode: z.string().optional(),
  headerCompression: z.boolean().optional(),
  DOVIBLCompatID: z.number().int().optional(),
  DOVIBLPresent: z.boolean().optional(),
  DOVIELPresent: z.boolean().optional(),
  DOVILevel: z.number().int().optional(),
  DOVIPresent: z.boolean().optional(),
  DOVIProfile: z.number().int().optional(),
  DOVIRPUPresent: z.boolean().optional(),
  DOVIVersion: z.string().optional(),
  bitDepth: z.number().int().optional(),
  chromaLocation: z.string().optional(),
  chromaSubsampling: z.string().optional(),
  codedHeight: z.number().int().optional(),
  codedWidth: z.number().int().optional(),
  closedCaptions: z.boolean().optional(),
  colorPrimaries: z.string().optional(),
  colorRange: z.string().optional(),
  colorSpace: z.string().optional(),
  colorTrc: z.string().optional(),
  frameRate: z.number().optional(),
  key: z.string().optional(),
  height: z.number().int().optional(),
  level: z.number().int().optional(),
  original: z.boolean().optional(),
  hasScalingMatrix: z.boolean().optional(),
  profile: z.string().optional(),
  scanType: z.string().optional(),
  embeddedInVideo: z.string().optional(),
  refFrames: z.number().int().optional(),
  width: z.number().int().optional(),
  displayTitle: z.string(),
  extendedDisplayTitle: z.string(),
  selected: z.boolean().optional(),
  forced: z.boolean().optional(),
  channels: z.number().int().optional(),
  audioChannelLayout: z.string().optional(),
  samplingRate: z.number().int().optional(),
  canAutoSync: z.boolean().optional(),
  hearingImpaired: z.boolean().optional(),
  dub: z.boolean().optional(),
  title: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "DOVIBLCompatID": "doviblCompatID",
    "DOVIBLPresent": "doviblPresent",
    "DOVIELPresent": "dovielPresent",
    "DOVILevel": "doviLevel",
    "DOVIPresent": "doviPresent",
    "DOVIProfile": "doviProfile",
    "DOVIRPUPresent": "dovirpuPresent",
    "DOVIVersion": "doviVersion",
  });
});

/** @internal */
export type GetLibrarySectionsAllStream$Outbound = {
  id: number;
  streamType: number;
  format?: string | undefined;
  default?: boolean | undefined;
  codec: string;
  index?: number | undefined;
  bitrate?: number | undefined;
  language?: string | undefined;
  languageTag?: string | undefined;
  languageCode?: string | undefined;
  headerCompression?: boolean | undefined;
  DOVIBLCompatID?: number | undefined;
  DOVIBLPresent?: boolean | undefined;
  DOVIELPresent?: boolean | undefined;
  DOVILevel?: number | undefined;
  DOVIPresent?: boolean | undefined;
  DOVIProfile?: number | undefined;
  DOVIRPUPresent?: boolean | undefined;
  DOVIVersion?: string | undefined;
  bitDepth?: number | undefined;
  chromaLocation?: string | undefined;
  chromaSubsampling?: string | undefined;
  codedHeight?: number | undefined;
  codedWidth?: number | undefined;
  closedCaptions?: boolean | undefined;
  colorPrimaries?: string | undefined;
  colorRange?: string | undefined;
  colorSpace?: string | undefined;
  colorTrc?: string | undefined;
  frameRate?: number | undefined;
  key?: string | undefined;
  height?: number | undefined;
  level?: number | undefined;
  original?: boolean | undefined;
  hasScalingMatrix?: boolean | undefined;
  profile?: string | undefined;
  scanType?: string | undefined;
  embeddedInVideo?: string | undefined;
  refFrames?: number | undefined;
  width?: number | undefined;
  displayTitle: string;
  extendedDisplayTitle: string;
  selected?: boolean | undefined;
  forced?: boolean | undefined;
  channels?: number | undefined;
  audioChannelLayout?: string | undefined;
  samplingRate?: number | undefined;
  canAutoSync?: boolean | undefined;
  hearingImpaired?: boolean | undefined;
  dub?: boolean | undefined;
  title?: string | undefined;
};

/** @internal */
export const GetLibrarySectionsAllStream$outboundSchema: z.ZodType<
  GetLibrarySectionsAllStream$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllStream
> = z.object({
  id: z.number().int(),
  streamType: GetLibrarySectionsAllStreamType$outboundSchema,
  format: z.string().optional(),
  default: z.boolean().optional(),
  codec: z.string(),
  index: z.number().int().optional(),
  bitrate: z.number().int().optional(),
  language: z.string().optional(),
  languageTag: z.string().optional(),
  languageCode: z.string().optional(),
  headerCompression: z.boolean().optional(),
  doviblCompatID: z.number().int().optional(),
  doviblPresent: z.boolean().optional(),
  dovielPresent: z.boolean().optional(),
  doviLevel: z.number().int().optional(),
  doviPresent: z.boolean().optional(),
  doviProfile: z.number().int().optional(),
  dovirpuPresent: z.boolean().optional(),
  doviVersion: z.string().optional(),
  bitDepth: z.number().int().optional(),
  chromaLocation: z.string().optional(),
  chromaSubsampling: z.string().optional(),
  codedHeight: z.number().int().optional(),
  codedWidth: z.number().int().optional(),
  closedCaptions: z.boolean().optional(),
  colorPrimaries: z.string().optional(),
  colorRange: z.string().optional(),
  colorSpace: z.string().optional(),
  colorTrc: z.string().optional(),
  frameRate: z.number().optional(),
  key: z.string().optional(),
  height: z.number().int().optional(),
  level: z.number().int().optional(),
  original: z.boolean().optional(),
  hasScalingMatrix: z.boolean().optional(),
  profile: z.string().optional(),
  scanType: z.string().optional(),
  embeddedInVideo: z.string().optional(),
  refFrames: z.number().int().optional(),
  width: z.number().int().optional(),
  displayTitle: z.string(),
  extendedDisplayTitle: z.string(),
  selected: z.boolean().optional(),
  forced: z.boolean().optional(),
  channels: z.number().int().optional(),
  audioChannelLayout: z.string().optional(),
  samplingRate: z.number().int().optional(),
  canAutoSync: z.boolean().optional(),
  hearingImpaired: z.boolean().optional(),
  dub: z.boolean().optional(),
  title: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    doviblCompatID: "DOVIBLCompatID",
    doviblPresent: "DOVIBLPresent",
    dovielPresent: "DOVIELPresent",
    doviLevel: "DOVILevel",
    doviPresent: "DOVIPresent",
    doviProfile: "DOVIProfile",
    dovirpuPresent: "DOVIRPUPresent",
    doviVersion: "DOVIVersion",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllStream$ {
  /** @deprecated use `GetLibrarySectionsAllStream$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllStream$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllStream$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllStream$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllStream$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllStream$Outbound;
}

export function getLibrarySectionsAllStreamToJSON(
  getLibrarySectionsAllStream: GetLibrarySectionsAllStream,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllStream$outboundSchema.parse(
      getLibrarySectionsAllStream,
    ),
  );
}

export function getLibrarySectionsAllStreamFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllStream, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllStream$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllStream' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllPart$inboundSchema: z.ZodType<
  GetLibrarySectionsAllPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  accessible: z.boolean().optional(),
  exists: z.boolean().optional(),
  id: z.number().int(),
  key: z.string(),
  indexes: z.string().optional(),
  duration: z.number().int().optional(),
  file: z.string(),
  size: z.number().int(),
  packetLength: z.number().int().optional(),
  container: z.string().optional(),
  videoProfile: z.string().optional(),
  audioProfile: z.string().optional(),
  has64bitOffsets: z.boolean().optional(),
  optimizedForStreaming: z.union([
    GetLibrarySectionsAllOptimizedForStreaming1$inboundSchema,
    z.boolean(),
  ]).optional(),
  hasThumbnail: GetLibrarySectionsAllHasThumbnail$inboundSchema.default(
    GetLibrarySectionsAllHasThumbnail.False,
  ),
  Stream: z.array(z.lazy(() => GetLibrarySectionsAllStream$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "Stream": "stream",
  });
});

/** @internal */
export type GetLibrarySectionsAllPart$Outbound = {
  accessible?: boolean | undefined;
  exists?: boolean | undefined;
  id: number;
  key: string;
  indexes?: string | undefined;
  duration?: number | undefined;
  file: string;
  size: number;
  packetLength?: number | undefined;
  container?: string | undefined;
  videoProfile?: string | undefined;
  audioProfile?: string | undefined;
  has64bitOffsets?: boolean | undefined;
  optimizedForStreaming?: number | boolean | undefined;
  hasThumbnail: string;
  Stream?: Array<GetLibrarySectionsAllStream$Outbound> | undefined;
};

/** @internal */
export const GetLibrarySectionsAllPart$outboundSchema: z.ZodType<
  GetLibrarySectionsAllPart$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllPart
> = z.object({
  accessible: z.boolean().optional(),
  exists: z.boolean().optional(),
  id: z.number().int(),
  key: z.string(),
  indexes: z.string().optional(),
  duration: z.number().int().optional(),
  file: z.string(),
  size: z.number().int(),
  packetLength: z.number().int().optional(),
  container: z.string().optional(),
  videoProfile: z.string().optional(),
  audioProfile: z.string().optional(),
  has64bitOffsets: z.boolean().optional(),
  optimizedForStreaming: z.union([
    GetLibrarySectionsAllOptimizedForStreaming1$outboundSchema,
    z.boolean(),
  ]).optional(),
  hasThumbnail: GetLibrarySectionsAllHasThumbnail$outboundSchema.default(
    GetLibrarySectionsAllHasThumbnail.False,
  ),
  stream: z.array(z.lazy(() => GetLibrarySectionsAllStream$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    stream: "Stream",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllPart$ {
  /** @deprecated use `GetLibrarySectionsAllPart$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllPart$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllPart$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllPart$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllPart$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllPart$Outbound;
}

export function getLibrarySectionsAllPartToJSON(
  getLibrarySectionsAllPart: GetLibrarySectionsAllPart,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllPart$outboundSchema.parse(getLibrarySectionsAllPart),
  );
}

export function getLibrarySectionsAllPartFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllPart' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllMedia$inboundSchema: z.ZodType<
  GetLibrarySectionsAllMedia,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  duration: z.number().int().optional(),
  bitrate: z.number().int().optional(),
  width: z.number().int().optional(),
  height: z.number().int().optional(),
  aspectRatio: z.number().optional(),
  audioChannels: z.number().int().optional(),
  displayOffset: z.number().int().optional(),
  audioCodec: z.string().optional(),
  videoCodec: z.string().optional(),
  videoResolution: z.string().optional(),
  container: z.string().optional(),
  videoFrameRate: z.string().optional(),
  videoProfile: z.string().optional(),
  hasVoiceActivity: z.boolean().optional(),
  audioProfile: z.string().optional(),
  optimizedForStreaming: z.union([
    OptimizedForStreaming1$inboundSchema,
    z.boolean(),
  ]).optional(),
  has64bitOffsets: z.boolean().optional(),
  Part: z.array(z.lazy(() => GetLibrarySectionsAllPart$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "Part": "part",
  });
});

/** @internal */
export type GetLibrarySectionsAllMedia$Outbound = {
  id: number;
  duration?: number | undefined;
  bitrate?: number | undefined;
  width?: number | undefined;
  height?: number | undefined;
  aspectRatio?: number | undefined;
  audioChannels?: number | undefined;
  displayOffset?: number | undefined;
  audioCodec?: string | undefined;
  videoCodec?: string | undefined;
  videoResolution?: string | undefined;
  container?: string | undefined;
  videoFrameRate?: string | undefined;
  videoProfile?: string | undefined;
  hasVoiceActivity?: boolean | undefined;
  audioProfile?: string | undefined;
  optimizedForStreaming?: number | boolean | undefined;
  has64bitOffsets?: boolean | undefined;
  Part?: Array<GetLibrarySectionsAllPart$Outbound> | undefined;
};

/** @internal */
export const GetLibrarySectionsAllMedia$outboundSchema: z.ZodType<
  GetLibrarySectionsAllMedia$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllMedia
> = z.object({
  id: z.number().int(),
  duration: z.number().int().optional(),
  bitrate: z.number().int().optional(),
  width: z.number().int().optional(),
  height: z.number().int().optional(),
  aspectRatio: z.number().optional(),
  audioChannels: z.number().int().optional(),
  displayOffset: z.number().int().optional(),
  audioCodec: z.string().optional(),
  videoCodec: z.string().optional(),
  videoResolution: z.string().optional(),
  container: z.string().optional(),
  videoFrameRate: z.string().optional(),
  videoProfile: z.string().optional(),
  hasVoiceActivity: z.boolean().optional(),
  audioProfile: z.string().optional(),
  optimizedForStreaming: z.union([
    OptimizedForStreaming1$outboundSchema,
    z.boolean(),
  ]).optional(),
  has64bitOffsets: z.boolean().optional(),
  part: z.array(z.lazy(() => GetLibrarySectionsAllPart$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    part: "Part",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllMedia$ {
  /** @deprecated use `GetLibrarySectionsAllMedia$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllMedia$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllMedia$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllMedia$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllMedia$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllMedia$Outbound;
}

export function getLibrarySectionsAllMediaToJSON(
  getLibrarySectionsAllMedia: GetLibrarySectionsAllMedia,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllMedia$outboundSchema.parse(getLibrarySectionsAllMedia),
  );
}

export function getLibrarySectionsAllMediaFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllMedia' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllGenre$inboundSchema: z.ZodType<
  GetLibrarySectionsAllGenre,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string(),
});

/** @internal */
export type GetLibrarySectionsAllGenre$Outbound = {
  tag: string;
};

/** @internal */
export const GetLibrarySectionsAllGenre$outboundSchema: z.ZodType<
  GetLibrarySectionsAllGenre$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllGenre
> = z.object({
  tag: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllGenre$ {
  /** @deprecated use `GetLibrarySectionsAllGenre$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllGenre$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllGenre$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllGenre$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllGenre$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllGenre$Outbound;
}

export function getLibrarySectionsAllGenreToJSON(
  getLibrarySectionsAllGenre: GetLibrarySectionsAllGenre,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllGenre$outboundSchema.parse(getLibrarySectionsAllGenre),
  );
}

export function getLibrarySectionsAllGenreFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllGenre, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllGenre$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllGenre' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllCountry$inboundSchema: z.ZodType<
  GetLibrarySectionsAllCountry,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string(),
});

/** @internal */
export type GetLibrarySectionsAllCountry$Outbound = {
  tag: string;
};

/** @internal */
export const GetLibrarySectionsAllCountry$outboundSchema: z.ZodType<
  GetLibrarySectionsAllCountry$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllCountry
> = z.object({
  tag: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllCountry$ {
  /** @deprecated use `GetLibrarySectionsAllCountry$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllCountry$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllCountry$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllCountry$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllCountry$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllCountry$Outbound;
}

export function getLibrarySectionsAllCountryToJSON(
  getLibrarySectionsAllCountry: GetLibrarySectionsAllCountry,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllCountry$outboundSchema.parse(
      getLibrarySectionsAllCountry,
    ),
  );
}

export function getLibrarySectionsAllCountryFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllCountry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllCountry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllCountry' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllDirector$inboundSchema: z.ZodType<
  GetLibrarySectionsAllDirector,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string(),
});

/** @internal */
export type GetLibrarySectionsAllDirector$Outbound = {
  tag: string;
};

/** @internal */
export const GetLibrarySectionsAllDirector$outboundSchema: z.ZodType<
  GetLibrarySectionsAllDirector$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllDirector
> = z.object({
  tag: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllDirector$ {
  /** @deprecated use `GetLibrarySectionsAllDirector$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllDirector$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllDirector$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllDirector$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllDirector$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllDirector$Outbound;
}

export function getLibrarySectionsAllDirectorToJSON(
  getLibrarySectionsAllDirector: GetLibrarySectionsAllDirector,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllDirector$outboundSchema.parse(
      getLibrarySectionsAllDirector,
    ),
  );
}

export function getLibrarySectionsAllDirectorFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllDirector, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllDirector$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllDirector' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllWriter$inboundSchema: z.ZodType<
  GetLibrarySectionsAllWriter,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string(),
});

/** @internal */
export type GetLibrarySectionsAllWriter$Outbound = {
  tag: string;
};

/** @internal */
export const GetLibrarySectionsAllWriter$outboundSchema: z.ZodType<
  GetLibrarySectionsAllWriter$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllWriter
> = z.object({
  tag: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllWriter$ {
  /** @deprecated use `GetLibrarySectionsAllWriter$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllWriter$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllWriter$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllWriter$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllWriter$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllWriter$Outbound;
}

export function getLibrarySectionsAllWriterToJSON(
  getLibrarySectionsAllWriter: GetLibrarySectionsAllWriter,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllWriter$outboundSchema.parse(
      getLibrarySectionsAllWriter,
    ),
  );
}

export function getLibrarySectionsAllWriterFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllWriter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllWriter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllWriter' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllRole$inboundSchema: z.ZodType<
  GetLibrarySectionsAllRole,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string(),
});

/** @internal */
export type GetLibrarySectionsAllRole$Outbound = {
  tag: string;
};

/** @internal */
export const GetLibrarySectionsAllRole$outboundSchema: z.ZodType<
  GetLibrarySectionsAllRole$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllRole
> = z.object({
  tag: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllRole$ {
  /** @deprecated use `GetLibrarySectionsAllRole$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllRole$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllRole$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllRole$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllRole$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllRole$Outbound;
}

export function getLibrarySectionsAllRoleToJSON(
  getLibrarySectionsAllRole: GetLibrarySectionsAllRole,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllRole$outboundSchema.parse(getLibrarySectionsAllRole),
  );
}

export function getLibrarySectionsAllRoleFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllRole' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllCollection$inboundSchema: z.ZodType<
  GetLibrarySectionsAllCollection,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string(),
});

/** @internal */
export type GetLibrarySectionsAllCollection$Outbound = {
  tag: string;
};

/** @internal */
export const GetLibrarySectionsAllCollection$outboundSchema: z.ZodType<
  GetLibrarySectionsAllCollection$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllCollection
> = z.object({
  tag: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllCollection$ {
  /** @deprecated use `GetLibrarySectionsAllCollection$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllCollection$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllCollection$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllCollection$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllCollection$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllCollection$Outbound;
}

export function getLibrarySectionsAllCollectionToJSON(
  getLibrarySectionsAllCollection: GetLibrarySectionsAllCollection,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllCollection$outboundSchema.parse(
      getLibrarySectionsAllCollection,
    ),
  );
}

export function getLibrarySectionsAllCollectionFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllCollection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllCollection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllCollection' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllMetadata$inboundSchema: z.ZodType<
  GetLibrarySectionsAllMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  ratingKey: z.string(),
  key: z.string(),
  guid: z.string(),
  slug: z.string(),
  studio: z.string().optional(),
  type: GetLibrarySectionsAllLibraryType$inboundSchema,
  title: z.string(),
  titleSort: z.string(),
  contentRating: z.string().optional(),
  summary: z.string(),
  rating: z.number(),
  audienceRating: z.number(),
  year: z.number().int().optional(),
  tagline: z.string(),
  thumb: z.string(),
  art: z.string(),
  theme: z.string(),
  index: z.number().int(),
  leafCount: z.number().int().optional(),
  viewedLeafCount: z.number().int().optional(),
  childCount: z.number().int(),
  seasonCount: z.number().int(),
  duration: z.number().int(),
  originallyAvailableAt: z.string().transform(v => new RFCDate(v)),
  addedAt: z.number().int(),
  updatedAt: z.number().int().optional(),
  audienceRatingImage: z.string().optional(),
  chapterSource: z.string().optional(),
  primaryExtraKey: z.string().optional(),
  originalTitle: z.string().optional(),
  parentRatingKey: z.string().optional(),
  grandparentRatingKey: z.string().optional(),
  parentGuid: z.string().optional(),
  grandparentGuid: z.string().optional(),
  grandparentSlug: z.string().optional(),
  grandparentKey: z.string().optional(),
  parentKey: z.string().optional(),
  grandparentTitle: z.string().optional(),
  grandparentThumb: z.string().optional(),
  grandparentTheme: z.string().optional(),
  grandparentArt: z.string().optional(),
  parentTitle: z.string().optional(),
  parentIndex: z.number().int().optional(),
  parentThumb: z.string().optional(),
  ratingImage: z.string().optional(),
  viewCount: z.number().int().optional(),
  viewOffset: z.number().int().optional(),
  skipCount: z.number().int().optional(),
  subtype: z.string().optional(),
  lastRatedAt: z.number().int().optional(),
  createdAtAccuracy: z.string().optional(),
  createdAtTZOffset: z.string().optional(),
  lastViewedAt: z.number().int().optional(),
  userRating: z.number().optional(),
  Image: z.array(z.lazy(() => GetLibrarySectionsAllImage$inboundSchema))
    .optional(),
  UltraBlurColors: z.lazy(() =>
    GetLibrarySectionsAllUltraBlurColors$inboundSchema
  ).optional(),
  Guid: z.array(z.lazy(() => GetLibrarySectionsAllGuids$inboundSchema))
    .optional(),
  Media: z.array(z.lazy(() => GetLibrarySectionsAllMedia$inboundSchema))
    .optional(),
  Genre: z.array(z.lazy(() => GetLibrarySectionsAllGenre$inboundSchema))
    .optional(),
  Country: z.array(z.lazy(() => GetLibrarySectionsAllCountry$inboundSchema))
    .optional(),
  Director: z.array(z.lazy(() => GetLibrarySectionsAllDirector$inboundSchema))
    .optional(),
  Writer: z.array(z.lazy(() => GetLibrarySectionsAllWriter$inboundSchema))
    .optional(),
  Role: z.array(z.lazy(() => GetLibrarySectionsAllRole$inboundSchema))
    .optional(),
  Collection: z.array(
    z.lazy(() => GetLibrarySectionsAllCollection$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "Image": "image",
    "UltraBlurColors": "ultraBlurColors",
    "Guid": "guids",
    "Media": "media",
    "Genre": "genre",
    "Country": "country",
    "Director": "director",
    "Writer": "writer",
    "Role": "role",
    "Collection": "collection",
  });
});

/** @internal */
export type GetLibrarySectionsAllMetadata$Outbound = {
  ratingKey: string;
  key: string;
  guid: string;
  slug: string;
  studio?: string | undefined;
  type: string;
  title: string;
  titleSort: string;
  contentRating?: string | undefined;
  summary: string;
  rating: number;
  audienceRating: number;
  year?: number | undefined;
  tagline: string;
  thumb: string;
  art: string;
  theme: string;
  index: number;
  leafCount?: number | undefined;
  viewedLeafCount?: number | undefined;
  childCount: number;
  seasonCount: number;
  duration: number;
  originallyAvailableAt: string;
  addedAt: number;
  updatedAt?: number | undefined;
  audienceRatingImage?: string | undefined;
  chapterSource?: string | undefined;
  primaryExtraKey?: string | undefined;
  originalTitle?: string | undefined;
  parentRatingKey?: string | undefined;
  grandparentRatingKey?: string | undefined;
  parentGuid?: string | undefined;
  grandparentGuid?: string | undefined;
  grandparentSlug?: string | undefined;
  grandparentKey?: string | undefined;
  parentKey?: string | undefined;
  grandparentTitle?: string | undefined;
  grandparentThumb?: string | undefined;
  grandparentTheme?: string | undefined;
  grandparentArt?: string | undefined;
  parentTitle?: string | undefined;
  parentIndex?: number | undefined;
  parentThumb?: string | undefined;
  ratingImage?: string | undefined;
  viewCount?: number | undefined;
  viewOffset?: number | undefined;
  skipCount?: number | undefined;
  subtype?: string | undefined;
  lastRatedAt?: number | undefined;
  createdAtAccuracy?: string | undefined;
  createdAtTZOffset?: string | undefined;
  lastViewedAt?: number | undefined;
  userRating?: number | undefined;
  Image?: Array<GetLibrarySectionsAllImage$Outbound> | undefined;
  UltraBlurColors?: GetLibrarySectionsAllUltraBlurColors$Outbound | undefined;
  Guid?: Array<GetLibrarySectionsAllGuids$Outbound> | undefined;
  Media?: Array<GetLibrarySectionsAllMedia$Outbound> | undefined;
  Genre?: Array<GetLibrarySectionsAllGenre$Outbound> | undefined;
  Country?: Array<GetLibrarySectionsAllCountry$Outbound> | undefined;
  Director?: Array<GetLibrarySectionsAllDirector$Outbound> | undefined;
  Writer?: Array<GetLibrarySectionsAllWriter$Outbound> | undefined;
  Role?: Array<GetLibrarySectionsAllRole$Outbound> | undefined;
  Collection?: Array<GetLibrarySectionsAllCollection$Outbound> | undefined;
};

/** @internal */
export const GetLibrarySectionsAllMetadata$outboundSchema: z.ZodType<
  GetLibrarySectionsAllMetadata$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllMetadata
> = z.object({
  ratingKey: z.string(),
  key: z.string(),
  guid: z.string(),
  slug: z.string(),
  studio: z.string().optional(),
  type: GetLibrarySectionsAllLibraryType$outboundSchema,
  title: z.string(),
  titleSort: z.string(),
  contentRating: z.string().optional(),
  summary: z.string(),
  rating: z.number(),
  audienceRating: z.number(),
  year: z.number().int().optional(),
  tagline: z.string(),
  thumb: z.string(),
  art: z.string(),
  theme: z.string(),
  index: z.number().int(),
  leafCount: z.number().int().optional(),
  viewedLeafCount: z.number().int().optional(),
  childCount: z.number().int(),
  seasonCount: z.number().int(),
  duration: z.number().int(),
  originallyAvailableAt: z.instanceof(RFCDate).transform(v => v.toString()),
  addedAt: z.number().int(),
  updatedAt: z.number().int().optional(),
  audienceRatingImage: z.string().optional(),
  chapterSource: z.string().optional(),
  primaryExtraKey: z.string().optional(),
  originalTitle: z.string().optional(),
  parentRatingKey: z.string().optional(),
  grandparentRatingKey: z.string().optional(),
  parentGuid: z.string().optional(),
  grandparentGuid: z.string().optional(),
  grandparentSlug: z.string().optional(),
  grandparentKey: z.string().optional(),
  parentKey: z.string().optional(),
  grandparentTitle: z.string().optional(),
  grandparentThumb: z.string().optional(),
  grandparentTheme: z.string().optional(),
  grandparentArt: z.string().optional(),
  parentTitle: z.string().optional(),
  parentIndex: z.number().int().optional(),
  parentThumb: z.string().optional(),
  ratingImage: z.string().optional(),
  viewCount: z.number().int().optional(),
  viewOffset: z.number().int().optional(),
  skipCount: z.number().int().optional(),
  subtype: z.string().optional(),
  lastRatedAt: z.number().int().optional(),
  createdAtAccuracy: z.string().optional(),
  createdAtTZOffset: z.string().optional(),
  lastViewedAt: z.number().int().optional(),
  userRating: z.number().optional(),
  image: z.array(z.lazy(() => GetLibrarySectionsAllImage$outboundSchema))
    .optional(),
  ultraBlurColors: z.lazy(() =>
    GetLibrarySectionsAllUltraBlurColors$outboundSchema
  ).optional(),
  guids: z.array(z.lazy(() => GetLibrarySectionsAllGuids$outboundSchema))
    .optional(),
  media: z.array(z.lazy(() => GetLibrarySectionsAllMedia$outboundSchema))
    .optional(),
  genre: z.array(z.lazy(() => GetLibrarySectionsAllGenre$outboundSchema))
    .optional(),
  country: z.array(z.lazy(() => GetLibrarySectionsAllCountry$outboundSchema))
    .optional(),
  director: z.array(z.lazy(() => GetLibrarySectionsAllDirector$outboundSchema))
    .optional(),
  writer: z.array(z.lazy(() => GetLibrarySectionsAllWriter$outboundSchema))
    .optional(),
  role: z.array(z.lazy(() => GetLibrarySectionsAllRole$outboundSchema))
    .optional(),
  collection: z.array(
    z.lazy(() => GetLibrarySectionsAllCollection$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    image: "Image",
    ultraBlurColors: "UltraBlurColors",
    guids: "Guid",
    media: "Media",
    genre: "Genre",
    country: "Country",
    director: "Director",
    writer: "Writer",
    role: "Role",
    collection: "Collection",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllMetadata$ {
  /** @deprecated use `GetLibrarySectionsAllMetadata$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllMetadata$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllMetadata$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllMetadata$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllMetadata$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllMetadata$Outbound;
}

export function getLibrarySectionsAllMetadataToJSON(
  getLibrarySectionsAllMetadata: GetLibrarySectionsAllMetadata,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllMetadata$outboundSchema.parse(
      getLibrarySectionsAllMetadata,
    ),
  );
}

export function getLibrarySectionsAllMetadataFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllMetadata' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllMediaContainer$inboundSchema: z.ZodType<
  GetLibrarySectionsAllMediaContainer,
  z.ZodTypeDef,
  unknown
> = z.object({
  size: z.number().int(),
  totalSize: z.number().int(),
  offset: z.number().int(),
  allowSync: z.boolean(),
  art: z.string(),
  content: z.string(),
  identifier: z.string(),
  librarySectionID: z.number().int(),
  librarySectionTitle: z.string(),
  librarySectionUUID: z.string().optional(),
  mediaTagPrefix: z.string(),
  mediaTagVersion: z.number().int(),
  thumb: z.string(),
  nocache: z.boolean(),
  title1: z.string(),
  title2: z.string(),
  viewGroup: z.string(),
  Meta: z.lazy(() => GetLibrarySectionsAllMeta$inboundSchema).optional(),
  Metadata: z.array(z.lazy(() => GetLibrarySectionsAllMetadata$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "Meta": "meta",
    "Metadata": "metadata",
  });
});

/** @internal */
export type GetLibrarySectionsAllMediaContainer$Outbound = {
  size: number;
  totalSize: number;
  offset: number;
  allowSync: boolean;
  art: string;
  content: string;
  identifier: string;
  librarySectionID: number;
  librarySectionTitle: string;
  librarySectionUUID?: string | undefined;
  mediaTagPrefix: string;
  mediaTagVersion: number;
  thumb: string;
  nocache: boolean;
  title1: string;
  title2: string;
  viewGroup: string;
  Meta?: GetLibrarySectionsAllMeta$Outbound | undefined;
  Metadata?: Array<GetLibrarySectionsAllMetadata$Outbound> | undefined;
};

/** @internal */
export const GetLibrarySectionsAllMediaContainer$outboundSchema: z.ZodType<
  GetLibrarySectionsAllMediaContainer$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllMediaContainer
> = z.object({
  size: z.number().int(),
  totalSize: z.number().int(),
  offset: z.number().int(),
  allowSync: z.boolean(),
  art: z.string(),
  content: z.string(),
  identifier: z.string(),
  librarySectionID: z.number().int(),
  librarySectionTitle: z.string(),
  librarySectionUUID: z.string().optional(),
  mediaTagPrefix: z.string(),
  mediaTagVersion: z.number().int(),
  thumb: z.string(),
  nocache: z.boolean(),
  title1: z.string(),
  title2: z.string(),
  viewGroup: z.string(),
  meta: z.lazy(() => GetLibrarySectionsAllMeta$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => GetLibrarySectionsAllMetadata$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    meta: "Meta",
    metadata: "Metadata",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllMediaContainer$ {
  /** @deprecated use `GetLibrarySectionsAllMediaContainer$inboundSchema` instead. */
  export const inboundSchema =
    GetLibrarySectionsAllMediaContainer$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllMediaContainer$outboundSchema` instead. */
  export const outboundSchema =
    GetLibrarySectionsAllMediaContainer$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllMediaContainer$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllMediaContainer$Outbound;
}

export function getLibrarySectionsAllMediaContainerToJSON(
  getLibrarySectionsAllMediaContainer: GetLibrarySectionsAllMediaContainer,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllMediaContainer$outboundSchema.parse(
      getLibrarySectionsAllMediaContainer,
    ),
  );
}

export function getLibrarySectionsAllMediaContainerFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllMediaContainer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetLibrarySectionsAllMediaContainer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllMediaContainer' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllResponseBody$inboundSchema: z.ZodType<
  GetLibrarySectionsAllResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  MediaContainer: z.lazy(() =>
    GetLibrarySectionsAllMediaContainer$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "MediaContainer": "mediaContainer",
  });
});

/** @internal */
export type GetLibrarySectionsAllResponseBody$Outbound = {
  MediaContainer?: GetLibrarySectionsAllMediaContainer$Outbound | undefined;
};

/** @internal */
export const GetLibrarySectionsAllResponseBody$outboundSchema: z.ZodType<
  GetLibrarySectionsAllResponseBody$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllResponseBody
> = z.object({
  mediaContainer: z.lazy(() =>
    GetLibrarySectionsAllMediaContainer$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    mediaContainer: "MediaContainer",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllResponseBody$ {
  /** @deprecated use `GetLibrarySectionsAllResponseBody$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllResponseBody$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllResponseBody$outboundSchema` instead. */
  export const outboundSchema =
    GetLibrarySectionsAllResponseBody$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllResponseBody$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllResponseBody$Outbound;
}

export function getLibrarySectionsAllResponseBodyToJSON(
  getLibrarySectionsAllResponseBody: GetLibrarySectionsAllResponseBody,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllResponseBody$outboundSchema.parse(
      getLibrarySectionsAllResponseBody,
    ),
  );
}

export function getLibrarySectionsAllResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllResponseBody' from JSON`,
  );
}

/** @internal */
export const GetLibrarySectionsAllResponse$inboundSchema: z.ZodType<
  GetLibrarySectionsAllResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  ContentType: z.string(),
  StatusCode: z.number().int(),
  RawResponse: z.instanceof(Response),
  object: z.lazy(() => GetLibrarySectionsAllResponseBody$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "ContentType": "contentType",
    "StatusCode": "statusCode",
    "RawResponse": "rawResponse",
  });
});

/** @internal */
export type GetLibrarySectionsAllResponse$Outbound = {
  ContentType: string;
  StatusCode: number;
  RawResponse: never;
  object?: GetLibrarySectionsAllResponseBody$Outbound | undefined;
};

/** @internal */
export const GetLibrarySectionsAllResponse$outboundSchema: z.ZodType<
  GetLibrarySectionsAllResponse$Outbound,
  z.ZodTypeDef,
  GetLibrarySectionsAllResponse
> = z.object({
  contentType: z.string(),
  statusCode: z.number().int(),
  rawResponse: z.instanceof(Response).transform(() => {
    throw new Error("Response cannot be serialized");
  }),
  object: z.lazy(() => GetLibrarySectionsAllResponseBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    contentType: "ContentType",
    statusCode: "StatusCode",
    rawResponse: "RawResponse",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetLibrarySectionsAllResponse$ {
  /** @deprecated use `GetLibrarySectionsAllResponse$inboundSchema` instead. */
  export const inboundSchema = GetLibrarySectionsAllResponse$inboundSchema;
  /** @deprecated use `GetLibrarySectionsAllResponse$outboundSchema` instead. */
  export const outboundSchema = GetLibrarySectionsAllResponse$outboundSchema;
  /** @deprecated use `GetLibrarySectionsAllResponse$Outbound` instead. */
  export type Outbound = GetLibrarySectionsAllResponse$Outbound;
}

export function getLibrarySectionsAllResponseToJSON(
  getLibrarySectionsAllResponse: GetLibrarySectionsAllResponse,
): string {
  return JSON.stringify(
    GetLibrarySectionsAllResponse$outboundSchema.parse(
      getLibrarySectionsAllResponse,
    ),
  );
}

export function getLibrarySectionsAllResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetLibrarySectionsAllResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetLibrarySectionsAllResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetLibrarySectionsAllResponse' from JSON`,
  );
}
