/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { RFCDate } from "../../types/rfcdate.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The type of media to retrieve or filter by.
 *
 * @remarks
 * 1 = movie
 * 2 = show
 * 3 = season
 * 4 = episode
 * E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries
 */
export enum Type {
  Movie = 1,
  TvShow = 2,
  Season = 3,
  Episode = 4,
  Artist = 5,
  Album = 6,
  Track = 7,
  PhotoAlbum = 8,
  Photo = 9,
}
/**
 * The type of media to retrieve or filter by.
 *
 * @remarks
 * 1 = movie
 * 2 = show
 * 3 = season
 * 4 = episode
 * E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries
 */
export type TypeOpen = OpenEnum<typeof Type>;

/**
 * Adds the Meta object to the response
 *
 * @remarks
 */
export enum IncludeMeta {
  Disable = 0,
  Enable = 1,
}

export type GetRecentlyAddedRequest = {
  /**
   * The content directory ID.
   */
  contentDirectoryID: number;
  /**
   * Comma-separated list of pinned content directory IDs.
   */
  pinnedContentDirectoryID?: string | undefined;
  /**
   * The library section ID for filtering content.
   */
  sectionID?: number | undefined;
  /**
   * The type of media to retrieve or filter by.
   *
   * @remarks
   * 1 = movie
   * 2 = show
   * 3 = season
   * 4 = episode
   * E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries
   */
  type: TypeOpen;
  /**
   * Adds the Meta object to the response
   *
   * @remarks
   */
  includeMeta?: IncludeMeta | undefined;
  /**
   * The index of the first item to return. If not specified, the first item will be returned.
   *
   * @remarks
   * If the number of items exceeds the limit, the response will be paginated.
   * By default this is 0
   */
  xPlexContainerStart?: number | undefined;
  /**
   * The number of items to return. If not specified, all items will be returned.
   *
   * @remarks
   * If the number of items exceeds the limit, the response will be paginated.
   * By default this is 50
   */
  xPlexContainerSize?: number | undefined;
};

export type GetRecentlyAddedFilter = {
  filter: string;
  filterType: string;
  key: string;
  title: string;
  type: string;
  advanced?: boolean | undefined;
};

/**
 * The direction of the sort. Can be either `asc` or `desc`.
 *
 * @remarks
 */
export enum GetRecentlyAddedActiveDirection {
  Ascending = "asc",
  Descending = "desc",
}

/**
 * The direction of the sort. Can be either `asc` or `desc`.
 *
 * @remarks
 */
export enum GetRecentlyAddedDefaultDirection {
  Ascending = "asc",
  Descending = "desc",
}

export type GetRecentlyAddedSort = {
  default?: string | undefined;
  active?: boolean | undefined;
  /**
   * The direction of the sort. Can be either `asc` or `desc`.
   *
   * @remarks
   */
  activeDirection?: GetRecentlyAddedActiveDirection | undefined;
  /**
   * The direction of the sort. Can be either `asc` or `desc`.
   *
   * @remarks
   */
  defaultDirection?: GetRecentlyAddedDefaultDirection | undefined;
  descKey?: string | undefined;
  firstCharacterKey?: string | undefined;
  key: string;
  title: string;
};

export type GetRecentlyAddedField = {
  key: string;
  title: string;
  type: string;
  subType?: string | undefined;
};

export type GetRecentlyAddedType = {
  key: string;
  type: string;
  subtype?: string | undefined;
  title: string;
  active: boolean;
  filter?: Array<GetRecentlyAddedFilter> | undefined;
  sort?: Array<GetRecentlyAddedSort> | undefined;
  field?: Array<GetRecentlyAddedField> | undefined;
};

export type GetRecentlyAddedOperator = {
  key: string;
  title: string;
};

export type GetRecentlyAddedFieldType = {
  type: string;
  operator: Array<GetRecentlyAddedOperator>;
};

/**
 * The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.
 *
 * @remarks
 */
export type Meta = {
  type?: Array<GetRecentlyAddedType> | undefined;
  fieldType?: Array<GetRecentlyAddedFieldType> | undefined;
};

/**
 * The type of media content in the Plex library. This can represent videos, music, or photos.
 *
 * @remarks
 */
export enum GetRecentlyAddedHubsType {
  Movie = "movie",
  TvShow = "show",
  Season = "season",
  Episode = "episode",
  Artist = "artist",
  Album = "album",
  Track = "track",
  PhotoAlbum = "photoalbum",
  Photo = "photo",
  Collection = "collection",
}
/**
 * The type of media content in the Plex library. This can represent videos, music, or photos.
 *
 * @remarks
 */
export type GetRecentlyAddedHubsTypeOpen = OpenEnum<
  typeof GetRecentlyAddedHubsType
>;

export enum GetRecentlyAddedHubsResponseType {
  CoverPoster = "coverPoster",
  Background = "background",
  Snapshot = "snapshot",
  ClearLogo = "clearLogo",
}
export type GetRecentlyAddedHubsResponseTypeOpen = OpenEnum<
  typeof GetRecentlyAddedHubsResponseType
>;

export type GetRecentlyAddedImage = {
  alt: string;
  type: GetRecentlyAddedHubsResponseTypeOpen;
  url: string;
};

export type UltraBlurColors = {
  topLeft: string;
  topRight: string;
  bottomRight: string;
  bottomLeft: string;
};

export type Guids = {
  /**
   * The unique identifier for the Guid. Can be prefixed with imdb://, tmdb://, tvdb://
   *
   * @remarks
   */
  id: string;
};

export enum One {
  Zero = 0,
  One = 1,
}

/**
 * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
 */
export type OptimizedForStreaming = One | boolean;

export enum GetRecentlyAddedOptimizedForStreaming1 {
  Zero = 0,
  One = 1,
}

/**
 * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
 */
export type GetRecentlyAddedOptimizedForStreaming =
  | GetRecentlyAddedOptimizedForStreaming1
  | boolean;

/**
 * Indicates if the part has a thumbnail.
 */
export enum HasThumbnail {
  False = "0",
  True = "1",
}

export type Stream = {
  /**
   * Unique stream identifier.
   */
  id: number;
  /**
   * Stream type:
   *
   * @remarks
   *   - VIDEO = 1
   *   - AUDIO = 2
   *   - SUBTITLE = 3
   */
  streamType?: 1 | undefined;
  /**
   * Format of the stream (e.g., srt).
   */
  format?: string | undefined;
  /**
   * Indicates if this stream is default.
   */
  default?: boolean | undefined;
  /**
   * Codec used by the stream.
   */
  codec: string;
  /**
   * Index of the stream.
   */
  index?: number | undefined;
  /**
   * Bitrate of the stream.
   */
  bitrate?: number | undefined;
  /**
   * Language of the stream.
   */
  language?: string | undefined;
  /**
   * Language tag (e.g., en).
   */
  languageTag?: string | undefined;
  /**
   * ISO language code.
   */
  languageCode?: string | undefined;
  /**
   * Indicates whether header compression is enabled.
   */
  headerCompression?: boolean | undefined;
  /**
   * Dolby Vision BL compatibility ID.
   */
  doviblCompatID?: number | undefined;
  /**
   * Indicates if Dolby Vision BL is present.
   */
  doviblPresent?: boolean | undefined;
  /**
   * Indicates if Dolby Vision EL is present.
   */
  dovielPresent?: boolean | undefined;
  /**
   * Dolby Vision level.
   */
  doviLevel?: number | undefined;
  /**
   * Indicates if Dolby Vision is present.
   */
  doviPresent?: boolean | undefined;
  /**
   * Dolby Vision profile.
   */
  doviProfile?: number | undefined;
  /**
   * Indicates if Dolby Vision RPU is present.
   */
  dovirpuPresent?: boolean | undefined;
  /**
   * Dolby Vision version.
   */
  doviVersion?: string | undefined;
  /**
   * Bit depth of the video stream.
   */
  bitDepth?: number | undefined;
  /**
   * Chroma sample location.
   */
  chromaLocation?: string | undefined;
  /**
   * Chroma subsampling format.
   */
  chromaSubsampling?: string | undefined;
  /**
   * Coded video height.
   */
  codedHeight?: number | undefined;
  /**
   * Coded video width.
   */
  codedWidth?: number | undefined;
  closedCaptions?: boolean | undefined;
  /**
   * Color primaries used.
   */
  colorPrimaries?: string | undefined;
  /**
   * Color range (e.g., tv).
   */
  colorRange?: string | undefined;
  /**
   * Color space.
   */
  colorSpace?: string | undefined;
  /**
   * Color transfer characteristics.
   */
  colorTrc?: string | undefined;
  /**
   * Frame rate of the stream.
   */
  frameRate?: number | undefined;
  /**
   * Key to access this stream part.
   */
  key?: string | undefined;
  /**
   * Height of the video stream.
   */
  height?: number | undefined;
  /**
   * Video level.
   */
  level?: number | undefined;
  /**
   * Indicates if this is the original stream.
   */
  original?: boolean | undefined;
  hasScalingMatrix?: boolean | undefined;
  /**
   * Video profile.
   */
  profile?: string | undefined;
  scanType?: string | undefined;
  embeddedInVideo?: string | undefined;
  /**
   * Number of reference frames.
   */
  refFrames?: number | undefined;
  /**
   * Width of the video stream.
   */
  width?: number | undefined;
  /**
   * Display title for the stream.
   */
  displayTitle: string;
  /**
   * Extended display title for the stream.
   */
  extendedDisplayTitle: string;
  /**
   * Indicates if this stream is selected (applicable for audio streams).
   */
  selected?: boolean | undefined;
  forced?: boolean | undefined;
  /**
   * Number of audio channels (for audio streams).
   */
  channels?: number | undefined;
  /**
   * Audio channel layout.
   */
  audioChannelLayout?: string | undefined;
  /**
   * Sampling rate for the audio stream.
   */
  samplingRate?: number | undefined;
  /**
   * Indicates if the stream can auto-sync.
   */
  canAutoSync?: boolean | undefined;
  /**
   * Indicates if the stream is for the hearing impaired.
   */
  hearingImpaired?: boolean | undefined;
  /**
   * Indicates if the stream is a dub.
   */
  dub?: boolean | undefined;
  /**
   * Optional title for the stream (e.g., language variant).
   */
  title?: string | undefined;
};

export type Part = {
  /**
   * Indicates if the part is accessible.
   */
  accessible?: boolean | undefined;
  /**
   * Indicates if the part exists.
   */
  exists?: boolean | undefined;
  /**
   * Unique part identifier.
   */
  id: number;
  /**
   * Key to access this part.
   */
  key: string;
  indexes?: string | undefined;
  /**
   * Duration of the part in milliseconds.
   */
  duration?: number | undefined;
  /**
   * File path for the part.
   */
  file: string;
  /**
   * File size in bytes.
   */
  size: number;
  packetLength?: number | undefined;
  /**
   * Container format of the part.
   */
  container?: string | undefined;
  /**
   * Video profile for the part.
   */
  videoProfile?: string | undefined;
  /**
   * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
   */
  audioProfile?: string | undefined;
  has64bitOffsets?: boolean | undefined;
  /**
   * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
   */
  optimizedForStreaming?:
    | GetRecentlyAddedOptimizedForStreaming1
    | boolean
    | undefined;
  hasThumbnail?: HasThumbnail | undefined;
  /**
   * An array of streams for this part.
   */
  stream?: Array<Stream> | undefined;
};

export type Media = {
  /**
   * Unique media identifier.
   */
  id: number;
  /**
   * Duration of the media in milliseconds.
   */
  duration?: number | undefined;
  /**
   * Bitrate in bits per second.
   */
  bitrate?: number | undefined;
  /**
   * Video width in pixels.
   */
  width?: number | undefined;
  /**
   * Video height in pixels.
   */
  height?: number | undefined;
  /**
   * Aspect ratio of the video.
   */
  aspectRatio?: number | undefined;
  /**
   * Number of audio channels.
   */
  audioChannels?: number | undefined;
  displayOffset?: number | undefined;
  /**
   * Audio codec used.
   */
  audioCodec?: string | undefined;
  /**
   * Video codec used.
   */
  videoCodec?: string | undefined;
  /**
   * Video resolution (e.g., 4k).
   */
  videoResolution?: string | undefined;
  /**
   * File container type.
   */
  container?: string | undefined;
  /**
   * Frame rate of the video. Values found include NTSC, PAL, 24p
   *
   * @remarks
   */
  videoFrameRate?: string | undefined;
  /**
   * Video profile (e.g., main 10).
   */
  videoProfile?: string | undefined;
  /**
   * Indicates whether voice activity is detected.
   */
  hasVoiceActivity?: boolean | undefined;
  /**
   * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
   */
  audioProfile?: string | undefined;
  /**
   * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
   */
  optimizedForStreaming?: One | boolean | undefined;
  has64bitOffsets?: boolean | undefined;
  /**
   * An array of parts for this media item.
   */
  part?: Array<Part> | undefined;
};

/**
 * The filter query string for similar items.
 */
export type Genre = {
  /**
   * The unique identifier for the genre.
   *
   * @remarks
   * NOTE: This is different for each Plex server and is not globally unique.
   */
  id: number;
  filter: string;
  /**
   * The genre name of this media-item
   *
   * @remarks
   */
  tag: string;
};

/**
 * The filter query string for country media items.
 */
export type Country = {
  /**
   * The unique identifier for the country.
   *
   * @remarks
   * NOTE: This is different for each Plex server and is not globally unique.
   */
  id: number;
  /**
   * The country of origin of this media item
   */
  tag: string;
  filter: string;
};

export type Director = {
  /**
   * Unique identifier for the director.
   */
  id: number;
  /**
   * The filter string used to query this director.
   */
  filter: string;
  /**
   * The role of Director
   */
  tag: string;
  /**
   * A unique 24-character hexadecimal key associated with the director's tag, used for internal identification.
   */
  tagKey: string;
  /**
   * The absolute URL of the thumbnail image for the director.
   */
  thumb?: string | undefined;
};

export type Writer = {
  /**
   * Unique identifier for the writer.
   */
  id: number;
  /**
   * The filter string used to query this writer.
   */
  filter: string;
  /**
   * The role of Writer
   */
  tag: string;
  /**
   * A 24-character hexadecimal unique key associated with the writer’s tag, used for internal identification.
   */
  tagKey?: string | undefined;
  /**
   * The absolute URL of the thumbnail image for the writer.
   */
  thumb?: string | undefined;
};

export type Role = {
  /**
   * The unique identifier for the role.
   *
   * @remarks
   * NOTE: This is different for each Plex server and is not globally unique.
   */
  id: number;
  /**
   * The filter string used to query this actor. For example, it may indicate that this is an actor with a given key.
   */
  filter: string;
  /**
   * The display tag for the actor (typically the actor's name).
   */
  tag: string;
  /**
   * A 24-character hexadecimal unique key associated with the actor's tag, used for internal identification.
   *
   * @remarks
   * NOTE: This is globally unique across all Plex Servers.
   */
  tagKey: string;
  /**
   * The role played by the actor in the media item.
   */
  role?: string | undefined;
  /**
   * The absolute URL of the thumbnail image for the actor.
   */
  thumb?: string | undefined;
};

export type Producer = {
  /**
   * Unique identifier for the producer.
   */
  id: number;
  /**
   * The filter string used to query this producer.
   */
  filter: string;
  /**
   * The name of the producer
   */
  tag: string;
  /**
   * A 24-character hexadecimal unique key associated with the producer's tag, used for internal identification.
   *
   * @remarks
   */
  tagKey: string;
  /**
   * The absolute URL of the thumbnail image for the producer.
   */
  thumb?: string | undefined;
};

/**
 * The type of rating, for example 'audience' or 'critic'.
 */
export type Rating = {
  /**
   * The URL for the rating image, for example from IMDb.
   */
  image: string;
  value: number;
  type: string;
};

/**
 * The display tag for the similar item, typically the title.
 */
export type Similar = {
  id: number;
  filter: string;
  tag: string;
};

/**
 * The folder path for the media item.
 */
export type Location = {
  path: string;
};

export type Collection = {
  /**
   * The user-made collection this media item belongs to
   */
  tag: string;
};

/**
 * Unknown
 *
 * @remarks
 */
export type GetRecentlyAddedMetadata = {
  addedAt: number;
  /**
   * The art image URL for the media item.
   */
  art: string;
  /**
   * The URL for the audience rating image.
   */
  audienceRatingImage?: string | undefined;
  /**
   * The audience rating for the media item.
   */
  audienceRating: number;
  /**
   * The source from which chapter data is derived.
   */
  chapterSource?: string | undefined;
  /**
   * The number of child items associated with this media item.
   */
  childCount: number;
  /**
   * The content rating for the media item.
   */
  contentRating?: string | undefined;
  /**
   * The accuracy of the creation timestamp. This value indicates the format(s) provided (for example, 'epoch,local' means both epoch and local time formats are available).
   */
  createdAtAccuracy?: string | undefined;
  /**
   * The time zone offset for the creation timestamp, represented as a string. This offset indicates the difference from UTC.
   */
  createdAtTZOffset?: string | undefined;
  /**
   * The duration of the media item in milliseconds.
   */
  duration: number;
  /**
   * The art URL for the grandparent media item.
   */
  grandparentArt?: string | undefined;
  /**
   * The GUID of the grandparent media item.
   */
  grandparentGuid?: string | undefined;
  /**
   * The key of the grandparent media item.
   */
  grandparentKey?: string | undefined;
  /**
   * The rating key of the grandparent media item.
   */
  grandparentRatingKey?: string | undefined;
  /**
   * The slug for the grandparent media item.
   */
  grandparentSlug?: string | undefined;
  /**
   * The theme URL for the grandparent media item.
   */
  grandparentTheme?: string | undefined;
  /**
   * The thumbnail URL for the grandparent media item.
   */
  grandparentThumb?: string | undefined;
  /**
   * The title of the grandparent media item.
   */
  grandparentTitle?: string | undefined;
  /**
   * The globally unique identifier for the media item.
   */
  guid: string;
  /**
   * The index position of the media item.
   */
  index: number;
  /**
   * The unique key for the media item.
   */
  key: string;
  /**
   * The Unix timestamp representing the last time the item was rated.
   */
  lastRatedAt?: number | undefined;
  /**
   * Unix timestamp for when the media item was last viewed.
   */
  lastViewedAt?: number | undefined;
  /**
   * The number of leaf items (end nodes) under this media item.
   */
  leafCount?: number | undefined;
  /**
   * The identifier for the library section.
   */
  librarySectionID?: number | undefined;
  /**
   * The key corresponding to the library section.
   */
  librarySectionKey?: string | undefined;
  /**
   * The title of the library section.
   */
  librarySectionTitle?: string | undefined;
  /**
   * The original title of the media item (if different).
   */
  originalTitle?: string | undefined;
  /**
   * The original release date of the media item.
   */
  originallyAvailableAt?: RFCDate | undefined;
  /**
   * The GUID of the parent media item.
   */
  parentGuid?: string | undefined;
  /**
   * The index position of the parent media item.
   */
  parentIndex?: number | undefined;
  /**
   * The key of the parent media item.
   */
  parentKey?: string | undefined;
  /**
   * The rating key of the parent media item.
   */
  parentRatingKey?: string | undefined;
  /**
   * The slug for the parent media item.
   */
  parentSlug?: string | undefined;
  /**
   * The studio of the parent media item.
   */
  parentStudio: string;
  /**
   * The theme URL for the parent media item.
   */
  parentTheme: string;
  /**
   * The thumbnail URL for the parent media item.
   */
  parentThumb?: string | undefined;
  /**
   * The title of the parent media item.
   */
  parentTitle?: string | undefined;
  /**
   * The release year of the parent media item.
   */
  parentYear?: number | undefined;
  /**
   * The primary extra key associated with this media item.
   */
  primaryExtraKey?: string | undefined;
  /**
   * The URL for the rating image.
   */
  ratingImage?: string | undefined;
  /**
   * The rating key (Media ID) of this media item. Note: Although this is always an integer, it is represented as a string in the API.
   */
  ratingKey: string;
  /**
   * The critic rating for the media item.
   */
  rating: number;
  /**
   * The total number of seasons (for TV shows).
   */
  seasonCount: number;
  /**
   * The number of times this media item has been skipped.
   */
  skipCount?: number | undefined;
  /**
   * A URL‐friendly version of the media title.
   */
  slug: string;
  /**
   * The studio that produced the media item.
   */
  studio?: string | undefined;
  /**
   * A classification that further describes the type of media item. For example, 'clip' indicates that the item is a short video clip.
   */
  subtype?: string | undefined;
  /**
   * A synopsis of the media item.
   */
  summary: string;
  /**
   * A brief tagline for the media item.
   */
  tagline: string;
  /**
   * The theme URL for the media item.
   */
  theme: string;
  /**
   * The thumbnail image URL for the media item.
   */
  thumb: string;
  /**
   * The sort title used for ordering media items.
   */
  titleSort: string;
  /**
   * The title of the media item.
   */
  title: string;
  type: GetRecentlyAddedHubsTypeOpen;
  /**
   * Unix epoch datetime in seconds
   */
  updatedAt?: number | undefined;
  /**
   * The rating provided by a user for the item. This value is expressed as a decimal number.
   */
  userRating?: number | undefined;
  /**
   * The number of times this media item has been viewed.
   */
  viewCount?: number | undefined;
  /**
   * The current playback offset (in milliseconds).
   */
  viewOffset?: number | undefined;
  /**
   * The number of leaf items that have been viewed.
   */
  viewedLeafCount?: number | undefined;
  /**
   * The release year of the media item.
   */
  year?: number | undefined;
  image?: Array<GetRecentlyAddedImage> | undefined;
  ultraBlurColors?: UltraBlurColors | undefined;
  guids?: Array<Guids> | undefined;
  media?: Array<Media> | undefined;
  genre?: Array<Genre> | undefined;
  country?: Array<Country> | undefined;
  director?: Array<Director> | undefined;
  writer?: Array<Writer> | undefined;
  role?: Array<Role> | undefined;
  producer?: Array<Producer> | undefined;
  rating1?: Array<Rating> | undefined;
  similar?: Array<Similar> | undefined;
  location?: Array<Location> | undefined;
  collection?: Array<Collection> | undefined;
};

export type GetRecentlyAddedMediaContainer = {
  /**
   * Number of media items returned in this response.
   */
  size: number;
  /**
   * Total number of media items in the library.
   */
  totalSize: number;
  /**
   * Offset value for pagination.
   */
  offset: number;
  /**
   * Indicates whether syncing is allowed.
   */
  allowSync: boolean;
  /**
   * An plugin identifier for the media container.
   */
  identifier: string;
  /**
   * The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.
   *
   * @remarks
   */
  meta?: Meta | undefined;
  /**
   * An array of metadata items.
   */
  metadata?: Array<GetRecentlyAddedMetadata> | undefined;
};

/**
 * A successful response with recently added content.
 */
export type GetRecentlyAddedResponseBody = {
  mediaContainer?: GetRecentlyAddedMediaContainer | undefined;
};

export type GetRecentlyAddedResponse = {
  /**
   * HTTP response content type for this operation
   */
  contentType: string;
  /**
   * HTTP response status code for this operation
   */
  statusCode: number;
  /**
   * Raw HTTP response; suitable for custom response parsing
   */
  rawResponse: Response;
  /**
   * A successful response with recently added content.
   */
  object?: GetRecentlyAddedResponseBody | undefined;
};

/** @internal */
export const Type$inboundSchema: z.ZodType<TypeOpen, z.ZodTypeDef, unknown> = z
  .union([
    z.nativeEnum(Type),
    z.number().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const Type$outboundSchema: z.ZodType<TypeOpen, z.ZodTypeDef, TypeOpen> =
  z.union([
    z.nativeEnum(Type),
    z.number().and(z.custom<Unrecognized<number>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Type$ {
  /** @deprecated use `Type$inboundSchema` instead. */
  export const inboundSchema = Type$inboundSchema;
  /** @deprecated use `Type$outboundSchema` instead. */
  export const outboundSchema = Type$outboundSchema;
}

/** @internal */
export const IncludeMeta$inboundSchema: z.ZodNativeEnum<typeof IncludeMeta> = z
  .nativeEnum(IncludeMeta);

/** @internal */
export const IncludeMeta$outboundSchema: z.ZodNativeEnum<typeof IncludeMeta> =
  IncludeMeta$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IncludeMeta$ {
  /** @deprecated use `IncludeMeta$inboundSchema` instead. */
  export const inboundSchema = IncludeMeta$inboundSchema;
  /** @deprecated use `IncludeMeta$outboundSchema` instead. */
  export const outboundSchema = IncludeMeta$outboundSchema;
}

/** @internal */
export const GetRecentlyAddedRequest$inboundSchema: z.ZodType<
  GetRecentlyAddedRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  contentDirectoryID: z.number().int(),
  pinnedContentDirectoryID: z.string().optional(),
  sectionID: z.number().int().optional(),
  type: Type$inboundSchema,
  includeMeta: IncludeMeta$inboundSchema,
  "X-Plex-Container-Start": z.number().int().default(0),
  "X-Plex-Container-Size": z.number().int().default(50),
}).transform((v) => {
  return remap$(v, {
    "X-Plex-Container-Start": "xPlexContainerStart",
    "X-Plex-Container-Size": "xPlexContainerSize",
  });
});

/** @internal */
export type GetRecentlyAddedRequest$Outbound = {
  contentDirectoryID: number;
  pinnedContentDirectoryID?: string | undefined;
  sectionID?: number | undefined;
  type: number;
  includeMeta: number;
  "X-Plex-Container-Start": number;
  "X-Plex-Container-Size": number;
};

/** @internal */
export const GetRecentlyAddedRequest$outboundSchema: z.ZodType<
  GetRecentlyAddedRequest$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedRequest
> = z.object({
  contentDirectoryID: z.number().int(),
  pinnedContentDirectoryID: z.string().optional(),
  sectionID: z.number().int().optional(),
  type: Type$outboundSchema,
  includeMeta: IncludeMeta$outboundSchema.default(IncludeMeta.Disable),
  xPlexContainerStart: z.number().int().default(0),
  xPlexContainerSize: z.number().int().default(50),
}).transform((v) => {
  return remap$(v, {
    xPlexContainerStart: "X-Plex-Container-Start",
    xPlexContainerSize: "X-Plex-Container-Size",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedRequest$ {
  /** @deprecated use `GetRecentlyAddedRequest$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedRequest$inboundSchema;
  /** @deprecated use `GetRecentlyAddedRequest$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedRequest$outboundSchema;
  /** @deprecated use `GetRecentlyAddedRequest$Outbound` instead. */
  export type Outbound = GetRecentlyAddedRequest$Outbound;
}

export function getRecentlyAddedRequestToJSON(
  getRecentlyAddedRequest: GetRecentlyAddedRequest,
): string {
  return JSON.stringify(
    GetRecentlyAddedRequest$outboundSchema.parse(getRecentlyAddedRequest),
  );
}

export function getRecentlyAddedRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedRequest' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedFilter$inboundSchema: z.ZodType<
  GetRecentlyAddedFilter,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: z.string(),
  filterType: z.string(),
  key: z.string(),
  title: z.string(),
  type: z.string(),
  advanced: z.boolean().optional(),
});

/** @internal */
export type GetRecentlyAddedFilter$Outbound = {
  filter: string;
  filterType: string;
  key: string;
  title: string;
  type: string;
  advanced?: boolean | undefined;
};

/** @internal */
export const GetRecentlyAddedFilter$outboundSchema: z.ZodType<
  GetRecentlyAddedFilter$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedFilter
> = z.object({
  filter: z.string(),
  filterType: z.string(),
  key: z.string(),
  title: z.string(),
  type: z.string(),
  advanced: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedFilter$ {
  /** @deprecated use `GetRecentlyAddedFilter$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedFilter$inboundSchema;
  /** @deprecated use `GetRecentlyAddedFilter$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedFilter$outboundSchema;
  /** @deprecated use `GetRecentlyAddedFilter$Outbound` instead. */
  export type Outbound = GetRecentlyAddedFilter$Outbound;
}

export function getRecentlyAddedFilterToJSON(
  getRecentlyAddedFilter: GetRecentlyAddedFilter,
): string {
  return JSON.stringify(
    GetRecentlyAddedFilter$outboundSchema.parse(getRecentlyAddedFilter),
  );
}

export function getRecentlyAddedFilterFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedFilter' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedActiveDirection$inboundSchema: z.ZodNativeEnum<
  typeof GetRecentlyAddedActiveDirection
> = z.nativeEnum(GetRecentlyAddedActiveDirection);

/** @internal */
export const GetRecentlyAddedActiveDirection$outboundSchema: z.ZodNativeEnum<
  typeof GetRecentlyAddedActiveDirection
> = GetRecentlyAddedActiveDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedActiveDirection$ {
  /** @deprecated use `GetRecentlyAddedActiveDirection$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedActiveDirection$inboundSchema;
  /** @deprecated use `GetRecentlyAddedActiveDirection$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedActiveDirection$outboundSchema;
}

/** @internal */
export const GetRecentlyAddedDefaultDirection$inboundSchema: z.ZodNativeEnum<
  typeof GetRecentlyAddedDefaultDirection
> = z.nativeEnum(GetRecentlyAddedDefaultDirection);

/** @internal */
export const GetRecentlyAddedDefaultDirection$outboundSchema: z.ZodNativeEnum<
  typeof GetRecentlyAddedDefaultDirection
> = GetRecentlyAddedDefaultDirection$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedDefaultDirection$ {
  /** @deprecated use `GetRecentlyAddedDefaultDirection$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedDefaultDirection$inboundSchema;
  /** @deprecated use `GetRecentlyAddedDefaultDirection$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedDefaultDirection$outboundSchema;
}

/** @internal */
export const GetRecentlyAddedSort$inboundSchema: z.ZodType<
  GetRecentlyAddedSort,
  z.ZodTypeDef,
  unknown
> = z.object({
  default: z.string().optional(),
  active: z.boolean().optional(),
  activeDirection: GetRecentlyAddedActiveDirection$inboundSchema.default(
    GetRecentlyAddedActiveDirection.Ascending,
  ),
  defaultDirection: GetRecentlyAddedDefaultDirection$inboundSchema.default(
    GetRecentlyAddedDefaultDirection.Ascending,
  ),
  descKey: z.string().optional(),
  firstCharacterKey: z.string().optional(),
  key: z.string(),
  title: z.string(),
});

/** @internal */
export type GetRecentlyAddedSort$Outbound = {
  default?: string | undefined;
  active?: boolean | undefined;
  activeDirection: string;
  defaultDirection: string;
  descKey?: string | undefined;
  firstCharacterKey?: string | undefined;
  key: string;
  title: string;
};

/** @internal */
export const GetRecentlyAddedSort$outboundSchema: z.ZodType<
  GetRecentlyAddedSort$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedSort
> = z.object({
  default: z.string().optional(),
  active: z.boolean().optional(),
  activeDirection: GetRecentlyAddedActiveDirection$outboundSchema.default(
    GetRecentlyAddedActiveDirection.Ascending,
  ),
  defaultDirection: GetRecentlyAddedDefaultDirection$outboundSchema.default(
    GetRecentlyAddedDefaultDirection.Ascending,
  ),
  descKey: z.string().optional(),
  firstCharacterKey: z.string().optional(),
  key: z.string(),
  title: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedSort$ {
  /** @deprecated use `GetRecentlyAddedSort$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedSort$inboundSchema;
  /** @deprecated use `GetRecentlyAddedSort$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedSort$outboundSchema;
  /** @deprecated use `GetRecentlyAddedSort$Outbound` instead. */
  export type Outbound = GetRecentlyAddedSort$Outbound;
}

export function getRecentlyAddedSortToJSON(
  getRecentlyAddedSort: GetRecentlyAddedSort,
): string {
  return JSON.stringify(
    GetRecentlyAddedSort$outboundSchema.parse(getRecentlyAddedSort),
  );
}

export function getRecentlyAddedSortFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedSort, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedSort$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedSort' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedField$inboundSchema: z.ZodType<
  GetRecentlyAddedField,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  title: z.string(),
  type: z.string(),
  subType: z.string().optional(),
});

/** @internal */
export type GetRecentlyAddedField$Outbound = {
  key: string;
  title: string;
  type: string;
  subType?: string | undefined;
};

/** @internal */
export const GetRecentlyAddedField$outboundSchema: z.ZodType<
  GetRecentlyAddedField$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedField
> = z.object({
  key: z.string(),
  title: z.string(),
  type: z.string(),
  subType: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedField$ {
  /** @deprecated use `GetRecentlyAddedField$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedField$inboundSchema;
  /** @deprecated use `GetRecentlyAddedField$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedField$outboundSchema;
  /** @deprecated use `GetRecentlyAddedField$Outbound` instead. */
  export type Outbound = GetRecentlyAddedField$Outbound;
}

export function getRecentlyAddedFieldToJSON(
  getRecentlyAddedField: GetRecentlyAddedField,
): string {
  return JSON.stringify(
    GetRecentlyAddedField$outboundSchema.parse(getRecentlyAddedField),
  );
}

export function getRecentlyAddedFieldFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedField, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedField$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedField' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedType$inboundSchema: z.ZodType<
  GetRecentlyAddedType,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  type: z.string(),
  subtype: z.string().optional(),
  title: z.string(),
  active: z.boolean(),
  Filter: z.array(z.lazy(() => GetRecentlyAddedFilter$inboundSchema))
    .optional(),
  Sort: z.array(z.lazy(() => GetRecentlyAddedSort$inboundSchema)).optional(),
  Field: z.array(z.lazy(() => GetRecentlyAddedField$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "Filter": "filter",
    "Sort": "sort",
    "Field": "field",
  });
});

/** @internal */
export type GetRecentlyAddedType$Outbound = {
  key: string;
  type: string;
  subtype?: string | undefined;
  title: string;
  active: boolean;
  Filter?: Array<GetRecentlyAddedFilter$Outbound> | undefined;
  Sort?: Array<GetRecentlyAddedSort$Outbound> | undefined;
  Field?: Array<GetRecentlyAddedField$Outbound> | undefined;
};

/** @internal */
export const GetRecentlyAddedType$outboundSchema: z.ZodType<
  GetRecentlyAddedType$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedType
> = z.object({
  key: z.string(),
  type: z.string(),
  subtype: z.string().optional(),
  title: z.string(),
  active: z.boolean(),
  filter: z.array(z.lazy(() => GetRecentlyAddedFilter$outboundSchema))
    .optional(),
  sort: z.array(z.lazy(() => GetRecentlyAddedSort$outboundSchema)).optional(),
  field: z.array(z.lazy(() => GetRecentlyAddedField$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    filter: "Filter",
    sort: "Sort",
    field: "Field",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedType$ {
  /** @deprecated use `GetRecentlyAddedType$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedType$inboundSchema;
  /** @deprecated use `GetRecentlyAddedType$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedType$outboundSchema;
  /** @deprecated use `GetRecentlyAddedType$Outbound` instead. */
  export type Outbound = GetRecentlyAddedType$Outbound;
}

export function getRecentlyAddedTypeToJSON(
  getRecentlyAddedType: GetRecentlyAddedType,
): string {
  return JSON.stringify(
    GetRecentlyAddedType$outboundSchema.parse(getRecentlyAddedType),
  );
}

export function getRecentlyAddedTypeFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedType' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedOperator$inboundSchema: z.ZodType<
  GetRecentlyAddedOperator,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  title: z.string(),
});

/** @internal */
export type GetRecentlyAddedOperator$Outbound = {
  key: string;
  title: string;
};

/** @internal */
export const GetRecentlyAddedOperator$outboundSchema: z.ZodType<
  GetRecentlyAddedOperator$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedOperator
> = z.object({
  key: z.string(),
  title: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedOperator$ {
  /** @deprecated use `GetRecentlyAddedOperator$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedOperator$inboundSchema;
  /** @deprecated use `GetRecentlyAddedOperator$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedOperator$outboundSchema;
  /** @deprecated use `GetRecentlyAddedOperator$Outbound` instead. */
  export type Outbound = GetRecentlyAddedOperator$Outbound;
}

export function getRecentlyAddedOperatorToJSON(
  getRecentlyAddedOperator: GetRecentlyAddedOperator,
): string {
  return JSON.stringify(
    GetRecentlyAddedOperator$outboundSchema.parse(getRecentlyAddedOperator),
  );
}

export function getRecentlyAddedOperatorFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedOperator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedOperator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedOperator' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedFieldType$inboundSchema: z.ZodType<
  GetRecentlyAddedFieldType,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string(),
  Operator: z.array(z.lazy(() => GetRecentlyAddedOperator$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "Operator": "operator",
  });
});

/** @internal */
export type GetRecentlyAddedFieldType$Outbound = {
  type: string;
  Operator: Array<GetRecentlyAddedOperator$Outbound>;
};

/** @internal */
export const GetRecentlyAddedFieldType$outboundSchema: z.ZodType<
  GetRecentlyAddedFieldType$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedFieldType
> = z.object({
  type: z.string(),
  operator: z.array(z.lazy(() => GetRecentlyAddedOperator$outboundSchema)),
}).transform((v) => {
  return remap$(v, {
    operator: "Operator",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedFieldType$ {
  /** @deprecated use `GetRecentlyAddedFieldType$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedFieldType$inboundSchema;
  /** @deprecated use `GetRecentlyAddedFieldType$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedFieldType$outboundSchema;
  /** @deprecated use `GetRecentlyAddedFieldType$Outbound` instead. */
  export type Outbound = GetRecentlyAddedFieldType$Outbound;
}

export function getRecentlyAddedFieldTypeToJSON(
  getRecentlyAddedFieldType: GetRecentlyAddedFieldType,
): string {
  return JSON.stringify(
    GetRecentlyAddedFieldType$outboundSchema.parse(getRecentlyAddedFieldType),
  );
}

export function getRecentlyAddedFieldTypeFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedFieldType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedFieldType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedFieldType' from JSON`,
  );
}

/** @internal */
export const Meta$inboundSchema: z.ZodType<Meta, z.ZodTypeDef, unknown> = z
  .object({
    Type: z.array(z.lazy(() => GetRecentlyAddedType$inboundSchema)).optional(),
    FieldType: z.array(z.lazy(() => GetRecentlyAddedFieldType$inboundSchema))
      .optional(),
  }).transform((v) => {
    return remap$(v, {
      "Type": "type",
      "FieldType": "fieldType",
    });
  });

/** @internal */
export type Meta$Outbound = {
  Type?: Array<GetRecentlyAddedType$Outbound> | undefined;
  FieldType?: Array<GetRecentlyAddedFieldType$Outbound> | undefined;
};

/** @internal */
export const Meta$outboundSchema: z.ZodType<Meta$Outbound, z.ZodTypeDef, Meta> =
  z.object({
    type: z.array(z.lazy(() => GetRecentlyAddedType$outboundSchema)).optional(),
    fieldType: z.array(z.lazy(() => GetRecentlyAddedFieldType$outboundSchema))
      .optional(),
  }).transform((v) => {
    return remap$(v, {
      type: "Type",
      fieldType: "FieldType",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Meta$ {
  /** @deprecated use `Meta$inboundSchema` instead. */
  export const inboundSchema = Meta$inboundSchema;
  /** @deprecated use `Meta$outboundSchema` instead. */
  export const outboundSchema = Meta$outboundSchema;
  /** @deprecated use `Meta$Outbound` instead. */
  export type Outbound = Meta$Outbound;
}

export function metaToJSON(meta: Meta): string {
  return JSON.stringify(Meta$outboundSchema.parse(meta));
}

export function metaFromJSON(
  jsonString: string,
): SafeParseResult<Meta, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Meta$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Meta' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedHubsType$inboundSchema: z.ZodType<
  GetRecentlyAddedHubsTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetRecentlyAddedHubsType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetRecentlyAddedHubsType$outboundSchema: z.ZodType<
  GetRecentlyAddedHubsTypeOpen,
  z.ZodTypeDef,
  GetRecentlyAddedHubsTypeOpen
> = z.union([
  z.nativeEnum(GetRecentlyAddedHubsType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedHubsType$ {
  /** @deprecated use `GetRecentlyAddedHubsType$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedHubsType$inboundSchema;
  /** @deprecated use `GetRecentlyAddedHubsType$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedHubsType$outboundSchema;
}

/** @internal */
export const GetRecentlyAddedHubsResponseType$inboundSchema: z.ZodType<
  GetRecentlyAddedHubsResponseTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetRecentlyAddedHubsResponseType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetRecentlyAddedHubsResponseType$outboundSchema: z.ZodType<
  GetRecentlyAddedHubsResponseTypeOpen,
  z.ZodTypeDef,
  GetRecentlyAddedHubsResponseTypeOpen
> = z.union([
  z.nativeEnum(GetRecentlyAddedHubsResponseType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedHubsResponseType$ {
  /** @deprecated use `GetRecentlyAddedHubsResponseType$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedHubsResponseType$inboundSchema;
  /** @deprecated use `GetRecentlyAddedHubsResponseType$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedHubsResponseType$outboundSchema;
}

/** @internal */
export const GetRecentlyAddedImage$inboundSchema: z.ZodType<
  GetRecentlyAddedImage,
  z.ZodTypeDef,
  unknown
> = z.object({
  alt: z.string(),
  type: GetRecentlyAddedHubsResponseType$inboundSchema,
  url: z.string(),
});

/** @internal */
export type GetRecentlyAddedImage$Outbound = {
  alt: string;
  type: string;
  url: string;
};

/** @internal */
export const GetRecentlyAddedImage$outboundSchema: z.ZodType<
  GetRecentlyAddedImage$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedImage
> = z.object({
  alt: z.string(),
  type: GetRecentlyAddedHubsResponseType$outboundSchema,
  url: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedImage$ {
  /** @deprecated use `GetRecentlyAddedImage$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedImage$inboundSchema;
  /** @deprecated use `GetRecentlyAddedImage$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedImage$outboundSchema;
  /** @deprecated use `GetRecentlyAddedImage$Outbound` instead. */
  export type Outbound = GetRecentlyAddedImage$Outbound;
}

export function getRecentlyAddedImageToJSON(
  getRecentlyAddedImage: GetRecentlyAddedImage,
): string {
  return JSON.stringify(
    GetRecentlyAddedImage$outboundSchema.parse(getRecentlyAddedImage),
  );
}

export function getRecentlyAddedImageFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedImage' from JSON`,
  );
}

/** @internal */
export const UltraBlurColors$inboundSchema: z.ZodType<
  UltraBlurColors,
  z.ZodTypeDef,
  unknown
> = z.object({
  topLeft: z.string(),
  topRight: z.string(),
  bottomRight: z.string(),
  bottomLeft: z.string(),
});

/** @internal */
export type UltraBlurColors$Outbound = {
  topLeft: string;
  topRight: string;
  bottomRight: string;
  bottomLeft: string;
};

/** @internal */
export const UltraBlurColors$outboundSchema: z.ZodType<
  UltraBlurColors$Outbound,
  z.ZodTypeDef,
  UltraBlurColors
> = z.object({
  topLeft: z.string(),
  topRight: z.string(),
  bottomRight: z.string(),
  bottomLeft: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UltraBlurColors$ {
  /** @deprecated use `UltraBlurColors$inboundSchema` instead. */
  export const inboundSchema = UltraBlurColors$inboundSchema;
  /** @deprecated use `UltraBlurColors$outboundSchema` instead. */
  export const outboundSchema = UltraBlurColors$outboundSchema;
  /** @deprecated use `UltraBlurColors$Outbound` instead. */
  export type Outbound = UltraBlurColors$Outbound;
}

export function ultraBlurColorsToJSON(
  ultraBlurColors: UltraBlurColors,
): string {
  return JSON.stringify(UltraBlurColors$outboundSchema.parse(ultraBlurColors));
}

export function ultraBlurColorsFromJSON(
  jsonString: string,
): SafeParseResult<UltraBlurColors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UltraBlurColors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UltraBlurColors' from JSON`,
  );
}

/** @internal */
export const Guids$inboundSchema: z.ZodType<Guids, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
  });

/** @internal */
export type Guids$Outbound = {
  id: string;
};

/** @internal */
export const Guids$outboundSchema: z.ZodType<
  Guids$Outbound,
  z.ZodTypeDef,
  Guids
> = z.object({
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Guids$ {
  /** @deprecated use `Guids$inboundSchema` instead. */
  export const inboundSchema = Guids$inboundSchema;
  /** @deprecated use `Guids$outboundSchema` instead. */
  export const outboundSchema = Guids$outboundSchema;
  /** @deprecated use `Guids$Outbound` instead. */
  export type Outbound = Guids$Outbound;
}

export function guidsToJSON(guids: Guids): string {
  return JSON.stringify(Guids$outboundSchema.parse(guids));
}

export function guidsFromJSON(
  jsonString: string,
): SafeParseResult<Guids, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Guids$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Guids' from JSON`,
  );
}

/** @internal */
export const One$inboundSchema: z.ZodNativeEnum<typeof One> = z.nativeEnum(One);

/** @internal */
export const One$outboundSchema: z.ZodNativeEnum<typeof One> =
  One$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace One$ {
  /** @deprecated use `One$inboundSchema` instead. */
  export const inboundSchema = One$inboundSchema;
  /** @deprecated use `One$outboundSchema` instead. */
  export const outboundSchema = One$outboundSchema;
}

/** @internal */
export const OptimizedForStreaming$inboundSchema: z.ZodType<
  OptimizedForStreaming,
  z.ZodTypeDef,
  unknown
> = z.union([One$inboundSchema, z.boolean()]);

/** @internal */
export type OptimizedForStreaming$Outbound = number | boolean;

/** @internal */
export const OptimizedForStreaming$outboundSchema: z.ZodType<
  OptimizedForStreaming$Outbound,
  z.ZodTypeDef,
  OptimizedForStreaming
> = z.union([One$outboundSchema, z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OptimizedForStreaming$ {
  /** @deprecated use `OptimizedForStreaming$inboundSchema` instead. */
  export const inboundSchema = OptimizedForStreaming$inboundSchema;
  /** @deprecated use `OptimizedForStreaming$outboundSchema` instead. */
  export const outboundSchema = OptimizedForStreaming$outboundSchema;
  /** @deprecated use `OptimizedForStreaming$Outbound` instead. */
  export type Outbound = OptimizedForStreaming$Outbound;
}

export function optimizedForStreamingToJSON(
  optimizedForStreaming: OptimizedForStreaming,
): string {
  return JSON.stringify(
    OptimizedForStreaming$outboundSchema.parse(optimizedForStreaming),
  );
}

export function optimizedForStreamingFromJSON(
  jsonString: string,
): SafeParseResult<OptimizedForStreaming, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OptimizedForStreaming$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OptimizedForStreaming' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedOptimizedForStreaming1$inboundSchema:
  z.ZodNativeEnum<typeof GetRecentlyAddedOptimizedForStreaming1> = z.nativeEnum(
    GetRecentlyAddedOptimizedForStreaming1,
  );

/** @internal */
export const GetRecentlyAddedOptimizedForStreaming1$outboundSchema:
  z.ZodNativeEnum<typeof GetRecentlyAddedOptimizedForStreaming1> =
    GetRecentlyAddedOptimizedForStreaming1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedOptimizedForStreaming1$ {
  /** @deprecated use `GetRecentlyAddedOptimizedForStreaming1$inboundSchema` instead. */
  export const inboundSchema =
    GetRecentlyAddedOptimizedForStreaming1$inboundSchema;
  /** @deprecated use `GetRecentlyAddedOptimizedForStreaming1$outboundSchema` instead. */
  export const outboundSchema =
    GetRecentlyAddedOptimizedForStreaming1$outboundSchema;
}

/** @internal */
export const GetRecentlyAddedOptimizedForStreaming$inboundSchema: z.ZodType<
  GetRecentlyAddedOptimizedForStreaming,
  z.ZodTypeDef,
  unknown
> = z.union([
  GetRecentlyAddedOptimizedForStreaming1$inboundSchema,
  z.boolean(),
]);

/** @internal */
export type GetRecentlyAddedOptimizedForStreaming$Outbound = number | boolean;

/** @internal */
export const GetRecentlyAddedOptimizedForStreaming$outboundSchema: z.ZodType<
  GetRecentlyAddedOptimizedForStreaming$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedOptimizedForStreaming
> = z.union([
  GetRecentlyAddedOptimizedForStreaming1$outboundSchema,
  z.boolean(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedOptimizedForStreaming$ {
  /** @deprecated use `GetRecentlyAddedOptimizedForStreaming$inboundSchema` instead. */
  export const inboundSchema =
    GetRecentlyAddedOptimizedForStreaming$inboundSchema;
  /** @deprecated use `GetRecentlyAddedOptimizedForStreaming$outboundSchema` instead. */
  export const outboundSchema =
    GetRecentlyAddedOptimizedForStreaming$outboundSchema;
  /** @deprecated use `GetRecentlyAddedOptimizedForStreaming$Outbound` instead. */
  export type Outbound = GetRecentlyAddedOptimizedForStreaming$Outbound;
}

export function getRecentlyAddedOptimizedForStreamingToJSON(
  getRecentlyAddedOptimizedForStreaming: GetRecentlyAddedOptimizedForStreaming,
): string {
  return JSON.stringify(
    GetRecentlyAddedOptimizedForStreaming$outboundSchema.parse(
      getRecentlyAddedOptimizedForStreaming,
    ),
  );
}

export function getRecentlyAddedOptimizedForStreamingFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedOptimizedForStreaming, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetRecentlyAddedOptimizedForStreaming$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedOptimizedForStreaming' from JSON`,
  );
}

/** @internal */
export const HasThumbnail$inboundSchema: z.ZodNativeEnum<typeof HasThumbnail> =
  z.nativeEnum(HasThumbnail);

/** @internal */
export const HasThumbnail$outboundSchema: z.ZodNativeEnum<typeof HasThumbnail> =
  HasThumbnail$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace HasThumbnail$ {
  /** @deprecated use `HasThumbnail$inboundSchema` instead. */
  export const inboundSchema = HasThumbnail$inboundSchema;
  /** @deprecated use `HasThumbnail$outboundSchema` instead. */
  export const outboundSchema = HasThumbnail$outboundSchema;
}

/** @internal */
export const Stream$inboundSchema: z.ZodType<Stream, z.ZodTypeDef, unknown> = z
  .object({
    id: z.number().int(),
    streamType: z.literal(1).optional(),
    format: z.string().optional(),
    default: z.boolean().optional(),
    codec: z.string(),
    index: z.number().int().optional(),
    bitrate: z.number().int().optional(),
    language: z.string().optional(),
    languageTag: z.string().optional(),
    languageCode: z.string().optional(),
    headerCompression: z.boolean().optional(),
    DOVIBLCompatID: z.number().int().optional(),
    DOVIBLPresent: z.boolean().optional(),
    DOVIELPresent: z.boolean().optional(),
    DOVILevel: z.number().int().optional(),
    DOVIPresent: z.boolean().optional(),
    DOVIProfile: z.number().int().optional(),
    DOVIRPUPresent: z.boolean().optional(),
    DOVIVersion: z.string().optional(),
    bitDepth: z.number().int().optional(),
    chromaLocation: z.string().optional(),
    chromaSubsampling: z.string().optional(),
    codedHeight: z.number().int().optional(),
    codedWidth: z.number().int().optional(),
    closedCaptions: z.boolean().optional(),
    colorPrimaries: z.string().optional(),
    colorRange: z.string().optional(),
    colorSpace: z.string().optional(),
    colorTrc: z.string().optional(),
    frameRate: z.number().optional(),
    key: z.string().optional(),
    height: z.number().int().optional(),
    level: z.number().int().optional(),
    original: z.boolean().optional(),
    hasScalingMatrix: z.boolean().optional(),
    profile: z.string().optional(),
    scanType: z.string().optional(),
    embeddedInVideo: z.string().optional(),
    refFrames: z.number().int().optional(),
    width: z.number().int().optional(),
    displayTitle: z.string(),
    extendedDisplayTitle: z.string(),
    selected: z.boolean().optional(),
    forced: z.boolean().optional(),
    channels: z.number().int().optional(),
    audioChannelLayout: z.string().optional(),
    samplingRate: z.number().int().optional(),
    canAutoSync: z.boolean().optional(),
    hearingImpaired: z.boolean().optional(),
    dub: z.boolean().optional(),
    title: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "DOVIBLCompatID": "doviblCompatID",
      "DOVIBLPresent": "doviblPresent",
      "DOVIELPresent": "dovielPresent",
      "DOVILevel": "doviLevel",
      "DOVIPresent": "doviPresent",
      "DOVIProfile": "doviProfile",
      "DOVIRPUPresent": "dovirpuPresent",
      "DOVIVersion": "doviVersion",
    });
  });

/** @internal */
export type Stream$Outbound = {
  id: number;
  streamType: 1;
  format?: string | undefined;
  default?: boolean | undefined;
  codec: string;
  index?: number | undefined;
  bitrate?: number | undefined;
  language?: string | undefined;
  languageTag?: string | undefined;
  languageCode?: string | undefined;
  headerCompression?: boolean | undefined;
  DOVIBLCompatID?: number | undefined;
  DOVIBLPresent?: boolean | undefined;
  DOVIELPresent?: boolean | undefined;
  DOVILevel?: number | undefined;
  DOVIPresent?: boolean | undefined;
  DOVIProfile?: number | undefined;
  DOVIRPUPresent?: boolean | undefined;
  DOVIVersion?: string | undefined;
  bitDepth?: number | undefined;
  chromaLocation?: string | undefined;
  chromaSubsampling?: string | undefined;
  codedHeight?: number | undefined;
  codedWidth?: number | undefined;
  closedCaptions?: boolean | undefined;
  colorPrimaries?: string | undefined;
  colorRange?: string | undefined;
  colorSpace?: string | undefined;
  colorTrc?: string | undefined;
  frameRate?: number | undefined;
  key?: string | undefined;
  height?: number | undefined;
  level?: number | undefined;
  original?: boolean | undefined;
  hasScalingMatrix?: boolean | undefined;
  profile?: string | undefined;
  scanType?: string | undefined;
  embeddedInVideo?: string | undefined;
  refFrames?: number | undefined;
  width?: number | undefined;
  displayTitle: string;
  extendedDisplayTitle: string;
  selected?: boolean | undefined;
  forced?: boolean | undefined;
  channels?: number | undefined;
  audioChannelLayout?: string | undefined;
  samplingRate?: number | undefined;
  canAutoSync?: boolean | undefined;
  hearingImpaired?: boolean | undefined;
  dub?: boolean | undefined;
  title?: string | undefined;
};

/** @internal */
export const Stream$outboundSchema: z.ZodType<
  Stream$Outbound,
  z.ZodTypeDef,
  Stream
> = z.object({
  id: z.number().int(),
  streamType: z.literal(1).default(1 as const),
  format: z.string().optional(),
  default: z.boolean().optional(),
  codec: z.string(),
  index: z.number().int().optional(),
  bitrate: z.number().int().optional(),
  language: z.string().optional(),
  languageTag: z.string().optional(),
  languageCode: z.string().optional(),
  headerCompression: z.boolean().optional(),
  doviblCompatID: z.number().int().optional(),
  doviblPresent: z.boolean().optional(),
  dovielPresent: z.boolean().optional(),
  doviLevel: z.number().int().optional(),
  doviPresent: z.boolean().optional(),
  doviProfile: z.number().int().optional(),
  dovirpuPresent: z.boolean().optional(),
  doviVersion: z.string().optional(),
  bitDepth: z.number().int().optional(),
  chromaLocation: z.string().optional(),
  chromaSubsampling: z.string().optional(),
  codedHeight: z.number().int().optional(),
  codedWidth: z.number().int().optional(),
  closedCaptions: z.boolean().optional(),
  colorPrimaries: z.string().optional(),
  colorRange: z.string().optional(),
  colorSpace: z.string().optional(),
  colorTrc: z.string().optional(),
  frameRate: z.number().optional(),
  key: z.string().optional(),
  height: z.number().int().optional(),
  level: z.number().int().optional(),
  original: z.boolean().optional(),
  hasScalingMatrix: z.boolean().optional(),
  profile: z.string().optional(),
  scanType: z.string().optional(),
  embeddedInVideo: z.string().optional(),
  refFrames: z.number().int().optional(),
  width: z.number().int().optional(),
  displayTitle: z.string(),
  extendedDisplayTitle: z.string(),
  selected: z.boolean().optional(),
  forced: z.boolean().optional(),
  channels: z.number().int().optional(),
  audioChannelLayout: z.string().optional(),
  samplingRate: z.number().int().optional(),
  canAutoSync: z.boolean().optional(),
  hearingImpaired: z.boolean().optional(),
  dub: z.boolean().optional(),
  title: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    doviblCompatID: "DOVIBLCompatID",
    doviblPresent: "DOVIBLPresent",
    dovielPresent: "DOVIELPresent",
    doviLevel: "DOVILevel",
    doviPresent: "DOVIPresent",
    doviProfile: "DOVIProfile",
    dovirpuPresent: "DOVIRPUPresent",
    doviVersion: "DOVIVersion",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Stream$ {
  /** @deprecated use `Stream$inboundSchema` instead. */
  export const inboundSchema = Stream$inboundSchema;
  /** @deprecated use `Stream$outboundSchema` instead. */
  export const outboundSchema = Stream$outboundSchema;
  /** @deprecated use `Stream$Outbound` instead. */
  export type Outbound = Stream$Outbound;
}

export function streamToJSON(stream: Stream): string {
  return JSON.stringify(Stream$outboundSchema.parse(stream));
}

export function streamFromJSON(
  jsonString: string,
): SafeParseResult<Stream, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Stream$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Stream' from JSON`,
  );
}

/** @internal */
export const Part$inboundSchema: z.ZodType<Part, z.ZodTypeDef, unknown> = z
  .object({
    accessible: z.boolean().optional(),
    exists: z.boolean().optional(),
    id: z.number().int(),
    key: z.string(),
    indexes: z.string().optional(),
    duration: z.number().int().optional(),
    file: z.string(),
    size: z.number().int(),
    packetLength: z.number().int().optional(),
    container: z.string().optional(),
    videoProfile: z.string().optional(),
    audioProfile: z.string().optional(),
    has64bitOffsets: z.boolean().optional(),
    optimizedForStreaming: z.union([
      GetRecentlyAddedOptimizedForStreaming1$inboundSchema,
      z.boolean(),
    ]).optional(),
    hasThumbnail: HasThumbnail$inboundSchema.default(HasThumbnail.False),
    Stream: z.array(z.lazy(() => Stream$inboundSchema)).optional(),
  }).transform((v) => {
    return remap$(v, {
      "Stream": "stream",
    });
  });

/** @internal */
export type Part$Outbound = {
  accessible?: boolean | undefined;
  exists?: boolean | undefined;
  id: number;
  key: string;
  indexes?: string | undefined;
  duration?: number | undefined;
  file: string;
  size: number;
  packetLength?: number | undefined;
  container?: string | undefined;
  videoProfile?: string | undefined;
  audioProfile?: string | undefined;
  has64bitOffsets?: boolean | undefined;
  optimizedForStreaming?: number | boolean | undefined;
  hasThumbnail: string;
  Stream?: Array<Stream$Outbound> | undefined;
};

/** @internal */
export const Part$outboundSchema: z.ZodType<Part$Outbound, z.ZodTypeDef, Part> =
  z.object({
    accessible: z.boolean().optional(),
    exists: z.boolean().optional(),
    id: z.number().int(),
    key: z.string(),
    indexes: z.string().optional(),
    duration: z.number().int().optional(),
    file: z.string(),
    size: z.number().int(),
    packetLength: z.number().int().optional(),
    container: z.string().optional(),
    videoProfile: z.string().optional(),
    audioProfile: z.string().optional(),
    has64bitOffsets: z.boolean().optional(),
    optimizedForStreaming: z.union([
      GetRecentlyAddedOptimizedForStreaming1$outboundSchema,
      z.boolean(),
    ]).optional(),
    hasThumbnail: HasThumbnail$outboundSchema.default(HasThumbnail.False),
    stream: z.array(z.lazy(() => Stream$outboundSchema)).optional(),
  }).transform((v) => {
    return remap$(v, {
      stream: "Stream",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Part$ {
  /** @deprecated use `Part$inboundSchema` instead. */
  export const inboundSchema = Part$inboundSchema;
  /** @deprecated use `Part$outboundSchema` instead. */
  export const outboundSchema = Part$outboundSchema;
  /** @deprecated use `Part$Outbound` instead. */
  export type Outbound = Part$Outbound;
}

export function partToJSON(part: Part): string {
  return JSON.stringify(Part$outboundSchema.parse(part));
}

export function partFromJSON(
  jsonString: string,
): SafeParseResult<Part, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Part$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Part' from JSON`,
  );
}

/** @internal */
export const Media$inboundSchema: z.ZodType<Media, z.ZodTypeDef, unknown> = z
  .object({
    id: z.number().int(),
    duration: z.number().int().optional(),
    bitrate: z.number().int().optional(),
    width: z.number().int().optional(),
    height: z.number().int().optional(),
    aspectRatio: z.number().optional(),
    audioChannels: z.number().int().optional(),
    displayOffset: z.number().int().optional(),
    audioCodec: z.string().optional(),
    videoCodec: z.string().optional(),
    videoResolution: z.string().optional(),
    container: z.string().optional(),
    videoFrameRate: z.string().optional(),
    videoProfile: z.string().optional(),
    hasVoiceActivity: z.boolean().optional(),
    audioProfile: z.string().optional(),
    optimizedForStreaming: z.union([One$inboundSchema, z.boolean()]).optional(),
    has64bitOffsets: z.boolean().optional(),
    Part: z.array(z.lazy(() => Part$inboundSchema)).optional(),
  }).transform((v) => {
    return remap$(v, {
      "Part": "part",
    });
  });

/** @internal */
export type Media$Outbound = {
  id: number;
  duration?: number | undefined;
  bitrate?: number | undefined;
  width?: number | undefined;
  height?: number | undefined;
  aspectRatio?: number | undefined;
  audioChannels?: number | undefined;
  displayOffset?: number | undefined;
  audioCodec?: string | undefined;
  videoCodec?: string | undefined;
  videoResolution?: string | undefined;
  container?: string | undefined;
  videoFrameRate?: string | undefined;
  videoProfile?: string | undefined;
  hasVoiceActivity?: boolean | undefined;
  audioProfile?: string | undefined;
  optimizedForStreaming?: number | boolean | undefined;
  has64bitOffsets?: boolean | undefined;
  Part?: Array<Part$Outbound> | undefined;
};

/** @internal */
export const Media$outboundSchema: z.ZodType<
  Media$Outbound,
  z.ZodTypeDef,
  Media
> = z.object({
  id: z.number().int(),
  duration: z.number().int().optional(),
  bitrate: z.number().int().optional(),
  width: z.number().int().optional(),
  height: z.number().int().optional(),
  aspectRatio: z.number().optional(),
  audioChannels: z.number().int().optional(),
  displayOffset: z.number().int().optional(),
  audioCodec: z.string().optional(),
  videoCodec: z.string().optional(),
  videoResolution: z.string().optional(),
  container: z.string().optional(),
  videoFrameRate: z.string().optional(),
  videoProfile: z.string().optional(),
  hasVoiceActivity: z.boolean().optional(),
  audioProfile: z.string().optional(),
  optimizedForStreaming: z.union([One$outboundSchema, z.boolean()]).optional(),
  has64bitOffsets: z.boolean().optional(),
  part: z.array(z.lazy(() => Part$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    part: "Part",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Media$ {
  /** @deprecated use `Media$inboundSchema` instead. */
  export const inboundSchema = Media$inboundSchema;
  /** @deprecated use `Media$outboundSchema` instead. */
  export const outboundSchema = Media$outboundSchema;
  /** @deprecated use `Media$Outbound` instead. */
  export type Outbound = Media$Outbound;
}

export function mediaToJSON(media: Media): string {
  return JSON.stringify(Media$outboundSchema.parse(media));
}

export function mediaFromJSON(
  jsonString: string,
): SafeParseResult<Media, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Media$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Media' from JSON`,
  );
}

/** @internal */
export const Genre$inboundSchema: z.ZodType<Genre, z.ZodTypeDef, unknown> = z
  .object({
    id: z.number().int(),
    filter: z.string(),
    tag: z.string(),
  });

/** @internal */
export type Genre$Outbound = {
  id: number;
  filter: string;
  tag: string;
};

/** @internal */
export const Genre$outboundSchema: z.ZodType<
  Genre$Outbound,
  z.ZodTypeDef,
  Genre
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  tag: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Genre$ {
  /** @deprecated use `Genre$inboundSchema` instead. */
  export const inboundSchema = Genre$inboundSchema;
  /** @deprecated use `Genre$outboundSchema` instead. */
  export const outboundSchema = Genre$outboundSchema;
  /** @deprecated use `Genre$Outbound` instead. */
  export type Outbound = Genre$Outbound;
}

export function genreToJSON(genre: Genre): string {
  return JSON.stringify(Genre$outboundSchema.parse(genre));
}

export function genreFromJSON(
  jsonString: string,
): SafeParseResult<Genre, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Genre$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Genre' from JSON`,
  );
}

/** @internal */
export const Country$inboundSchema: z.ZodType<Country, z.ZodTypeDef, unknown> =
  z.object({
    id: z.number().int(),
    tag: z.string(),
    filter: z.string(),
  });

/** @internal */
export type Country$Outbound = {
  id: number;
  tag: string;
  filter: string;
};

/** @internal */
export const Country$outboundSchema: z.ZodType<
  Country$Outbound,
  z.ZodTypeDef,
  Country
> = z.object({
  id: z.number().int(),
  tag: z.string(),
  filter: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Country$ {
  /** @deprecated use `Country$inboundSchema` instead. */
  export const inboundSchema = Country$inboundSchema;
  /** @deprecated use `Country$outboundSchema` instead. */
  export const outboundSchema = Country$outboundSchema;
  /** @deprecated use `Country$Outbound` instead. */
  export type Outbound = Country$Outbound;
}

export function countryToJSON(country: Country): string {
  return JSON.stringify(Country$outboundSchema.parse(country));
}

export function countryFromJSON(
  jsonString: string,
): SafeParseResult<Country, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Country$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Country' from JSON`,
  );
}

/** @internal */
export const Director$inboundSchema: z.ZodType<
  Director,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  tag: z.string(),
  tagKey: z.string(),
  thumb: z.string().optional(),
});

/** @internal */
export type Director$Outbound = {
  id: number;
  filter: string;
  tag: string;
  tagKey: string;
  thumb?: string | undefined;
};

/** @internal */
export const Director$outboundSchema: z.ZodType<
  Director$Outbound,
  z.ZodTypeDef,
  Director
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  tag: z.string(),
  tagKey: z.string(),
  thumb: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Director$ {
  /** @deprecated use `Director$inboundSchema` instead. */
  export const inboundSchema = Director$inboundSchema;
  /** @deprecated use `Director$outboundSchema` instead. */
  export const outboundSchema = Director$outboundSchema;
  /** @deprecated use `Director$Outbound` instead. */
  export type Outbound = Director$Outbound;
}

export function directorToJSON(director: Director): string {
  return JSON.stringify(Director$outboundSchema.parse(director));
}

export function directorFromJSON(
  jsonString: string,
): SafeParseResult<Director, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Director$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Director' from JSON`,
  );
}

/** @internal */
export const Writer$inboundSchema: z.ZodType<Writer, z.ZodTypeDef, unknown> = z
  .object({
    id: z.number().int(),
    filter: z.string(),
    tag: z.string(),
    tagKey: z.string().optional(),
    thumb: z.string().optional(),
  });

/** @internal */
export type Writer$Outbound = {
  id: number;
  filter: string;
  tag: string;
  tagKey?: string | undefined;
  thumb?: string | undefined;
};

/** @internal */
export const Writer$outboundSchema: z.ZodType<
  Writer$Outbound,
  z.ZodTypeDef,
  Writer
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  tag: z.string(),
  tagKey: z.string().optional(),
  thumb: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Writer$ {
  /** @deprecated use `Writer$inboundSchema` instead. */
  export const inboundSchema = Writer$inboundSchema;
  /** @deprecated use `Writer$outboundSchema` instead. */
  export const outboundSchema = Writer$outboundSchema;
  /** @deprecated use `Writer$Outbound` instead. */
  export type Outbound = Writer$Outbound;
}

export function writerToJSON(writer: Writer): string {
  return JSON.stringify(Writer$outboundSchema.parse(writer));
}

export function writerFromJSON(
  jsonString: string,
): SafeParseResult<Writer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Writer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Writer' from JSON`,
  );
}

/** @internal */
export const Role$inboundSchema: z.ZodType<Role, z.ZodTypeDef, unknown> = z
  .object({
    id: z.number().int(),
    filter: z.string(),
    tag: z.string(),
    tagKey: z.string(),
    role: z.string().optional(),
    thumb: z.string().optional(),
  });

/** @internal */
export type Role$Outbound = {
  id: number;
  filter: string;
  tag: string;
  tagKey: string;
  role?: string | undefined;
  thumb?: string | undefined;
};

/** @internal */
export const Role$outboundSchema: z.ZodType<Role$Outbound, z.ZodTypeDef, Role> =
  z.object({
    id: z.number().int(),
    filter: z.string(),
    tag: z.string(),
    tagKey: z.string(),
    role: z.string().optional(),
    thumb: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Role$ {
  /** @deprecated use `Role$inboundSchema` instead. */
  export const inboundSchema = Role$inboundSchema;
  /** @deprecated use `Role$outboundSchema` instead. */
  export const outboundSchema = Role$outboundSchema;
  /** @deprecated use `Role$Outbound` instead. */
  export type Outbound = Role$Outbound;
}

export function roleToJSON(role: Role): string {
  return JSON.stringify(Role$outboundSchema.parse(role));
}

export function roleFromJSON(
  jsonString: string,
): SafeParseResult<Role, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Role$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Role' from JSON`,
  );
}

/** @internal */
export const Producer$inboundSchema: z.ZodType<
  Producer,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  tag: z.string(),
  tagKey: z.string(),
  thumb: z.string().optional(),
});

/** @internal */
export type Producer$Outbound = {
  id: number;
  filter: string;
  tag: string;
  tagKey: string;
  thumb?: string | undefined;
};

/** @internal */
export const Producer$outboundSchema: z.ZodType<
  Producer$Outbound,
  z.ZodTypeDef,
  Producer
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  tag: z.string(),
  tagKey: z.string(),
  thumb: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Producer$ {
  /** @deprecated use `Producer$inboundSchema` instead. */
  export const inboundSchema = Producer$inboundSchema;
  /** @deprecated use `Producer$outboundSchema` instead. */
  export const outboundSchema = Producer$outboundSchema;
  /** @deprecated use `Producer$Outbound` instead. */
  export type Outbound = Producer$Outbound;
}

export function producerToJSON(producer: Producer): string {
  return JSON.stringify(Producer$outboundSchema.parse(producer));
}

export function producerFromJSON(
  jsonString: string,
): SafeParseResult<Producer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Producer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Producer' from JSON`,
  );
}

/** @internal */
export const Rating$inboundSchema: z.ZodType<Rating, z.ZodTypeDef, unknown> = z
  .object({
    image: z.string(),
    value: z.number(),
    type: z.string(),
  });

/** @internal */
export type Rating$Outbound = {
  image: string;
  value: number;
  type: string;
};

/** @internal */
export const Rating$outboundSchema: z.ZodType<
  Rating$Outbound,
  z.ZodTypeDef,
  Rating
> = z.object({
  image: z.string(),
  value: z.number(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Rating$ {
  /** @deprecated use `Rating$inboundSchema` instead. */
  export const inboundSchema = Rating$inboundSchema;
  /** @deprecated use `Rating$outboundSchema` instead. */
  export const outboundSchema = Rating$outboundSchema;
  /** @deprecated use `Rating$Outbound` instead. */
  export type Outbound = Rating$Outbound;
}

export function ratingToJSON(rating: Rating): string {
  return JSON.stringify(Rating$outboundSchema.parse(rating));
}

export function ratingFromJSON(
  jsonString: string,
): SafeParseResult<Rating, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Rating$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Rating' from JSON`,
  );
}

/** @internal */
export const Similar$inboundSchema: z.ZodType<Similar, z.ZodTypeDef, unknown> =
  z.object({
    id: z.number().int(),
    filter: z.string(),
    tag: z.string(),
  });

/** @internal */
export type Similar$Outbound = {
  id: number;
  filter: string;
  tag: string;
};

/** @internal */
export const Similar$outboundSchema: z.ZodType<
  Similar$Outbound,
  z.ZodTypeDef,
  Similar
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  tag: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Similar$ {
  /** @deprecated use `Similar$inboundSchema` instead. */
  export const inboundSchema = Similar$inboundSchema;
  /** @deprecated use `Similar$outboundSchema` instead. */
  export const outboundSchema = Similar$outboundSchema;
  /** @deprecated use `Similar$Outbound` instead. */
  export type Outbound = Similar$Outbound;
}

export function similarToJSON(similar: Similar): string {
  return JSON.stringify(Similar$outboundSchema.parse(similar));
}

export function similarFromJSON(
  jsonString: string,
): SafeParseResult<Similar, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Similar$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Similar' from JSON`,
  );
}

/** @internal */
export const Location$inboundSchema: z.ZodType<
  Location,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
});

/** @internal */
export type Location$Outbound = {
  path: string;
};

/** @internal */
export const Location$outboundSchema: z.ZodType<
  Location$Outbound,
  z.ZodTypeDef,
  Location
> = z.object({
  path: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Location$ {
  /** @deprecated use `Location$inboundSchema` instead. */
  export const inboundSchema = Location$inboundSchema;
  /** @deprecated use `Location$outboundSchema` instead. */
  export const outboundSchema = Location$outboundSchema;
  /** @deprecated use `Location$Outbound` instead. */
  export type Outbound = Location$Outbound;
}

export function locationToJSON(location: Location): string {
  return JSON.stringify(Location$outboundSchema.parse(location));
}

export function locationFromJSON(
  jsonString: string,
): SafeParseResult<Location, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Location$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Location' from JSON`,
  );
}

/** @internal */
export const Collection$inboundSchema: z.ZodType<
  Collection,
  z.ZodTypeDef,
  unknown
> = z.object({
  tag: z.string(),
});

/** @internal */
export type Collection$Outbound = {
  tag: string;
};

/** @internal */
export const Collection$outboundSchema: z.ZodType<
  Collection$Outbound,
  z.ZodTypeDef,
  Collection
> = z.object({
  tag: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Collection$ {
  /** @deprecated use `Collection$inboundSchema` instead. */
  export const inboundSchema = Collection$inboundSchema;
  /** @deprecated use `Collection$outboundSchema` instead. */
  export const outboundSchema = Collection$outboundSchema;
  /** @deprecated use `Collection$Outbound` instead. */
  export type Outbound = Collection$Outbound;
}

export function collectionToJSON(collection: Collection): string {
  return JSON.stringify(Collection$outboundSchema.parse(collection));
}

export function collectionFromJSON(
  jsonString: string,
): SafeParseResult<Collection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Collection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Collection' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedMetadata$inboundSchema: z.ZodType<
  GetRecentlyAddedMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  addedAt: z.number().int(),
  art: z.string(),
  audienceRatingImage: z.string().optional(),
  audienceRating: z.number(),
  chapterSource: z.string().optional(),
  childCount: z.number().int(),
  contentRating: z.string().optional(),
  createdAtAccuracy: z.string().optional(),
  createdAtTZOffset: z.string().optional(),
  duration: z.number().int(),
  grandparentArt: z.string().optional(),
  grandparentGuid: z.string().optional(),
  grandparentKey: z.string().optional(),
  grandparentRatingKey: z.string().optional(),
  grandparentSlug: z.string().optional(),
  grandparentTheme: z.string().optional(),
  grandparentThumb: z.string().optional(),
  grandparentTitle: z.string().optional(),
  guid: z.string(),
  index: z.number().int(),
  key: z.string(),
  lastRatedAt: z.number().int().optional(),
  lastViewedAt: z.number().int().optional(),
  leafCount: z.number().int().optional(),
  librarySectionID: z.number().int().optional(),
  librarySectionKey: z.string().optional(),
  librarySectionTitle: z.string().optional(),
  originalTitle: z.string().optional(),
  originallyAvailableAt: z.string().transform(v => new RFCDate(v)).optional(),
  parentGuid: z.string().optional(),
  parentIndex: z.number().int().optional(),
  parentKey: z.string().optional(),
  parentRatingKey: z.string().optional(),
  parentSlug: z.string().optional(),
  parentStudio: z.string(),
  parentTheme: z.string(),
  parentThumb: z.string().optional(),
  parentTitle: z.string().optional(),
  parentYear: z.number().int().optional(),
  primaryExtraKey: z.string().optional(),
  ratingImage: z.string().optional(),
  ratingKey: z.string(),
  rating: z.number(),
  seasonCount: z.number().int(),
  skipCount: z.number().int().optional(),
  slug: z.string(),
  studio: z.string().optional(),
  subtype: z.string().optional(),
  summary: z.string(),
  tagline: z.string(),
  theme: z.string(),
  thumb: z.string(),
  titleSort: z.string(),
  title: z.string(),
  type: GetRecentlyAddedHubsType$inboundSchema,
  updatedAt: z.number().int().optional(),
  userRating: z.number().optional(),
  viewCount: z.number().int().optional(),
  viewOffset: z.number().int().optional(),
  viewedLeafCount: z.number().int().optional(),
  year: z.number().int().optional(),
  Image: z.array(z.lazy(() => GetRecentlyAddedImage$inboundSchema)).optional(),
  UltraBlurColors: z.lazy(() => UltraBlurColors$inboundSchema).optional(),
  Guid: z.array(z.lazy(() => Guids$inboundSchema)).optional(),
  Media: z.array(z.lazy(() => Media$inboundSchema)).optional(),
  Genre: z.array(z.lazy(() => Genre$inboundSchema)).optional(),
  Country: z.array(z.lazy(() => Country$inboundSchema)).optional(),
  Director: z.array(z.lazy(() => Director$inboundSchema)).optional(),
  Writer: z.array(z.lazy(() => Writer$inboundSchema)).optional(),
  Role: z.array(z.lazy(() => Role$inboundSchema)).optional(),
  Producer: z.array(z.lazy(() => Producer$inboundSchema)).optional(),
  Rating: z.array(z.lazy(() => Rating$inboundSchema)).optional(),
  Similar: z.array(z.lazy(() => Similar$inboundSchema)).optional(),
  Location: z.array(z.lazy(() => Location$inboundSchema)).optional(),
  Collection: z.array(z.lazy(() => Collection$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "Image": "image",
    "UltraBlurColors": "ultraBlurColors",
    "Guid": "guids",
    "Media": "media",
    "Genre": "genre",
    "Country": "country",
    "Director": "director",
    "Writer": "writer",
    "Role": "role",
    "Producer": "producer",
    "Rating": "rating1",
    "Similar": "similar",
    "Location": "location",
    "Collection": "collection",
  });
});

/** @internal */
export type GetRecentlyAddedMetadata$Outbound = {
  addedAt: number;
  art: string;
  audienceRatingImage?: string | undefined;
  audienceRating: number;
  chapterSource?: string | undefined;
  childCount: number;
  contentRating?: string | undefined;
  createdAtAccuracy?: string | undefined;
  createdAtTZOffset?: string | undefined;
  duration: number;
  grandparentArt?: string | undefined;
  grandparentGuid?: string | undefined;
  grandparentKey?: string | undefined;
  grandparentRatingKey?: string | undefined;
  grandparentSlug?: string | undefined;
  grandparentTheme?: string | undefined;
  grandparentThumb?: string | undefined;
  grandparentTitle?: string | undefined;
  guid: string;
  index: number;
  key: string;
  lastRatedAt?: number | undefined;
  lastViewedAt?: number | undefined;
  leafCount?: number | undefined;
  librarySectionID?: number | undefined;
  librarySectionKey?: string | undefined;
  librarySectionTitle?: string | undefined;
  originalTitle?: string | undefined;
  originallyAvailableAt?: string | undefined;
  parentGuid?: string | undefined;
  parentIndex?: number | undefined;
  parentKey?: string | undefined;
  parentRatingKey?: string | undefined;
  parentSlug?: string | undefined;
  parentStudio: string;
  parentTheme: string;
  parentThumb?: string | undefined;
  parentTitle?: string | undefined;
  parentYear?: number | undefined;
  primaryExtraKey?: string | undefined;
  ratingImage?: string | undefined;
  ratingKey: string;
  rating: number;
  seasonCount: number;
  skipCount?: number | undefined;
  slug: string;
  studio?: string | undefined;
  subtype?: string | undefined;
  summary: string;
  tagline: string;
  theme: string;
  thumb: string;
  titleSort: string;
  title: string;
  type: string;
  updatedAt?: number | undefined;
  userRating?: number | undefined;
  viewCount?: number | undefined;
  viewOffset?: number | undefined;
  viewedLeafCount?: number | undefined;
  year?: number | undefined;
  Image?: Array<GetRecentlyAddedImage$Outbound> | undefined;
  UltraBlurColors?: UltraBlurColors$Outbound | undefined;
  Guid?: Array<Guids$Outbound> | undefined;
  Media?: Array<Media$Outbound> | undefined;
  Genre?: Array<Genre$Outbound> | undefined;
  Country?: Array<Country$Outbound> | undefined;
  Director?: Array<Director$Outbound> | undefined;
  Writer?: Array<Writer$Outbound> | undefined;
  Role?: Array<Role$Outbound> | undefined;
  Producer?: Array<Producer$Outbound> | undefined;
  Rating?: Array<Rating$Outbound> | undefined;
  Similar?: Array<Similar$Outbound> | undefined;
  Location?: Array<Location$Outbound> | undefined;
  Collection?: Array<Collection$Outbound> | undefined;
};

/** @internal */
export const GetRecentlyAddedMetadata$outboundSchema: z.ZodType<
  GetRecentlyAddedMetadata$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedMetadata
> = z.object({
  addedAt: z.number().int(),
  art: z.string(),
  audienceRatingImage: z.string().optional(),
  audienceRating: z.number(),
  chapterSource: z.string().optional(),
  childCount: z.number().int(),
  contentRating: z.string().optional(),
  createdAtAccuracy: z.string().optional(),
  createdAtTZOffset: z.string().optional(),
  duration: z.number().int(),
  grandparentArt: z.string().optional(),
  grandparentGuid: z.string().optional(),
  grandparentKey: z.string().optional(),
  grandparentRatingKey: z.string().optional(),
  grandparentSlug: z.string().optional(),
  grandparentTheme: z.string().optional(),
  grandparentThumb: z.string().optional(),
  grandparentTitle: z.string().optional(),
  guid: z.string(),
  index: z.number().int(),
  key: z.string(),
  lastRatedAt: z.number().int().optional(),
  lastViewedAt: z.number().int().optional(),
  leafCount: z.number().int().optional(),
  librarySectionID: z.number().int().optional(),
  librarySectionKey: z.string().optional(),
  librarySectionTitle: z.string().optional(),
  originalTitle: z.string().optional(),
  originallyAvailableAt: z.instanceof(RFCDate).transform(v => v.toString())
    .optional(),
  parentGuid: z.string().optional(),
  parentIndex: z.number().int().optional(),
  parentKey: z.string().optional(),
  parentRatingKey: z.string().optional(),
  parentSlug: z.string().optional(),
  parentStudio: z.string(),
  parentTheme: z.string(),
  parentThumb: z.string().optional(),
  parentTitle: z.string().optional(),
  parentYear: z.number().int().optional(),
  primaryExtraKey: z.string().optional(),
  ratingImage: z.string().optional(),
  ratingKey: z.string(),
  rating: z.number(),
  seasonCount: z.number().int(),
  skipCount: z.number().int().optional(),
  slug: z.string(),
  studio: z.string().optional(),
  subtype: z.string().optional(),
  summary: z.string(),
  tagline: z.string(),
  theme: z.string(),
  thumb: z.string(),
  titleSort: z.string(),
  title: z.string(),
  type: GetRecentlyAddedHubsType$outboundSchema,
  updatedAt: z.number().int().optional(),
  userRating: z.number().optional(),
  viewCount: z.number().int().optional(),
  viewOffset: z.number().int().optional(),
  viewedLeafCount: z.number().int().optional(),
  year: z.number().int().optional(),
  image: z.array(z.lazy(() => GetRecentlyAddedImage$outboundSchema)).optional(),
  ultraBlurColors: z.lazy(() => UltraBlurColors$outboundSchema).optional(),
  guids: z.array(z.lazy(() => Guids$outboundSchema)).optional(),
  media: z.array(z.lazy(() => Media$outboundSchema)).optional(),
  genre: z.array(z.lazy(() => Genre$outboundSchema)).optional(),
  country: z.array(z.lazy(() => Country$outboundSchema)).optional(),
  director: z.array(z.lazy(() => Director$outboundSchema)).optional(),
  writer: z.array(z.lazy(() => Writer$outboundSchema)).optional(),
  role: z.array(z.lazy(() => Role$outboundSchema)).optional(),
  producer: z.array(z.lazy(() => Producer$outboundSchema)).optional(),
  rating1: z.array(z.lazy(() => Rating$outboundSchema)).optional(),
  similar: z.array(z.lazy(() => Similar$outboundSchema)).optional(),
  location: z.array(z.lazy(() => Location$outboundSchema)).optional(),
  collection: z.array(z.lazy(() => Collection$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    image: "Image",
    ultraBlurColors: "UltraBlurColors",
    guids: "Guid",
    media: "Media",
    genre: "Genre",
    country: "Country",
    director: "Director",
    writer: "Writer",
    role: "Role",
    producer: "Producer",
    rating1: "Rating",
    similar: "Similar",
    location: "Location",
    collection: "Collection",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedMetadata$ {
  /** @deprecated use `GetRecentlyAddedMetadata$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedMetadata$inboundSchema;
  /** @deprecated use `GetRecentlyAddedMetadata$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedMetadata$outboundSchema;
  /** @deprecated use `GetRecentlyAddedMetadata$Outbound` instead. */
  export type Outbound = GetRecentlyAddedMetadata$Outbound;
}

export function getRecentlyAddedMetadataToJSON(
  getRecentlyAddedMetadata: GetRecentlyAddedMetadata,
): string {
  return JSON.stringify(
    GetRecentlyAddedMetadata$outboundSchema.parse(getRecentlyAddedMetadata),
  );
}

export function getRecentlyAddedMetadataFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedMetadata' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedMediaContainer$inboundSchema: z.ZodType<
  GetRecentlyAddedMediaContainer,
  z.ZodTypeDef,
  unknown
> = z.object({
  size: z.number().int(),
  totalSize: z.number().int(),
  offset: z.number().int(),
  allowSync: z.boolean(),
  identifier: z.string(),
  Meta: z.lazy(() => Meta$inboundSchema).optional(),
  Metadata: z.array(z.lazy(() => GetRecentlyAddedMetadata$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "Meta": "meta",
    "Metadata": "metadata",
  });
});

/** @internal */
export type GetRecentlyAddedMediaContainer$Outbound = {
  size: number;
  totalSize: number;
  offset: number;
  allowSync: boolean;
  identifier: string;
  Meta?: Meta$Outbound | undefined;
  Metadata?: Array<GetRecentlyAddedMetadata$Outbound> | undefined;
};

/** @internal */
export const GetRecentlyAddedMediaContainer$outboundSchema: z.ZodType<
  GetRecentlyAddedMediaContainer$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedMediaContainer
> = z.object({
  size: z.number().int(),
  totalSize: z.number().int(),
  offset: z.number().int(),
  allowSync: z.boolean(),
  identifier: z.string(),
  meta: z.lazy(() => Meta$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => GetRecentlyAddedMetadata$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    meta: "Meta",
    metadata: "Metadata",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedMediaContainer$ {
  /** @deprecated use `GetRecentlyAddedMediaContainer$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedMediaContainer$inboundSchema;
  /** @deprecated use `GetRecentlyAddedMediaContainer$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedMediaContainer$outboundSchema;
  /** @deprecated use `GetRecentlyAddedMediaContainer$Outbound` instead. */
  export type Outbound = GetRecentlyAddedMediaContainer$Outbound;
}

export function getRecentlyAddedMediaContainerToJSON(
  getRecentlyAddedMediaContainer: GetRecentlyAddedMediaContainer,
): string {
  return JSON.stringify(
    GetRecentlyAddedMediaContainer$outboundSchema.parse(
      getRecentlyAddedMediaContainer,
    ),
  );
}

export function getRecentlyAddedMediaContainerFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedMediaContainer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedMediaContainer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedMediaContainer' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedResponseBody$inboundSchema: z.ZodType<
  GetRecentlyAddedResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  MediaContainer: z.lazy(() => GetRecentlyAddedMediaContainer$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "MediaContainer": "mediaContainer",
  });
});

/** @internal */
export type GetRecentlyAddedResponseBody$Outbound = {
  MediaContainer?: GetRecentlyAddedMediaContainer$Outbound | undefined;
};

/** @internal */
export const GetRecentlyAddedResponseBody$outboundSchema: z.ZodType<
  GetRecentlyAddedResponseBody$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedResponseBody
> = z.object({
  mediaContainer: z.lazy(() => GetRecentlyAddedMediaContainer$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    mediaContainer: "MediaContainer",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedResponseBody$ {
  /** @deprecated use `GetRecentlyAddedResponseBody$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedResponseBody$inboundSchema;
  /** @deprecated use `GetRecentlyAddedResponseBody$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedResponseBody$outboundSchema;
  /** @deprecated use `GetRecentlyAddedResponseBody$Outbound` instead. */
  export type Outbound = GetRecentlyAddedResponseBody$Outbound;
}

export function getRecentlyAddedResponseBodyToJSON(
  getRecentlyAddedResponseBody: GetRecentlyAddedResponseBody,
): string {
  return JSON.stringify(
    GetRecentlyAddedResponseBody$outboundSchema.parse(
      getRecentlyAddedResponseBody,
    ),
  );
}

export function getRecentlyAddedResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedResponseBody' from JSON`,
  );
}

/** @internal */
export const GetRecentlyAddedResponse$inboundSchema: z.ZodType<
  GetRecentlyAddedResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  ContentType: z.string(),
  StatusCode: z.number().int(),
  RawResponse: z.instanceof(Response),
  object: z.lazy(() => GetRecentlyAddedResponseBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "ContentType": "contentType",
    "StatusCode": "statusCode",
    "RawResponse": "rawResponse",
  });
});

/** @internal */
export type GetRecentlyAddedResponse$Outbound = {
  ContentType: string;
  StatusCode: number;
  RawResponse: never;
  object?: GetRecentlyAddedResponseBody$Outbound | undefined;
};

/** @internal */
export const GetRecentlyAddedResponse$outboundSchema: z.ZodType<
  GetRecentlyAddedResponse$Outbound,
  z.ZodTypeDef,
  GetRecentlyAddedResponse
> = z.object({
  contentType: z.string(),
  statusCode: z.number().int(),
  rawResponse: z.instanceof(Response).transform(() => {
    throw new Error("Response cannot be serialized");
  }),
  object: z.lazy(() => GetRecentlyAddedResponseBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    contentType: "ContentType",
    statusCode: "StatusCode",
    rawResponse: "RawResponse",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetRecentlyAddedResponse$ {
  /** @deprecated use `GetRecentlyAddedResponse$inboundSchema` instead. */
  export const inboundSchema = GetRecentlyAddedResponse$inboundSchema;
  /** @deprecated use `GetRecentlyAddedResponse$outboundSchema` instead. */
  export const outboundSchema = GetRecentlyAddedResponse$outboundSchema;
  /** @deprecated use `GetRecentlyAddedResponse$Outbound` instead. */
  export type Outbound = GetRecentlyAddedResponse$Outbound;
}

export function getRecentlyAddedResponseToJSON(
  getRecentlyAddedResponse: GetRecentlyAddedResponse,
): string {
  return JSON.stringify(
    GetRecentlyAddedResponse$outboundSchema.parse(getRecentlyAddedResponse),
  );
}

export function getRecentlyAddedResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetRecentlyAddedResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRecentlyAddedResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRecentlyAddedResponse' from JSON`,
  );
}
