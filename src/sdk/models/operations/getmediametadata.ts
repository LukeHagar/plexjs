/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { RFCDate } from "../../types/rfcdate.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetMediaMetaDataRequest = {
  /**
   * The id(s) of the library item(s) to return metadata for. Can be a single ID or comma-separated list of IDs.
   */
  ratingKey: string;
  /**
   * Include concerts data if set to true.
   */
  includeConcerts?: boolean | undefined;
  /**
   * Include extra content (e.g. bonus features).
   */
  includeExtras?: boolean | undefined;
  /**
   * Include on-deck items.
   */
  includeOnDeck?: boolean | undefined;
  /**
   * Include popular leaves (episodes/chapters).
   */
  includePopularLeaves?: boolean | undefined;
  /**
   * Include preferences information.
   */
  includePreferences?: boolean | undefined;
  /**
   * Include reviews for the content.
   */
  includeReviews?: boolean | undefined;
  /**
   * Include chapter details.
   */
  includeChapters?: boolean | undefined;
  /**
   * Include station data.
   */
  includeStations?: boolean | undefined;
  /**
   * Include external media data.
   */
  includeExternalMedia?: boolean | undefined;
  /**
   * Trigger asynchronous metadata augmentation.
   */
  asyncAugmentMetadata?: boolean | undefined;
  /**
   * Trigger asynchronous file checking.
   */
  asyncCheckFiles?: boolean | undefined;
  /**
   * Trigger asynchronous refresh of analysis.
   */
  asyncRefreshAnalysis?: boolean | undefined;
  /**
   * Trigger asynchronous refresh of the local media agent.
   */
  asyncRefreshLocalMediaAgent?: boolean | undefined;
};

/**
 * The type of media content in the Plex library. This can represent videos, music, or photos.
 *
 * @remarks
 */
export enum GetMediaMetaDataType {
  Movie = "movie",
  TvShow = "show",
  Season = "season",
  Episode = "episode",
  Artist = "artist",
  Album = "album",
  Track = "track",
  PhotoAlbum = "photoalbum",
  Photo = "photo",
  Collection = "collection",
}
/**
 * The type of media content in the Plex library. This can represent videos, music, or photos.
 *
 * @remarks
 */
export type GetMediaMetaDataTypeOpen = OpenEnum<typeof GetMediaMetaDataType>;

export enum GetMediaMetaDataLibraryType {
  CoverPoster = "coverPoster",
  Background = "background",
  Snapshot = "snapshot",
  ClearLogo = "clearLogo",
}
export type GetMediaMetaDataLibraryTypeOpen = OpenEnum<
  typeof GetMediaMetaDataLibraryType
>;

export type GetMediaMetaDataImage = {
  alt: string;
  type: GetMediaMetaDataLibraryTypeOpen;
  url: string;
};

export type GetMediaMetaDataUltraBlurColors = {
  topLeft: string;
  topRight: string;
  bottomRight: string;
  bottomLeft: string;
};

export type GetMediaMetaDataGuids = {
  /**
   * The unique identifier for the Guid. Can be prefixed with imdb://, tmdb://, tvdb://
   *
   * @remarks
   */
  id: string;
};

export enum GetMediaMetaDataOptimizedForStreaming1 {
  Zero = 0,
  One = 1,
}

/**
 * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
 */
export type GetMediaMetaDataOptimizedForStreaming =
  | GetMediaMetaDataOptimizedForStreaming1
  | boolean;

export enum GetMediaMetaDataOptimizedForStreamingLibrary1 {
  Zero = 0,
  One = 1,
}

/**
 * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
 *
 * @remarks
 */
export type GetMediaMetaDataLibraryOptimizedForStreaming =
  | GetMediaMetaDataOptimizedForStreamingLibrary1
  | boolean;

/**
 * Indicates if the part has a thumbnail.
 *
 * @remarks
 */
export enum GetMediaMetaDataHasThumbnail {
  False = "0",
  True = "1",
}

export type GetMediaMetaDataStream = {
  /**
   * Unique stream identifier.
   */
  id: number;
  /**
   * Stream type:
   *
   * @remarks
   *   - VIDEO = 1
   *   - AUDIO = 2
   *   - SUBTITLE = 3
   */
  streamType?: 1 | undefined;
  /**
   * Format of the stream (e.g., srt).
   */
  format?: string | undefined;
  /**
   * Indicates if this stream is default.
   */
  default?: boolean | undefined;
  /**
   * Codec used by the stream.
   */
  codec?: string | undefined;
  /**
   * Index of the stream.
   */
  index?: number | undefined;
  /**
   * Bitrate of the stream.
   */
  bitrate?: number | undefined;
  /**
   * Language of the stream.
   */
  language?: string | undefined;
  /**
   * Language tag (e.g., en).
   */
  languageTag?: string | undefined;
  /**
   * ISO language code.
   */
  languageCode?: string | undefined;
  /**
   * Indicates whether header compression is enabled.
   */
  headerCompression?: boolean | undefined;
  /**
   * Dolby Vision BL compatibility ID.
   */
  doviblCompatID?: number | undefined;
  /**
   * Indicates if Dolby Vision BL is present.
   */
  doviblPresent?: boolean | undefined;
  /**
   * Indicates if Dolby Vision EL is present.
   */
  dovielPresent?: boolean | undefined;
  /**
   * Dolby Vision level.
   */
  doviLevel?: number | undefined;
  /**
   * Indicates if Dolby Vision is present.
   */
  doviPresent?: boolean | undefined;
  /**
   * Dolby Vision profile.
   */
  doviProfile?: number | undefined;
  /**
   * Indicates if Dolby Vision RPU is present.
   */
  dovirpuPresent?: boolean | undefined;
  /**
   * Dolby Vision version.
   */
  doviVersion?: string | undefined;
  /**
   * Bit depth of the video stream.
   */
  bitDepth?: number | undefined;
  /**
   * Chroma sample location.
   */
  chromaLocation?: string | undefined;
  /**
   * Chroma subsampling format.
   */
  chromaSubsampling?: string | undefined;
  /**
   * Coded video height.
   */
  codedHeight?: number | undefined;
  /**
   * Coded video width.
   */
  codedWidth?: number | undefined;
  closedCaptions?: boolean | undefined;
  /**
   * Color primaries used.
   */
  colorPrimaries?: string | undefined;
  /**
   * Color range (e.g., tv).
   */
  colorRange?: string | undefined;
  /**
   * Color space.
   */
  colorSpace?: string | undefined;
  /**
   * Color transfer characteristics.
   */
  colorTrc?: string | undefined;
  /**
   * Frame rate of the stream.
   */
  frameRate?: number | undefined;
  /**
   * Key to access this stream part.
   */
  key?: string | undefined;
  /**
   * Height of the video stream.
   */
  height?: number | undefined;
  /**
   * Video level.
   */
  level?: number | undefined;
  /**
   * Indicates if this is the original stream.
   */
  original?: boolean | undefined;
  hasScalingMatrix?: boolean | undefined;
  /**
   * Video profile.
   */
  profile?: string | undefined;
  scanType?: string | undefined;
  embeddedInVideo?: string | undefined;
  /**
   * Number of reference frames.
   */
  refFrames?: number | undefined;
  /**
   * Width of the video stream.
   */
  width?: number | undefined;
  /**
   * Display title for the stream.
   */
  displayTitle?: string | undefined;
  /**
   * Extended display title for the stream.
   */
  extendedDisplayTitle?: string | undefined;
  /**
   * Indicates if this stream is selected (applicable for audio streams).
   */
  selected?: boolean | undefined;
  forced?: boolean | undefined;
  /**
   * Number of audio channels (for audio streams).
   */
  channels?: number | undefined;
  /**
   * Audio channel layout.
   */
  audioChannelLayout?: string | undefined;
  /**
   * Sampling rate for the audio stream.
   */
  samplingRate?: number | undefined;
  /**
   * Indicates if the stream can auto-sync.
   */
  canAutoSync?: boolean | undefined;
  /**
   * Indicates if the stream is for the hearing impaired.
   */
  hearingImpaired?: boolean | undefined;
  /**
   * Indicates if the stream is a dub.
   */
  dub?: boolean | undefined;
  /**
   * Optional title for the stream (e.g., language variant).
   */
  title?: string | undefined;
};

export type GetMediaMetaDataPart = {
  /**
   * Indicates if the part is accessible.
   */
  accessible?: boolean | undefined;
  /**
   * Indicates if the part exists.
   */
  exists?: boolean | undefined;
  /**
   * Unique part identifier.
   */
  id: number;
  /**
   * Key to access this part.
   */
  key?: string | undefined;
  indexes?: string | undefined;
  /**
   * Duration of the part in milliseconds.
   */
  duration?: number | undefined;
  /**
   * File path for the part.
   */
  file?: string | undefined;
  /**
   * File size in bytes.
   */
  size?: number | undefined;
  packetLength?: number | undefined;
  /**
   * Container format of the part.
   */
  container?: string | undefined;
  /**
   * Video profile for the part.
   */
  videoProfile?: string | undefined;
  /**
   * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
   */
  audioProfile?: string | undefined;
  has64bitOffsets?: boolean | undefined;
  /**
   * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
   *
   * @remarks
   */
  optimizedForStreaming?:
    | GetMediaMetaDataOptimizedForStreamingLibrary1
    | boolean
    | undefined;
  hasThumbnail?: GetMediaMetaDataHasThumbnail | undefined;
  stream?: Array<GetMediaMetaDataStream> | undefined;
};

export type GetMediaMetaDataMedia = {
  /**
   * Unique media identifier.
   */
  id: number;
  /**
   * Duration of the media in milliseconds.
   */
  duration?: number | undefined;
  /**
   * Bitrate in bits per second.
   */
  bitrate?: number | undefined;
  /**
   * Video width in pixels.
   */
  width?: number | undefined;
  /**
   * Video height in pixels.
   */
  height?: number | undefined;
  /**
   * Aspect ratio of the video.
   */
  aspectRatio?: number | undefined;
  /**
   * Number of audio channels.
   */
  audioChannels?: number | undefined;
  displayOffset?: number | undefined;
  /**
   * Audio codec used.
   */
  audioCodec?: string | undefined;
  /**
   * Video codec used.
   */
  videoCodec?: string | undefined;
  /**
   * Video resolution (e.g., 4k).
   */
  videoResolution?: string | undefined;
  /**
   * Container format of the media.
   */
  container?: string | undefined;
  /**
   * Frame rate of the video. Values found include NTSC, PAL, 24p
   *
   * @remarks
   */
  videoFrameRate?: string | undefined;
  /**
   * Video profile (e.g., main 10).
   */
  videoProfile?: string | undefined;
  /**
   * Indicates whether voice activity is detected.
   */
  hasVoiceActivity?: boolean | undefined;
  /**
   * The audio profile used for the media (e.g., DTS, Dolby Digital, etc.).
   */
  audioProfile?: string | undefined;
  /**
   * Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true
   */
  optimizedForStreaming?:
    | GetMediaMetaDataOptimizedForStreaming1
    | boolean
    | undefined;
  /**
   * Indicates whether the media has 64-bit offsets.
   *
   * @remarks
   * This is relevant for media files that may require larger offsets than what 32-bit integers can provide.
   */
  has64bitOffsets?: boolean | undefined;
  part?: Array<GetMediaMetaDataPart> | undefined;
};

/**
 * The filter query string for similar items.
 */
export type GetMediaMetaDataGenre = {
  /**
   * The unique identifier for the genre.
   *
   * @remarks
   * NOTE: This is different for each Plex server and is not globally unique.
   */
  id: number;
  /**
   * The genre name of this media-item
   *
   * @remarks
   */
  tag: string;
  filter: string;
};

/**
 * The filter query string for country media items.
 */
export type GetMediaMetaDataCountry = {
  /**
   * The unique identifier for the country.
   *
   * @remarks
   * NOTE: This is different for each Plex server and is not globally unique.
   */
  id: number;
  /**
   * The country of origin of this media item
   */
  tag: string;
  filter: string;
};

export type GetMediaMetaDataDirector = {
  /**
   * Unique identifier for the director.
   */
  id: number;
  /**
   * The role of Director
   */
  tag: string;
  /**
   * The filter string used to query this director.
   */
  filter: string;
  /**
   * A unique 24-character hexadecimal key associated with the director's tag, used for internal identification.
   */
  tagKey: string;
  /**
   * The absolute URL of the thumbnail image for the director.
   */
  thumb?: string | undefined;
};

export type GetMediaMetaDataWriter = {
  /**
   * Unique identifier for the writer.
   */
  id: number;
  /**
   * The role of Writer
   */
  tag: string;
  /**
   * The filter string used to query this writer.
   */
  filter: string;
  /**
   * The absolute URL of the thumbnail image for the writer.
   */
  thumb?: string | undefined;
  /**
   * A 24-character hexadecimal unique key associated with the writer’s tag, used for internal identification.
   */
  tagKey?: string | undefined;
};

export type GetMediaMetaDataProducer = {
  /**
   * The unique role identifier.
   */
  id: number;
  /**
   * The filter string for the role.
   */
  filter: string;
  /**
   * The actor's name.
   */
  tag: string;
  /**
   * A key associated with the actor tag.
   */
  tagKey: string;
  /**
   * The character name or role.
   */
  role?: string | undefined;
  /**
   * URL for the role thumbnail image.
   */
  thumb?: string | undefined;
};

export type GetMediaMetaDataRole = {
  /**
   * The unique identifier for the role.
   *
   * @remarks
   * NOTE: This is different for each Plex server and is not globally unique.
   */
  id: number;
  /**
   * The display tag for the actor (typically the actor's name).
   */
  tag: string;
  /**
   * The role played by the actor in the media item.
   */
  role?: string | undefined;
  /**
   * The filter string used to query this actor. For example, it may indicate that this is an actor with a given key.
   */
  filter: string;
  /**
   * A 24-character hexadecimal unique key associated with the actor's tag, used for internal identification.
   *
   * @remarks
   * NOTE: This is globally unique across all Plex Servers.
   */
  tagKey: string;
  /**
   * The absolute URL of the thumbnail image for the actor.
   */
  thumb?: string | undefined;
};

export type GetMediaMetaDataRatings = {
  /**
   * The image or reference for the rating.
   */
  image: string;
  /**
   * The rating value.
   */
  value: number;
  /**
   * The type of rating (e.g., audience, critic).
   */
  type: string;
};

export type GetMediaMetaDataSimilar = {
  /**
   * The unique similar item identifier.
   */
  id: number;
  /**
   * The filter string for similar items.
   */
  filter: string;
  /**
   * The tag or title of the similar content.
   */
  tag: string;
};

export type GetMediaMetaDataLocation = {
  /**
   * The file path for the location.
   */
  path: string;
};

/**
 * The thumbnail for the chapter
 */
export type GetMediaMetaDataChapter = {
  id: number;
  filter: string;
  index: number;
  startTimeOffset: number;
  endTimeOffset: number;
  thumb: string;
};

/**
 * Attributes associated with the marker.
 */
export type GetMediaMetaDataAttributes = {
  /**
   * The identifier for the attributes.
   */
  id: number;
  /**
   * The version number of the marker attributes.
   */
  version?: number | undefined;
};

/**
 * The final status of the marker
 */
export type GetMediaMetaDataMarker = {
  id: number;
  type: string;
  startTimeOffset: number;
  endTimeOffset: number;
  final?: boolean | undefined;
  /**
   * Attributes associated with the marker.
   */
  attributes?: GetMediaMetaDataAttributes | undefined;
};

export type GetMediaMetaDataExtras = {
  /**
   * The size of the extras.
   */
  size?: number | undefined;
};

/**
 * Unknown
 *
 * @remarks
 */
export type GetMediaMetaDataMetadata = {
  /**
   * The rating key (Media ID) of this media item. Note: Although this is always an integer, it is represented as a string in the API.
   */
  ratingKey: string;
  /**
   * The unique key for the media item.
   */
  key: string;
  /**
   * The globally unique identifier for the media item.
   */
  guid: string;
  /**
   * A URL‐friendly version of the media title.
   */
  slug: string;
  /**
   * The studio that produced the media item.
   */
  studio?: string | undefined;
  type: GetMediaMetaDataTypeOpen;
  /**
   * The title of the media item.
   */
  title: string;
  /**
   * The sort title used for ordering media items.
   */
  titleSort: string;
  /**
   * The content rating for the media item.
   */
  contentRating?: string | undefined;
  /**
   * A synopsis of the media item.
   */
  summary: string;
  /**
   * The critic rating for the media item.
   */
  rating: number;
  /**
   * The audience rating for the media item.
   */
  audienceRating: number;
  /**
   * The release year of the media item.
   */
  year?: number | undefined;
  /**
   * A brief tagline for the media item.
   */
  tagline: string;
  /**
   * The thumbnail image URL for the media item.
   */
  thumb: string;
  /**
   * The art image URL for the media item.
   */
  art: string;
  /**
   * The theme URL for the media item.
   */
  theme: string;
  /**
   * The index position of the media item.
   */
  index: number;
  /**
   * The number of leaf items (end nodes) under this media item.
   */
  leafCount?: number | undefined;
  /**
   * The number of leaf items that have been viewed.
   */
  viewedLeafCount?: number | undefined;
  /**
   * The number of child items associated with this media item.
   */
  childCount: number;
  /**
   * The total number of seasons (for TV shows).
   */
  seasonCount: number;
  /**
   * The duration of the media item in milliseconds.
   */
  duration: number;
  /**
   * The original release date of the media item.
   */
  originallyAvailableAt?: RFCDate | undefined;
  addedAt: number;
  /**
   * Unix epoch datetime in seconds
   */
  updatedAt?: number | undefined;
  /**
   * The URL for the audience rating image.
   */
  audienceRatingImage?: string | undefined;
  /**
   * The source from which chapter data is derived.
   */
  chapterSource?: string | undefined;
  /**
   * The primary extra key associated with this media item.
   */
  primaryExtraKey?: string | undefined;
  /**
   * The original title of the media item (if different).
   */
  originalTitle?: string | undefined;
  /**
   * The rating key of the parent media item.
   */
  parentRatingKey?: string | undefined;
  /**
   * The rating key of the grandparent media item.
   */
  grandparentRatingKey?: string | undefined;
  /**
   * The GUID of the parent media item.
   */
  parentGuid?: string | undefined;
  /**
   * The GUID of the grandparent media item.
   */
  grandparentGuid?: string | undefined;
  /**
   * The slug for the grandparent media item.
   */
  grandparentSlug?: string | undefined;
  /**
   * The key of the grandparent media item.
   */
  grandparentKey?: string | undefined;
  /**
   * The key of the parent media item.
   */
  parentKey?: string | undefined;
  /**
   * The title of the grandparent media item.
   */
  grandparentTitle?: string | undefined;
  /**
   * The thumbnail URL for the grandparent media item.
   */
  grandparentThumb?: string | undefined;
  /**
   * The theme URL for the grandparent media item.
   */
  grandparentTheme?: string | undefined;
  /**
   * The art URL for the grandparent media item.
   */
  grandparentArt?: string | undefined;
  /**
   * The title of the parent media item.
   */
  parentTitle?: string | undefined;
  /**
   * The index position of the parent media item.
   */
  parentIndex?: number | undefined;
  /**
   * The thumbnail URL for the parent media item.
   */
  parentThumb?: string | undefined;
  /**
   * The URL for the rating image.
   */
  ratingImage?: string | undefined;
  /**
   * The number of times this media item has been viewed.
   */
  viewCount?: number | undefined;
  /**
   * The current playback offset (in milliseconds).
   */
  viewOffset?: number | undefined;
  /**
   * The number of times this media item has been skipped.
   */
  skipCount?: number | undefined;
  /**
   * A classification that further describes the type of media item. For example, 'clip' indicates that the item is a short video clip.
   */
  subtype?: string | undefined;
  /**
   * The Unix timestamp representing the last time the item was rated.
   */
  lastRatedAt?: number | undefined;
  /**
   * The accuracy of the creation timestamp. This value indicates the format(s) provided (for example, 'epoch,local' means both epoch and local time formats are available).
   */
  createdAtAccuracy?: string | undefined;
  /**
   * The time zone offset for the creation timestamp, represented as a string. This offset indicates the difference from UTC.
   */
  createdAtTZOffset?: string | undefined;
  /**
   * Unix timestamp for when the media item was last viewed.
   */
  lastViewedAt?: number | undefined;
  /**
   * The rating provided by a user for the item. This value is expressed as a decimal number.
   */
  userRating?: number | undefined;
  image?: Array<GetMediaMetaDataImage> | undefined;
  ultraBlurColors?: GetMediaMetaDataUltraBlurColors | undefined;
  /**
   * The identifier for the library section.
   */
  librarySectionID?: number | undefined;
  /**
   * The title of the library section.
   */
  librarySectionTitle?: string | undefined;
  /**
   * The key corresponding to the library section.
   */
  librarySectionKey?: string | undefined;
  guids?: Array<GetMediaMetaDataGuids> | undefined;
  media?: Array<GetMediaMetaDataMedia> | undefined;
  genre?: Array<GetMediaMetaDataGenre> | undefined;
  country?: Array<GetMediaMetaDataCountry> | undefined;
  director?: Array<GetMediaMetaDataDirector> | undefined;
  writer?: Array<GetMediaMetaDataWriter> | undefined;
  producer?: Array<GetMediaMetaDataProducer> | undefined;
  role?: Array<GetMediaMetaDataRole> | undefined;
  ratings?: Array<GetMediaMetaDataRatings> | undefined;
  similar?: Array<GetMediaMetaDataSimilar> | undefined;
  location?: Array<GetMediaMetaDataLocation> | undefined;
  chapter?: Array<GetMediaMetaDataChapter> | undefined;
  marker?: Array<GetMediaMetaDataMarker> | undefined;
  extras?: GetMediaMetaDataExtras | undefined;
};

export type GetMediaMetaDataMediaContainer = {
  /**
   * Number of media items returned in this response.
   */
  size: number;
  /**
   * Indicates whether syncing is allowed.
   */
  allowSync: boolean;
  /**
   * An plugin identifier for the media container.
   */
  identifier: string;
  /**
   * The unique identifier for the library section.
   */
  librarySectionID?: number | undefined;
  /**
   * The title of the library section.
   */
  librarySectionTitle?: string | undefined;
  /**
   * The universally unique identifier for the library section.
   */
  librarySectionUUID?: string | undefined;
  /**
   * The prefix used for media tag resource paths.
   */
  mediaTagPrefix: string;
  /**
   * The version number for media tags.
   */
  mediaTagVersion: number;
  /**
   * An array of metadata items.
   */
  metadata: Array<GetMediaMetaDataMetadata>;
};

/**
 * The metadata of the library item.
 */
export type GetMediaMetaDataResponseBody = {
  mediaContainer?: GetMediaMetaDataMediaContainer | undefined;
};

export type GetMediaMetaDataResponse = {
  /**
   * HTTP response content type for this operation
   */
  contentType: string;
  /**
   * HTTP response status code for this operation
   */
  statusCode: number;
  /**
   * Raw HTTP response; suitable for custom response parsing
   */
  rawResponse: Response;
  /**
   * The metadata of the library item.
   */
  object?: GetMediaMetaDataResponseBody | undefined;
};

/** @internal */
export const GetMediaMetaDataRequest$inboundSchema: z.ZodType<
  GetMediaMetaDataRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  ratingKey: z.string(),
  includeConcerts: z.boolean().optional(),
  includeExtras: z.boolean().optional(),
  includeOnDeck: z.boolean().optional(),
  includePopularLeaves: z.boolean().optional(),
  includePreferences: z.boolean().optional(),
  includeReviews: z.boolean().optional(),
  includeChapters: z.boolean().optional(),
  includeStations: z.boolean().optional(),
  includeExternalMedia: z.boolean().optional(),
  asyncAugmentMetadata: z.boolean().optional(),
  asyncCheckFiles: z.boolean().optional(),
  asyncRefreshAnalysis: z.boolean().optional(),
  asyncRefreshLocalMediaAgent: z.boolean().optional(),
});

/** @internal */
export type GetMediaMetaDataRequest$Outbound = {
  ratingKey: string;
  includeConcerts?: boolean | undefined;
  includeExtras?: boolean | undefined;
  includeOnDeck?: boolean | undefined;
  includePopularLeaves?: boolean | undefined;
  includePreferences?: boolean | undefined;
  includeReviews?: boolean | undefined;
  includeChapters?: boolean | undefined;
  includeStations?: boolean | undefined;
  includeExternalMedia?: boolean | undefined;
  asyncAugmentMetadata?: boolean | undefined;
  asyncCheckFiles?: boolean | undefined;
  asyncRefreshAnalysis?: boolean | undefined;
  asyncRefreshLocalMediaAgent?: boolean | undefined;
};

/** @internal */
export const GetMediaMetaDataRequest$outboundSchema: z.ZodType<
  GetMediaMetaDataRequest$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataRequest
> = z.object({
  ratingKey: z.string(),
  includeConcerts: z.boolean().optional(),
  includeExtras: z.boolean().optional(),
  includeOnDeck: z.boolean().optional(),
  includePopularLeaves: z.boolean().optional(),
  includePreferences: z.boolean().optional(),
  includeReviews: z.boolean().optional(),
  includeChapters: z.boolean().optional(),
  includeStations: z.boolean().optional(),
  includeExternalMedia: z.boolean().optional(),
  asyncAugmentMetadata: z.boolean().optional(),
  asyncCheckFiles: z.boolean().optional(),
  asyncRefreshAnalysis: z.boolean().optional(),
  asyncRefreshLocalMediaAgent: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataRequest$ {
  /** @deprecated use `GetMediaMetaDataRequest$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataRequest$inboundSchema;
  /** @deprecated use `GetMediaMetaDataRequest$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataRequest$outboundSchema;
  /** @deprecated use `GetMediaMetaDataRequest$Outbound` instead. */
  export type Outbound = GetMediaMetaDataRequest$Outbound;
}

export function getMediaMetaDataRequestToJSON(
  getMediaMetaDataRequest: GetMediaMetaDataRequest,
): string {
  return JSON.stringify(
    GetMediaMetaDataRequest$outboundSchema.parse(getMediaMetaDataRequest),
  );
}

export function getMediaMetaDataRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataRequest' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataType$inboundSchema: z.ZodType<
  GetMediaMetaDataTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetMediaMetaDataType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetMediaMetaDataType$outboundSchema: z.ZodType<
  GetMediaMetaDataTypeOpen,
  z.ZodTypeDef,
  GetMediaMetaDataTypeOpen
> = z.union([
  z.nativeEnum(GetMediaMetaDataType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataType$ {
  /** @deprecated use `GetMediaMetaDataType$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataType$inboundSchema;
  /** @deprecated use `GetMediaMetaDataType$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataType$outboundSchema;
}

/** @internal */
export const GetMediaMetaDataLibraryType$inboundSchema: z.ZodType<
  GetMediaMetaDataLibraryTypeOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(GetMediaMetaDataLibraryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const GetMediaMetaDataLibraryType$outboundSchema: z.ZodType<
  GetMediaMetaDataLibraryTypeOpen,
  z.ZodTypeDef,
  GetMediaMetaDataLibraryTypeOpen
> = z.union([
  z.nativeEnum(GetMediaMetaDataLibraryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataLibraryType$ {
  /** @deprecated use `GetMediaMetaDataLibraryType$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataLibraryType$inboundSchema;
  /** @deprecated use `GetMediaMetaDataLibraryType$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataLibraryType$outboundSchema;
}

/** @internal */
export const GetMediaMetaDataImage$inboundSchema: z.ZodType<
  GetMediaMetaDataImage,
  z.ZodTypeDef,
  unknown
> = z.object({
  alt: z.string(),
  type: GetMediaMetaDataLibraryType$inboundSchema,
  url: z.string(),
});

/** @internal */
export type GetMediaMetaDataImage$Outbound = {
  alt: string;
  type: string;
  url: string;
};

/** @internal */
export const GetMediaMetaDataImage$outboundSchema: z.ZodType<
  GetMediaMetaDataImage$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataImage
> = z.object({
  alt: z.string(),
  type: GetMediaMetaDataLibraryType$outboundSchema,
  url: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataImage$ {
  /** @deprecated use `GetMediaMetaDataImage$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataImage$inboundSchema;
  /** @deprecated use `GetMediaMetaDataImage$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataImage$outboundSchema;
  /** @deprecated use `GetMediaMetaDataImage$Outbound` instead. */
  export type Outbound = GetMediaMetaDataImage$Outbound;
}

export function getMediaMetaDataImageToJSON(
  getMediaMetaDataImage: GetMediaMetaDataImage,
): string {
  return JSON.stringify(
    GetMediaMetaDataImage$outboundSchema.parse(getMediaMetaDataImage),
  );
}

export function getMediaMetaDataImageFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataImage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataImage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataImage' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataUltraBlurColors$inboundSchema: z.ZodType<
  GetMediaMetaDataUltraBlurColors,
  z.ZodTypeDef,
  unknown
> = z.object({
  topLeft: z.string(),
  topRight: z.string(),
  bottomRight: z.string(),
  bottomLeft: z.string(),
});

/** @internal */
export type GetMediaMetaDataUltraBlurColors$Outbound = {
  topLeft: string;
  topRight: string;
  bottomRight: string;
  bottomLeft: string;
};

/** @internal */
export const GetMediaMetaDataUltraBlurColors$outboundSchema: z.ZodType<
  GetMediaMetaDataUltraBlurColors$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataUltraBlurColors
> = z.object({
  topLeft: z.string(),
  topRight: z.string(),
  bottomRight: z.string(),
  bottomLeft: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataUltraBlurColors$ {
  /** @deprecated use `GetMediaMetaDataUltraBlurColors$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataUltraBlurColors$inboundSchema;
  /** @deprecated use `GetMediaMetaDataUltraBlurColors$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataUltraBlurColors$outboundSchema;
  /** @deprecated use `GetMediaMetaDataUltraBlurColors$Outbound` instead. */
  export type Outbound = GetMediaMetaDataUltraBlurColors$Outbound;
}

export function getMediaMetaDataUltraBlurColorsToJSON(
  getMediaMetaDataUltraBlurColors: GetMediaMetaDataUltraBlurColors,
): string {
  return JSON.stringify(
    GetMediaMetaDataUltraBlurColors$outboundSchema.parse(
      getMediaMetaDataUltraBlurColors,
    ),
  );
}

export function getMediaMetaDataUltraBlurColorsFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataUltraBlurColors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataUltraBlurColors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataUltraBlurColors' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataGuids$inboundSchema: z.ZodType<
  GetMediaMetaDataGuids,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

/** @internal */
export type GetMediaMetaDataGuids$Outbound = {
  id: string;
};

/** @internal */
export const GetMediaMetaDataGuids$outboundSchema: z.ZodType<
  GetMediaMetaDataGuids$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataGuids
> = z.object({
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataGuids$ {
  /** @deprecated use `GetMediaMetaDataGuids$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataGuids$inboundSchema;
  /** @deprecated use `GetMediaMetaDataGuids$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataGuids$outboundSchema;
  /** @deprecated use `GetMediaMetaDataGuids$Outbound` instead. */
  export type Outbound = GetMediaMetaDataGuids$Outbound;
}

export function getMediaMetaDataGuidsToJSON(
  getMediaMetaDataGuids: GetMediaMetaDataGuids,
): string {
  return JSON.stringify(
    GetMediaMetaDataGuids$outboundSchema.parse(getMediaMetaDataGuids),
  );
}

export function getMediaMetaDataGuidsFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataGuids, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataGuids$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataGuids' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataOptimizedForStreaming1$inboundSchema:
  z.ZodNativeEnum<typeof GetMediaMetaDataOptimizedForStreaming1> = z.nativeEnum(
    GetMediaMetaDataOptimizedForStreaming1,
  );

/** @internal */
export const GetMediaMetaDataOptimizedForStreaming1$outboundSchema:
  z.ZodNativeEnum<typeof GetMediaMetaDataOptimizedForStreaming1> =
    GetMediaMetaDataOptimizedForStreaming1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataOptimizedForStreaming1$ {
  /** @deprecated use `GetMediaMetaDataOptimizedForStreaming1$inboundSchema` instead. */
  export const inboundSchema =
    GetMediaMetaDataOptimizedForStreaming1$inboundSchema;
  /** @deprecated use `GetMediaMetaDataOptimizedForStreaming1$outboundSchema` instead. */
  export const outboundSchema =
    GetMediaMetaDataOptimizedForStreaming1$outboundSchema;
}

/** @internal */
export const GetMediaMetaDataOptimizedForStreaming$inboundSchema: z.ZodType<
  GetMediaMetaDataOptimizedForStreaming,
  z.ZodTypeDef,
  unknown
> = z.union([
  GetMediaMetaDataOptimizedForStreaming1$inboundSchema,
  z.boolean(),
]);

/** @internal */
export type GetMediaMetaDataOptimizedForStreaming$Outbound = number | boolean;

/** @internal */
export const GetMediaMetaDataOptimizedForStreaming$outboundSchema: z.ZodType<
  GetMediaMetaDataOptimizedForStreaming$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataOptimizedForStreaming
> = z.union([
  GetMediaMetaDataOptimizedForStreaming1$outboundSchema,
  z.boolean(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataOptimizedForStreaming$ {
  /** @deprecated use `GetMediaMetaDataOptimizedForStreaming$inboundSchema` instead. */
  export const inboundSchema =
    GetMediaMetaDataOptimizedForStreaming$inboundSchema;
  /** @deprecated use `GetMediaMetaDataOptimizedForStreaming$outboundSchema` instead. */
  export const outboundSchema =
    GetMediaMetaDataOptimizedForStreaming$outboundSchema;
  /** @deprecated use `GetMediaMetaDataOptimizedForStreaming$Outbound` instead. */
  export type Outbound = GetMediaMetaDataOptimizedForStreaming$Outbound;
}

export function getMediaMetaDataOptimizedForStreamingToJSON(
  getMediaMetaDataOptimizedForStreaming: GetMediaMetaDataOptimizedForStreaming,
): string {
  return JSON.stringify(
    GetMediaMetaDataOptimizedForStreaming$outboundSchema.parse(
      getMediaMetaDataOptimizedForStreaming,
    ),
  );
}

export function getMediaMetaDataOptimizedForStreamingFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataOptimizedForStreaming, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetMediaMetaDataOptimizedForStreaming$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataOptimizedForStreaming' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataOptimizedForStreamingLibrary1$inboundSchema:
  z.ZodNativeEnum<typeof GetMediaMetaDataOptimizedForStreamingLibrary1> = z
    .nativeEnum(GetMediaMetaDataOptimizedForStreamingLibrary1);

/** @internal */
export const GetMediaMetaDataOptimizedForStreamingLibrary1$outboundSchema:
  z.ZodNativeEnum<typeof GetMediaMetaDataOptimizedForStreamingLibrary1> =
    GetMediaMetaDataOptimizedForStreamingLibrary1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataOptimizedForStreamingLibrary1$ {
  /** @deprecated use `GetMediaMetaDataOptimizedForStreamingLibrary1$inboundSchema` instead. */
  export const inboundSchema =
    GetMediaMetaDataOptimizedForStreamingLibrary1$inboundSchema;
  /** @deprecated use `GetMediaMetaDataOptimizedForStreamingLibrary1$outboundSchema` instead. */
  export const outboundSchema =
    GetMediaMetaDataOptimizedForStreamingLibrary1$outboundSchema;
}

/** @internal */
export const GetMediaMetaDataLibraryOptimizedForStreaming$inboundSchema:
  z.ZodType<
    GetMediaMetaDataLibraryOptimizedForStreaming,
    z.ZodTypeDef,
    unknown
  > = z.union([
    GetMediaMetaDataOptimizedForStreamingLibrary1$inboundSchema,
    z.boolean(),
  ]);

/** @internal */
export type GetMediaMetaDataLibraryOptimizedForStreaming$Outbound =
  | number
  | boolean;

/** @internal */
export const GetMediaMetaDataLibraryOptimizedForStreaming$outboundSchema:
  z.ZodType<
    GetMediaMetaDataLibraryOptimizedForStreaming$Outbound,
    z.ZodTypeDef,
    GetMediaMetaDataLibraryOptimizedForStreaming
  > = z.union([
    GetMediaMetaDataOptimizedForStreamingLibrary1$outboundSchema,
    z.boolean(),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataLibraryOptimizedForStreaming$ {
  /** @deprecated use `GetMediaMetaDataLibraryOptimizedForStreaming$inboundSchema` instead. */
  export const inboundSchema =
    GetMediaMetaDataLibraryOptimizedForStreaming$inboundSchema;
  /** @deprecated use `GetMediaMetaDataLibraryOptimizedForStreaming$outboundSchema` instead. */
  export const outboundSchema =
    GetMediaMetaDataLibraryOptimizedForStreaming$outboundSchema;
  /** @deprecated use `GetMediaMetaDataLibraryOptimizedForStreaming$Outbound` instead. */
  export type Outbound = GetMediaMetaDataLibraryOptimizedForStreaming$Outbound;
}

export function getMediaMetaDataLibraryOptimizedForStreamingToJSON(
  getMediaMetaDataLibraryOptimizedForStreaming:
    GetMediaMetaDataLibraryOptimizedForStreaming,
): string {
  return JSON.stringify(
    GetMediaMetaDataLibraryOptimizedForStreaming$outboundSchema.parse(
      getMediaMetaDataLibraryOptimizedForStreaming,
    ),
  );
}

export function getMediaMetaDataLibraryOptimizedForStreamingFromJSON(
  jsonString: string,
): SafeParseResult<
  GetMediaMetaDataLibraryOptimizedForStreaming,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetMediaMetaDataLibraryOptimizedForStreaming$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetMediaMetaDataLibraryOptimizedForStreaming' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataHasThumbnail$inboundSchema: z.ZodNativeEnum<
  typeof GetMediaMetaDataHasThumbnail
> = z.nativeEnum(GetMediaMetaDataHasThumbnail);

/** @internal */
export const GetMediaMetaDataHasThumbnail$outboundSchema: z.ZodNativeEnum<
  typeof GetMediaMetaDataHasThumbnail
> = GetMediaMetaDataHasThumbnail$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataHasThumbnail$ {
  /** @deprecated use `GetMediaMetaDataHasThumbnail$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataHasThumbnail$inboundSchema;
  /** @deprecated use `GetMediaMetaDataHasThumbnail$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataHasThumbnail$outboundSchema;
}

/** @internal */
export const GetMediaMetaDataStream$inboundSchema: z.ZodType<
  GetMediaMetaDataStream,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  streamType: z.literal(1).optional(),
  format: z.string().optional(),
  default: z.boolean().optional(),
  codec: z.string().optional(),
  index: z.number().int().optional(),
  bitrate: z.number().int().optional(),
  language: z.string().optional(),
  languageTag: z.string().optional(),
  languageCode: z.string().optional(),
  headerCompression: z.boolean().optional(),
  DOVIBLCompatID: z.number().int().optional(),
  DOVIBLPresent: z.boolean().optional(),
  DOVIELPresent: z.boolean().optional(),
  DOVILevel: z.number().int().optional(),
  DOVIPresent: z.boolean().optional(),
  DOVIProfile: z.number().int().optional(),
  DOVIRPUPresent: z.boolean().optional(),
  DOVIVersion: z.string().optional(),
  bitDepth: z.number().int().optional(),
  chromaLocation: z.string().optional(),
  chromaSubsampling: z.string().optional(),
  codedHeight: z.number().int().optional(),
  codedWidth: z.number().int().optional(),
  closedCaptions: z.boolean().optional(),
  colorPrimaries: z.string().optional(),
  colorRange: z.string().optional(),
  colorSpace: z.string().optional(),
  colorTrc: z.string().optional(),
  frameRate: z.number().optional(),
  key: z.string().optional(),
  height: z.number().int().optional(),
  level: z.number().int().optional(),
  original: z.boolean().optional(),
  hasScalingMatrix: z.boolean().optional(),
  profile: z.string().optional(),
  scanType: z.string().optional(),
  embeddedInVideo: z.string().optional(),
  refFrames: z.number().int().optional(),
  width: z.number().int().optional(),
  displayTitle: z.string().optional(),
  extendedDisplayTitle: z.string().optional(),
  selected: z.boolean().optional(),
  forced: z.boolean().optional(),
  channels: z.number().int().optional(),
  audioChannelLayout: z.string().optional(),
  samplingRate: z.number().int().optional(),
  canAutoSync: z.boolean().optional(),
  hearingImpaired: z.boolean().optional(),
  dub: z.boolean().optional(),
  title: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "DOVIBLCompatID": "doviblCompatID",
    "DOVIBLPresent": "doviblPresent",
    "DOVIELPresent": "dovielPresent",
    "DOVILevel": "doviLevel",
    "DOVIPresent": "doviPresent",
    "DOVIProfile": "doviProfile",
    "DOVIRPUPresent": "dovirpuPresent",
    "DOVIVersion": "doviVersion",
  });
});

/** @internal */
export type GetMediaMetaDataStream$Outbound = {
  id: number;
  streamType: 1;
  format?: string | undefined;
  default?: boolean | undefined;
  codec?: string | undefined;
  index?: number | undefined;
  bitrate?: number | undefined;
  language?: string | undefined;
  languageTag?: string | undefined;
  languageCode?: string | undefined;
  headerCompression?: boolean | undefined;
  DOVIBLCompatID?: number | undefined;
  DOVIBLPresent?: boolean | undefined;
  DOVIELPresent?: boolean | undefined;
  DOVILevel?: number | undefined;
  DOVIPresent?: boolean | undefined;
  DOVIProfile?: number | undefined;
  DOVIRPUPresent?: boolean | undefined;
  DOVIVersion?: string | undefined;
  bitDepth?: number | undefined;
  chromaLocation?: string | undefined;
  chromaSubsampling?: string | undefined;
  codedHeight?: number | undefined;
  codedWidth?: number | undefined;
  closedCaptions?: boolean | undefined;
  colorPrimaries?: string | undefined;
  colorRange?: string | undefined;
  colorSpace?: string | undefined;
  colorTrc?: string | undefined;
  frameRate?: number | undefined;
  key?: string | undefined;
  height?: number | undefined;
  level?: number | undefined;
  original?: boolean | undefined;
  hasScalingMatrix?: boolean | undefined;
  profile?: string | undefined;
  scanType?: string | undefined;
  embeddedInVideo?: string | undefined;
  refFrames?: number | undefined;
  width?: number | undefined;
  displayTitle?: string | undefined;
  extendedDisplayTitle?: string | undefined;
  selected?: boolean | undefined;
  forced?: boolean | undefined;
  channels?: number | undefined;
  audioChannelLayout?: string | undefined;
  samplingRate?: number | undefined;
  canAutoSync?: boolean | undefined;
  hearingImpaired?: boolean | undefined;
  dub?: boolean | undefined;
  title?: string | undefined;
};

/** @internal */
export const GetMediaMetaDataStream$outboundSchema: z.ZodType<
  GetMediaMetaDataStream$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataStream
> = z.object({
  id: z.number().int(),
  streamType: z.literal(1).default(1 as const),
  format: z.string().optional(),
  default: z.boolean().optional(),
  codec: z.string().optional(),
  index: z.number().int().optional(),
  bitrate: z.number().int().optional(),
  language: z.string().optional(),
  languageTag: z.string().optional(),
  languageCode: z.string().optional(),
  headerCompression: z.boolean().optional(),
  doviblCompatID: z.number().int().optional(),
  doviblPresent: z.boolean().optional(),
  dovielPresent: z.boolean().optional(),
  doviLevel: z.number().int().optional(),
  doviPresent: z.boolean().optional(),
  doviProfile: z.number().int().optional(),
  dovirpuPresent: z.boolean().optional(),
  doviVersion: z.string().optional(),
  bitDepth: z.number().int().optional(),
  chromaLocation: z.string().optional(),
  chromaSubsampling: z.string().optional(),
  codedHeight: z.number().int().optional(),
  codedWidth: z.number().int().optional(),
  closedCaptions: z.boolean().optional(),
  colorPrimaries: z.string().optional(),
  colorRange: z.string().optional(),
  colorSpace: z.string().optional(),
  colorTrc: z.string().optional(),
  frameRate: z.number().optional(),
  key: z.string().optional(),
  height: z.number().int().optional(),
  level: z.number().int().optional(),
  original: z.boolean().optional(),
  hasScalingMatrix: z.boolean().optional(),
  profile: z.string().optional(),
  scanType: z.string().optional(),
  embeddedInVideo: z.string().optional(),
  refFrames: z.number().int().optional(),
  width: z.number().int().optional(),
  displayTitle: z.string().optional(),
  extendedDisplayTitle: z.string().optional(),
  selected: z.boolean().optional(),
  forced: z.boolean().optional(),
  channels: z.number().int().optional(),
  audioChannelLayout: z.string().optional(),
  samplingRate: z.number().int().optional(),
  canAutoSync: z.boolean().optional(),
  hearingImpaired: z.boolean().optional(),
  dub: z.boolean().optional(),
  title: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    doviblCompatID: "DOVIBLCompatID",
    doviblPresent: "DOVIBLPresent",
    dovielPresent: "DOVIELPresent",
    doviLevel: "DOVILevel",
    doviPresent: "DOVIPresent",
    doviProfile: "DOVIProfile",
    dovirpuPresent: "DOVIRPUPresent",
    doviVersion: "DOVIVersion",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataStream$ {
  /** @deprecated use `GetMediaMetaDataStream$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataStream$inboundSchema;
  /** @deprecated use `GetMediaMetaDataStream$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataStream$outboundSchema;
  /** @deprecated use `GetMediaMetaDataStream$Outbound` instead. */
  export type Outbound = GetMediaMetaDataStream$Outbound;
}

export function getMediaMetaDataStreamToJSON(
  getMediaMetaDataStream: GetMediaMetaDataStream,
): string {
  return JSON.stringify(
    GetMediaMetaDataStream$outboundSchema.parse(getMediaMetaDataStream),
  );
}

export function getMediaMetaDataStreamFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataStream, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataStream$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataStream' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataPart$inboundSchema: z.ZodType<
  GetMediaMetaDataPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  accessible: z.boolean().optional(),
  exists: z.boolean().optional(),
  id: z.number().int(),
  key: z.string().optional(),
  indexes: z.string().optional(),
  duration: z.number().int().optional(),
  file: z.string().optional(),
  size: z.number().int().optional(),
  packetLength: z.number().int().optional(),
  container: z.string().optional(),
  videoProfile: z.string().optional(),
  audioProfile: z.string().optional(),
  has64bitOffsets: z.boolean().optional(),
  optimizedForStreaming: z.union([
    GetMediaMetaDataOptimizedForStreamingLibrary1$inboundSchema,
    z.boolean(),
  ]).optional(),
  hasThumbnail: GetMediaMetaDataHasThumbnail$inboundSchema.default(
    GetMediaMetaDataHasThumbnail.False,
  ),
  Stream: z.array(z.lazy(() => GetMediaMetaDataStream$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "Stream": "stream",
  });
});

/** @internal */
export type GetMediaMetaDataPart$Outbound = {
  accessible?: boolean | undefined;
  exists?: boolean | undefined;
  id: number;
  key?: string | undefined;
  indexes?: string | undefined;
  duration?: number | undefined;
  file?: string | undefined;
  size?: number | undefined;
  packetLength?: number | undefined;
  container?: string | undefined;
  videoProfile?: string | undefined;
  audioProfile?: string | undefined;
  has64bitOffsets?: boolean | undefined;
  optimizedForStreaming?: number | boolean | undefined;
  hasThumbnail: string;
  Stream?: Array<GetMediaMetaDataStream$Outbound> | undefined;
};

/** @internal */
export const GetMediaMetaDataPart$outboundSchema: z.ZodType<
  GetMediaMetaDataPart$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataPart
> = z.object({
  accessible: z.boolean().optional(),
  exists: z.boolean().optional(),
  id: z.number().int(),
  key: z.string().optional(),
  indexes: z.string().optional(),
  duration: z.number().int().optional(),
  file: z.string().optional(),
  size: z.number().int().optional(),
  packetLength: z.number().int().optional(),
  container: z.string().optional(),
  videoProfile: z.string().optional(),
  audioProfile: z.string().optional(),
  has64bitOffsets: z.boolean().optional(),
  optimizedForStreaming: z.union([
    GetMediaMetaDataOptimizedForStreamingLibrary1$outboundSchema,
    z.boolean(),
  ]).optional(),
  hasThumbnail: GetMediaMetaDataHasThumbnail$outboundSchema.default(
    GetMediaMetaDataHasThumbnail.False,
  ),
  stream: z.array(z.lazy(() => GetMediaMetaDataStream$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    stream: "Stream",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataPart$ {
  /** @deprecated use `GetMediaMetaDataPart$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataPart$inboundSchema;
  /** @deprecated use `GetMediaMetaDataPart$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataPart$outboundSchema;
  /** @deprecated use `GetMediaMetaDataPart$Outbound` instead. */
  export type Outbound = GetMediaMetaDataPart$Outbound;
}

export function getMediaMetaDataPartToJSON(
  getMediaMetaDataPart: GetMediaMetaDataPart,
): string {
  return JSON.stringify(
    GetMediaMetaDataPart$outboundSchema.parse(getMediaMetaDataPart),
  );
}

export function getMediaMetaDataPartFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataPart' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataMedia$inboundSchema: z.ZodType<
  GetMediaMetaDataMedia,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  duration: z.number().int().optional(),
  bitrate: z.number().int().optional(),
  width: z.number().int().optional(),
  height: z.number().int().optional(),
  aspectRatio: z.number().optional(),
  audioChannels: z.number().int().optional(),
  displayOffset: z.number().int().optional(),
  audioCodec: z.string().optional(),
  videoCodec: z.string().optional(),
  videoResolution: z.string().optional(),
  container: z.string().optional(),
  videoFrameRate: z.string().optional(),
  videoProfile: z.string().optional(),
  hasVoiceActivity: z.boolean().optional(),
  audioProfile: z.string().optional(),
  optimizedForStreaming: z.union([
    GetMediaMetaDataOptimizedForStreaming1$inboundSchema,
    z.boolean(),
  ]).optional(),
  has64bitOffsets: z.boolean().optional(),
  Part: z.array(z.lazy(() => GetMediaMetaDataPart$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "Part": "part",
  });
});

/** @internal */
export type GetMediaMetaDataMedia$Outbound = {
  id: number;
  duration?: number | undefined;
  bitrate?: number | undefined;
  width?: number | undefined;
  height?: number | undefined;
  aspectRatio?: number | undefined;
  audioChannels?: number | undefined;
  displayOffset?: number | undefined;
  audioCodec?: string | undefined;
  videoCodec?: string | undefined;
  videoResolution?: string | undefined;
  container?: string | undefined;
  videoFrameRate?: string | undefined;
  videoProfile?: string | undefined;
  hasVoiceActivity?: boolean | undefined;
  audioProfile?: string | undefined;
  optimizedForStreaming?: number | boolean | undefined;
  has64bitOffsets?: boolean | undefined;
  Part?: Array<GetMediaMetaDataPart$Outbound> | undefined;
};

/** @internal */
export const GetMediaMetaDataMedia$outboundSchema: z.ZodType<
  GetMediaMetaDataMedia$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataMedia
> = z.object({
  id: z.number().int(),
  duration: z.number().int().optional(),
  bitrate: z.number().int().optional(),
  width: z.number().int().optional(),
  height: z.number().int().optional(),
  aspectRatio: z.number().optional(),
  audioChannels: z.number().int().optional(),
  displayOffset: z.number().int().optional(),
  audioCodec: z.string().optional(),
  videoCodec: z.string().optional(),
  videoResolution: z.string().optional(),
  container: z.string().optional(),
  videoFrameRate: z.string().optional(),
  videoProfile: z.string().optional(),
  hasVoiceActivity: z.boolean().optional(),
  audioProfile: z.string().optional(),
  optimizedForStreaming: z.union([
    GetMediaMetaDataOptimizedForStreaming1$outboundSchema,
    z.boolean(),
  ]).optional(),
  has64bitOffsets: z.boolean().optional(),
  part: z.array(z.lazy(() => GetMediaMetaDataPart$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    part: "Part",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataMedia$ {
  /** @deprecated use `GetMediaMetaDataMedia$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataMedia$inboundSchema;
  /** @deprecated use `GetMediaMetaDataMedia$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataMedia$outboundSchema;
  /** @deprecated use `GetMediaMetaDataMedia$Outbound` instead. */
  export type Outbound = GetMediaMetaDataMedia$Outbound;
}

export function getMediaMetaDataMediaToJSON(
  getMediaMetaDataMedia: GetMediaMetaDataMedia,
): string {
  return JSON.stringify(
    GetMediaMetaDataMedia$outboundSchema.parse(getMediaMetaDataMedia),
  );
}

export function getMediaMetaDataMediaFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataMedia' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataGenre$inboundSchema: z.ZodType<
  GetMediaMetaDataGenre,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  tag: z.string(),
  filter: z.string(),
});

/** @internal */
export type GetMediaMetaDataGenre$Outbound = {
  id: number;
  tag: string;
  filter: string;
};

/** @internal */
export const GetMediaMetaDataGenre$outboundSchema: z.ZodType<
  GetMediaMetaDataGenre$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataGenre
> = z.object({
  id: z.number().int(),
  tag: z.string(),
  filter: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataGenre$ {
  /** @deprecated use `GetMediaMetaDataGenre$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataGenre$inboundSchema;
  /** @deprecated use `GetMediaMetaDataGenre$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataGenre$outboundSchema;
  /** @deprecated use `GetMediaMetaDataGenre$Outbound` instead. */
  export type Outbound = GetMediaMetaDataGenre$Outbound;
}

export function getMediaMetaDataGenreToJSON(
  getMediaMetaDataGenre: GetMediaMetaDataGenre,
): string {
  return JSON.stringify(
    GetMediaMetaDataGenre$outboundSchema.parse(getMediaMetaDataGenre),
  );
}

export function getMediaMetaDataGenreFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataGenre, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataGenre$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataGenre' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataCountry$inboundSchema: z.ZodType<
  GetMediaMetaDataCountry,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  tag: z.string(),
  filter: z.string(),
});

/** @internal */
export type GetMediaMetaDataCountry$Outbound = {
  id: number;
  tag: string;
  filter: string;
};

/** @internal */
export const GetMediaMetaDataCountry$outboundSchema: z.ZodType<
  GetMediaMetaDataCountry$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataCountry
> = z.object({
  id: z.number().int(),
  tag: z.string(),
  filter: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataCountry$ {
  /** @deprecated use `GetMediaMetaDataCountry$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataCountry$inboundSchema;
  /** @deprecated use `GetMediaMetaDataCountry$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataCountry$outboundSchema;
  /** @deprecated use `GetMediaMetaDataCountry$Outbound` instead. */
  export type Outbound = GetMediaMetaDataCountry$Outbound;
}

export function getMediaMetaDataCountryToJSON(
  getMediaMetaDataCountry: GetMediaMetaDataCountry,
): string {
  return JSON.stringify(
    GetMediaMetaDataCountry$outboundSchema.parse(getMediaMetaDataCountry),
  );
}

export function getMediaMetaDataCountryFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataCountry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataCountry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataCountry' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataDirector$inboundSchema: z.ZodType<
  GetMediaMetaDataDirector,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  tag: z.string(),
  filter: z.string(),
  tagKey: z.string(),
  thumb: z.string().optional(),
});

/** @internal */
export type GetMediaMetaDataDirector$Outbound = {
  id: number;
  tag: string;
  filter: string;
  tagKey: string;
  thumb?: string | undefined;
};

/** @internal */
export const GetMediaMetaDataDirector$outboundSchema: z.ZodType<
  GetMediaMetaDataDirector$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataDirector
> = z.object({
  id: z.number().int(),
  tag: z.string(),
  filter: z.string(),
  tagKey: z.string(),
  thumb: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataDirector$ {
  /** @deprecated use `GetMediaMetaDataDirector$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataDirector$inboundSchema;
  /** @deprecated use `GetMediaMetaDataDirector$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataDirector$outboundSchema;
  /** @deprecated use `GetMediaMetaDataDirector$Outbound` instead. */
  export type Outbound = GetMediaMetaDataDirector$Outbound;
}

export function getMediaMetaDataDirectorToJSON(
  getMediaMetaDataDirector: GetMediaMetaDataDirector,
): string {
  return JSON.stringify(
    GetMediaMetaDataDirector$outboundSchema.parse(getMediaMetaDataDirector),
  );
}

export function getMediaMetaDataDirectorFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataDirector, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataDirector$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataDirector' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataWriter$inboundSchema: z.ZodType<
  GetMediaMetaDataWriter,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  tag: z.string(),
  filter: z.string(),
  thumb: z.string().optional(),
  tagKey: z.string().optional(),
});

/** @internal */
export type GetMediaMetaDataWriter$Outbound = {
  id: number;
  tag: string;
  filter: string;
  thumb?: string | undefined;
  tagKey?: string | undefined;
};

/** @internal */
export const GetMediaMetaDataWriter$outboundSchema: z.ZodType<
  GetMediaMetaDataWriter$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataWriter
> = z.object({
  id: z.number().int(),
  tag: z.string(),
  filter: z.string(),
  thumb: z.string().optional(),
  tagKey: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataWriter$ {
  /** @deprecated use `GetMediaMetaDataWriter$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataWriter$inboundSchema;
  /** @deprecated use `GetMediaMetaDataWriter$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataWriter$outboundSchema;
  /** @deprecated use `GetMediaMetaDataWriter$Outbound` instead. */
  export type Outbound = GetMediaMetaDataWriter$Outbound;
}

export function getMediaMetaDataWriterToJSON(
  getMediaMetaDataWriter: GetMediaMetaDataWriter,
): string {
  return JSON.stringify(
    GetMediaMetaDataWriter$outboundSchema.parse(getMediaMetaDataWriter),
  );
}

export function getMediaMetaDataWriterFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataWriter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataWriter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataWriter' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataProducer$inboundSchema: z.ZodType<
  GetMediaMetaDataProducer,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  tag: z.string(),
  tagKey: z.string(),
  role: z.string().optional(),
  thumb: z.string().optional(),
});

/** @internal */
export type GetMediaMetaDataProducer$Outbound = {
  id: number;
  filter: string;
  tag: string;
  tagKey: string;
  role?: string | undefined;
  thumb?: string | undefined;
};

/** @internal */
export const GetMediaMetaDataProducer$outboundSchema: z.ZodType<
  GetMediaMetaDataProducer$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataProducer
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  tag: z.string(),
  tagKey: z.string(),
  role: z.string().optional(),
  thumb: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataProducer$ {
  /** @deprecated use `GetMediaMetaDataProducer$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataProducer$inboundSchema;
  /** @deprecated use `GetMediaMetaDataProducer$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataProducer$outboundSchema;
  /** @deprecated use `GetMediaMetaDataProducer$Outbound` instead. */
  export type Outbound = GetMediaMetaDataProducer$Outbound;
}

export function getMediaMetaDataProducerToJSON(
  getMediaMetaDataProducer: GetMediaMetaDataProducer,
): string {
  return JSON.stringify(
    GetMediaMetaDataProducer$outboundSchema.parse(getMediaMetaDataProducer),
  );
}

export function getMediaMetaDataProducerFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataProducer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataProducer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataProducer' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataRole$inboundSchema: z.ZodType<
  GetMediaMetaDataRole,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  tag: z.string(),
  role: z.string().optional(),
  filter: z.string(),
  tagKey: z.string(),
  thumb: z.string().optional(),
});

/** @internal */
export type GetMediaMetaDataRole$Outbound = {
  id: number;
  tag: string;
  role?: string | undefined;
  filter: string;
  tagKey: string;
  thumb?: string | undefined;
};

/** @internal */
export const GetMediaMetaDataRole$outboundSchema: z.ZodType<
  GetMediaMetaDataRole$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataRole
> = z.object({
  id: z.number().int(),
  tag: z.string(),
  role: z.string().optional(),
  filter: z.string(),
  tagKey: z.string(),
  thumb: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataRole$ {
  /** @deprecated use `GetMediaMetaDataRole$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataRole$inboundSchema;
  /** @deprecated use `GetMediaMetaDataRole$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataRole$outboundSchema;
  /** @deprecated use `GetMediaMetaDataRole$Outbound` instead. */
  export type Outbound = GetMediaMetaDataRole$Outbound;
}

export function getMediaMetaDataRoleToJSON(
  getMediaMetaDataRole: GetMediaMetaDataRole,
): string {
  return JSON.stringify(
    GetMediaMetaDataRole$outboundSchema.parse(getMediaMetaDataRole),
  );
}

export function getMediaMetaDataRoleFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataRole' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataRatings$inboundSchema: z.ZodType<
  GetMediaMetaDataRatings,
  z.ZodTypeDef,
  unknown
> = z.object({
  image: z.string(),
  value: z.number(),
  type: z.string(),
});

/** @internal */
export type GetMediaMetaDataRatings$Outbound = {
  image: string;
  value: number;
  type: string;
};

/** @internal */
export const GetMediaMetaDataRatings$outboundSchema: z.ZodType<
  GetMediaMetaDataRatings$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataRatings
> = z.object({
  image: z.string(),
  value: z.number(),
  type: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataRatings$ {
  /** @deprecated use `GetMediaMetaDataRatings$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataRatings$inboundSchema;
  /** @deprecated use `GetMediaMetaDataRatings$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataRatings$outboundSchema;
  /** @deprecated use `GetMediaMetaDataRatings$Outbound` instead. */
  export type Outbound = GetMediaMetaDataRatings$Outbound;
}

export function getMediaMetaDataRatingsToJSON(
  getMediaMetaDataRatings: GetMediaMetaDataRatings,
): string {
  return JSON.stringify(
    GetMediaMetaDataRatings$outboundSchema.parse(getMediaMetaDataRatings),
  );
}

export function getMediaMetaDataRatingsFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataRatings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataRatings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataRatings' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataSimilar$inboundSchema: z.ZodType<
  GetMediaMetaDataSimilar,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  tag: z.string(),
});

/** @internal */
export type GetMediaMetaDataSimilar$Outbound = {
  id: number;
  filter: string;
  tag: string;
};

/** @internal */
export const GetMediaMetaDataSimilar$outboundSchema: z.ZodType<
  GetMediaMetaDataSimilar$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataSimilar
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  tag: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataSimilar$ {
  /** @deprecated use `GetMediaMetaDataSimilar$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataSimilar$inboundSchema;
  /** @deprecated use `GetMediaMetaDataSimilar$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataSimilar$outboundSchema;
  /** @deprecated use `GetMediaMetaDataSimilar$Outbound` instead. */
  export type Outbound = GetMediaMetaDataSimilar$Outbound;
}

export function getMediaMetaDataSimilarToJSON(
  getMediaMetaDataSimilar: GetMediaMetaDataSimilar,
): string {
  return JSON.stringify(
    GetMediaMetaDataSimilar$outboundSchema.parse(getMediaMetaDataSimilar),
  );
}

export function getMediaMetaDataSimilarFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataSimilar, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataSimilar$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataSimilar' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataLocation$inboundSchema: z.ZodType<
  GetMediaMetaDataLocation,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
});

/** @internal */
export type GetMediaMetaDataLocation$Outbound = {
  path: string;
};

/** @internal */
export const GetMediaMetaDataLocation$outboundSchema: z.ZodType<
  GetMediaMetaDataLocation$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataLocation
> = z.object({
  path: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataLocation$ {
  /** @deprecated use `GetMediaMetaDataLocation$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataLocation$inboundSchema;
  /** @deprecated use `GetMediaMetaDataLocation$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataLocation$outboundSchema;
  /** @deprecated use `GetMediaMetaDataLocation$Outbound` instead. */
  export type Outbound = GetMediaMetaDataLocation$Outbound;
}

export function getMediaMetaDataLocationToJSON(
  getMediaMetaDataLocation: GetMediaMetaDataLocation,
): string {
  return JSON.stringify(
    GetMediaMetaDataLocation$outboundSchema.parse(getMediaMetaDataLocation),
  );
}

export function getMediaMetaDataLocationFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataLocation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataLocation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataLocation' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataChapter$inboundSchema: z.ZodType<
  GetMediaMetaDataChapter,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  index: z.number().int(),
  startTimeOffset: z.number().int(),
  endTimeOffset: z.number().int(),
  thumb: z.string(),
});

/** @internal */
export type GetMediaMetaDataChapter$Outbound = {
  id: number;
  filter: string;
  index: number;
  startTimeOffset: number;
  endTimeOffset: number;
  thumb: string;
};

/** @internal */
export const GetMediaMetaDataChapter$outboundSchema: z.ZodType<
  GetMediaMetaDataChapter$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataChapter
> = z.object({
  id: z.number().int(),
  filter: z.string(),
  index: z.number().int(),
  startTimeOffset: z.number().int(),
  endTimeOffset: z.number().int(),
  thumb: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataChapter$ {
  /** @deprecated use `GetMediaMetaDataChapter$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataChapter$inboundSchema;
  /** @deprecated use `GetMediaMetaDataChapter$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataChapter$outboundSchema;
  /** @deprecated use `GetMediaMetaDataChapter$Outbound` instead. */
  export type Outbound = GetMediaMetaDataChapter$Outbound;
}

export function getMediaMetaDataChapterToJSON(
  getMediaMetaDataChapter: GetMediaMetaDataChapter,
): string {
  return JSON.stringify(
    GetMediaMetaDataChapter$outboundSchema.parse(getMediaMetaDataChapter),
  );
}

export function getMediaMetaDataChapterFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataChapter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataChapter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataChapter' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataAttributes$inboundSchema: z.ZodType<
  GetMediaMetaDataAttributes,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  version: z.number().int().optional(),
});

/** @internal */
export type GetMediaMetaDataAttributes$Outbound = {
  id: number;
  version?: number | undefined;
};

/** @internal */
export const GetMediaMetaDataAttributes$outboundSchema: z.ZodType<
  GetMediaMetaDataAttributes$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataAttributes
> = z.object({
  id: z.number().int(),
  version: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataAttributes$ {
  /** @deprecated use `GetMediaMetaDataAttributes$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataAttributes$inboundSchema;
  /** @deprecated use `GetMediaMetaDataAttributes$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataAttributes$outboundSchema;
  /** @deprecated use `GetMediaMetaDataAttributes$Outbound` instead. */
  export type Outbound = GetMediaMetaDataAttributes$Outbound;
}

export function getMediaMetaDataAttributesToJSON(
  getMediaMetaDataAttributes: GetMediaMetaDataAttributes,
): string {
  return JSON.stringify(
    GetMediaMetaDataAttributes$outboundSchema.parse(getMediaMetaDataAttributes),
  );
}

export function getMediaMetaDataAttributesFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataAttributes, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataAttributes$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataAttributes' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataMarker$inboundSchema: z.ZodType<
  GetMediaMetaDataMarker,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  type: z.string(),
  startTimeOffset: z.number().int(),
  endTimeOffset: z.number().int(),
  final: z.boolean().optional(),
  Attributes: z.lazy(() => GetMediaMetaDataAttributes$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "Attributes": "attributes",
  });
});

/** @internal */
export type GetMediaMetaDataMarker$Outbound = {
  id: number;
  type: string;
  startTimeOffset: number;
  endTimeOffset: number;
  final?: boolean | undefined;
  Attributes?: GetMediaMetaDataAttributes$Outbound | undefined;
};

/** @internal */
export const GetMediaMetaDataMarker$outboundSchema: z.ZodType<
  GetMediaMetaDataMarker$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataMarker
> = z.object({
  id: z.number().int(),
  type: z.string(),
  startTimeOffset: z.number().int(),
  endTimeOffset: z.number().int(),
  final: z.boolean().optional(),
  attributes: z.lazy(() => GetMediaMetaDataAttributes$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    attributes: "Attributes",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataMarker$ {
  /** @deprecated use `GetMediaMetaDataMarker$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataMarker$inboundSchema;
  /** @deprecated use `GetMediaMetaDataMarker$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataMarker$outboundSchema;
  /** @deprecated use `GetMediaMetaDataMarker$Outbound` instead. */
  export type Outbound = GetMediaMetaDataMarker$Outbound;
}

export function getMediaMetaDataMarkerToJSON(
  getMediaMetaDataMarker: GetMediaMetaDataMarker,
): string {
  return JSON.stringify(
    GetMediaMetaDataMarker$outboundSchema.parse(getMediaMetaDataMarker),
  );
}

export function getMediaMetaDataMarkerFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataMarker, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataMarker$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataMarker' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataExtras$inboundSchema: z.ZodType<
  GetMediaMetaDataExtras,
  z.ZodTypeDef,
  unknown
> = z.object({
  size: z.number().int().optional(),
});

/** @internal */
export type GetMediaMetaDataExtras$Outbound = {
  size?: number | undefined;
};

/** @internal */
export const GetMediaMetaDataExtras$outboundSchema: z.ZodType<
  GetMediaMetaDataExtras$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataExtras
> = z.object({
  size: z.number().int().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataExtras$ {
  /** @deprecated use `GetMediaMetaDataExtras$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataExtras$inboundSchema;
  /** @deprecated use `GetMediaMetaDataExtras$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataExtras$outboundSchema;
  /** @deprecated use `GetMediaMetaDataExtras$Outbound` instead. */
  export type Outbound = GetMediaMetaDataExtras$Outbound;
}

export function getMediaMetaDataExtrasToJSON(
  getMediaMetaDataExtras: GetMediaMetaDataExtras,
): string {
  return JSON.stringify(
    GetMediaMetaDataExtras$outboundSchema.parse(getMediaMetaDataExtras),
  );
}

export function getMediaMetaDataExtrasFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataExtras, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataExtras$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataExtras' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataMetadata$inboundSchema: z.ZodType<
  GetMediaMetaDataMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  ratingKey: z.string(),
  key: z.string(),
  guid: z.string(),
  slug: z.string(),
  studio: z.string().optional(),
  type: GetMediaMetaDataType$inboundSchema,
  title: z.string(),
  titleSort: z.string(),
  contentRating: z.string().optional(),
  summary: z.string(),
  rating: z.number(),
  audienceRating: z.number(),
  year: z.number().int().optional(),
  tagline: z.string(),
  thumb: z.string(),
  art: z.string(),
  theme: z.string(),
  index: z.number().int(),
  leafCount: z.number().int().optional(),
  viewedLeafCount: z.number().int().optional(),
  childCount: z.number().int(),
  seasonCount: z.number().int(),
  duration: z.number().int(),
  originallyAvailableAt: z.string().transform(v => new RFCDate(v)).optional(),
  addedAt: z.number().int(),
  updatedAt: z.number().int().optional(),
  audienceRatingImage: z.string().optional(),
  chapterSource: z.string().optional(),
  primaryExtraKey: z.string().optional(),
  originalTitle: z.string().optional(),
  parentRatingKey: z.string().optional(),
  grandparentRatingKey: z.string().optional(),
  parentGuid: z.string().optional(),
  grandparentGuid: z.string().optional(),
  grandparentSlug: z.string().optional(),
  grandparentKey: z.string().optional(),
  parentKey: z.string().optional(),
  grandparentTitle: z.string().optional(),
  grandparentThumb: z.string().optional(),
  grandparentTheme: z.string().optional(),
  grandparentArt: z.string().optional(),
  parentTitle: z.string().optional(),
  parentIndex: z.number().int().optional(),
  parentThumb: z.string().optional(),
  ratingImage: z.string().optional(),
  viewCount: z.number().int().optional(),
  viewOffset: z.number().int().optional(),
  skipCount: z.number().int().optional(),
  subtype: z.string().optional(),
  lastRatedAt: z.number().int().optional(),
  createdAtAccuracy: z.string().optional(),
  createdAtTZOffset: z.string().optional(),
  lastViewedAt: z.number().int().optional(),
  userRating: z.number().optional(),
  Image: z.array(z.lazy(() => GetMediaMetaDataImage$inboundSchema)).optional(),
  UltraBlurColors: z.lazy(() => GetMediaMetaDataUltraBlurColors$inboundSchema)
    .optional(),
  librarySectionID: z.number().int().optional(),
  librarySectionTitle: z.string().optional(),
  librarySectionKey: z.string().optional(),
  Guid: z.array(z.lazy(() => GetMediaMetaDataGuids$inboundSchema)).optional(),
  Media: z.array(z.lazy(() => GetMediaMetaDataMedia$inboundSchema)).optional(),
  Genre: z.array(z.lazy(() => GetMediaMetaDataGenre$inboundSchema)).optional(),
  Country: z.array(z.lazy(() => GetMediaMetaDataCountry$inboundSchema))
    .optional(),
  Director: z.array(z.lazy(() => GetMediaMetaDataDirector$inboundSchema))
    .optional(),
  Writer: z.array(z.lazy(() => GetMediaMetaDataWriter$inboundSchema))
    .optional(),
  Producer: z.array(z.lazy(() => GetMediaMetaDataProducer$inboundSchema))
    .optional(),
  Role: z.array(z.lazy(() => GetMediaMetaDataRole$inboundSchema)).optional(),
  Rating: z.array(z.lazy(() => GetMediaMetaDataRatings$inboundSchema))
    .optional(),
  Similar: z.array(z.lazy(() => GetMediaMetaDataSimilar$inboundSchema))
    .optional(),
  Location: z.array(z.lazy(() => GetMediaMetaDataLocation$inboundSchema))
    .optional(),
  Chapter: z.array(z.lazy(() => GetMediaMetaDataChapter$inboundSchema))
    .optional(),
  Marker: z.array(z.lazy(() => GetMediaMetaDataMarker$inboundSchema))
    .optional(),
  Extras: z.lazy(() => GetMediaMetaDataExtras$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "Image": "image",
    "UltraBlurColors": "ultraBlurColors",
    "Guid": "guids",
    "Media": "media",
    "Genre": "genre",
    "Country": "country",
    "Director": "director",
    "Writer": "writer",
    "Producer": "producer",
    "Role": "role",
    "Rating": "ratings",
    "Similar": "similar",
    "Location": "location",
    "Chapter": "chapter",
    "Marker": "marker",
    "Extras": "extras",
  });
});

/** @internal */
export type GetMediaMetaDataMetadata$Outbound = {
  ratingKey: string;
  key: string;
  guid: string;
  slug: string;
  studio?: string | undefined;
  type: string;
  title: string;
  titleSort: string;
  contentRating?: string | undefined;
  summary: string;
  rating: number;
  audienceRating: number;
  year?: number | undefined;
  tagline: string;
  thumb: string;
  art: string;
  theme: string;
  index: number;
  leafCount?: number | undefined;
  viewedLeafCount?: number | undefined;
  childCount: number;
  seasonCount: number;
  duration: number;
  originallyAvailableAt?: string | undefined;
  addedAt: number;
  updatedAt?: number | undefined;
  audienceRatingImage?: string | undefined;
  chapterSource?: string | undefined;
  primaryExtraKey?: string | undefined;
  originalTitle?: string | undefined;
  parentRatingKey?: string | undefined;
  grandparentRatingKey?: string | undefined;
  parentGuid?: string | undefined;
  grandparentGuid?: string | undefined;
  grandparentSlug?: string | undefined;
  grandparentKey?: string | undefined;
  parentKey?: string | undefined;
  grandparentTitle?: string | undefined;
  grandparentThumb?: string | undefined;
  grandparentTheme?: string | undefined;
  grandparentArt?: string | undefined;
  parentTitle?: string | undefined;
  parentIndex?: number | undefined;
  parentThumb?: string | undefined;
  ratingImage?: string | undefined;
  viewCount?: number | undefined;
  viewOffset?: number | undefined;
  skipCount?: number | undefined;
  subtype?: string | undefined;
  lastRatedAt?: number | undefined;
  createdAtAccuracy?: string | undefined;
  createdAtTZOffset?: string | undefined;
  lastViewedAt?: number | undefined;
  userRating?: number | undefined;
  Image?: Array<GetMediaMetaDataImage$Outbound> | undefined;
  UltraBlurColors?: GetMediaMetaDataUltraBlurColors$Outbound | undefined;
  librarySectionID?: number | undefined;
  librarySectionTitle?: string | undefined;
  librarySectionKey?: string | undefined;
  Guid?: Array<GetMediaMetaDataGuids$Outbound> | undefined;
  Media?: Array<GetMediaMetaDataMedia$Outbound> | undefined;
  Genre?: Array<GetMediaMetaDataGenre$Outbound> | undefined;
  Country?: Array<GetMediaMetaDataCountry$Outbound> | undefined;
  Director?: Array<GetMediaMetaDataDirector$Outbound> | undefined;
  Writer?: Array<GetMediaMetaDataWriter$Outbound> | undefined;
  Producer?: Array<GetMediaMetaDataProducer$Outbound> | undefined;
  Role?: Array<GetMediaMetaDataRole$Outbound> | undefined;
  Rating?: Array<GetMediaMetaDataRatings$Outbound> | undefined;
  Similar?: Array<GetMediaMetaDataSimilar$Outbound> | undefined;
  Location?: Array<GetMediaMetaDataLocation$Outbound> | undefined;
  Chapter?: Array<GetMediaMetaDataChapter$Outbound> | undefined;
  Marker?: Array<GetMediaMetaDataMarker$Outbound> | undefined;
  Extras?: GetMediaMetaDataExtras$Outbound | undefined;
};

/** @internal */
export const GetMediaMetaDataMetadata$outboundSchema: z.ZodType<
  GetMediaMetaDataMetadata$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataMetadata
> = z.object({
  ratingKey: z.string(),
  key: z.string(),
  guid: z.string(),
  slug: z.string(),
  studio: z.string().optional(),
  type: GetMediaMetaDataType$outboundSchema,
  title: z.string(),
  titleSort: z.string(),
  contentRating: z.string().optional(),
  summary: z.string(),
  rating: z.number(),
  audienceRating: z.number(),
  year: z.number().int().optional(),
  tagline: z.string(),
  thumb: z.string(),
  art: z.string(),
  theme: z.string(),
  index: z.number().int(),
  leafCount: z.number().int().optional(),
  viewedLeafCount: z.number().int().optional(),
  childCount: z.number().int(),
  seasonCount: z.number().int(),
  duration: z.number().int(),
  originallyAvailableAt: z.instanceof(RFCDate).transform(v => v.toString())
    .optional(),
  addedAt: z.number().int(),
  updatedAt: z.number().int().optional(),
  audienceRatingImage: z.string().optional(),
  chapterSource: z.string().optional(),
  primaryExtraKey: z.string().optional(),
  originalTitle: z.string().optional(),
  parentRatingKey: z.string().optional(),
  grandparentRatingKey: z.string().optional(),
  parentGuid: z.string().optional(),
  grandparentGuid: z.string().optional(),
  grandparentSlug: z.string().optional(),
  grandparentKey: z.string().optional(),
  parentKey: z.string().optional(),
  grandparentTitle: z.string().optional(),
  grandparentThumb: z.string().optional(),
  grandparentTheme: z.string().optional(),
  grandparentArt: z.string().optional(),
  parentTitle: z.string().optional(),
  parentIndex: z.number().int().optional(),
  parentThumb: z.string().optional(),
  ratingImage: z.string().optional(),
  viewCount: z.number().int().optional(),
  viewOffset: z.number().int().optional(),
  skipCount: z.number().int().optional(),
  subtype: z.string().optional(),
  lastRatedAt: z.number().int().optional(),
  createdAtAccuracy: z.string().optional(),
  createdAtTZOffset: z.string().optional(),
  lastViewedAt: z.number().int().optional(),
  userRating: z.number().optional(),
  image: z.array(z.lazy(() => GetMediaMetaDataImage$outboundSchema)).optional(),
  ultraBlurColors: z.lazy(() => GetMediaMetaDataUltraBlurColors$outboundSchema)
    .optional(),
  librarySectionID: z.number().int().optional(),
  librarySectionTitle: z.string().optional(),
  librarySectionKey: z.string().optional(),
  guids: z.array(z.lazy(() => GetMediaMetaDataGuids$outboundSchema)).optional(),
  media: z.array(z.lazy(() => GetMediaMetaDataMedia$outboundSchema)).optional(),
  genre: z.array(z.lazy(() => GetMediaMetaDataGenre$outboundSchema)).optional(),
  country: z.array(z.lazy(() => GetMediaMetaDataCountry$outboundSchema))
    .optional(),
  director: z.array(z.lazy(() => GetMediaMetaDataDirector$outboundSchema))
    .optional(),
  writer: z.array(z.lazy(() => GetMediaMetaDataWriter$outboundSchema))
    .optional(),
  producer: z.array(z.lazy(() => GetMediaMetaDataProducer$outboundSchema))
    .optional(),
  role: z.array(z.lazy(() => GetMediaMetaDataRole$outboundSchema)).optional(),
  ratings: z.array(z.lazy(() => GetMediaMetaDataRatings$outboundSchema))
    .optional(),
  similar: z.array(z.lazy(() => GetMediaMetaDataSimilar$outboundSchema))
    .optional(),
  location: z.array(z.lazy(() => GetMediaMetaDataLocation$outboundSchema))
    .optional(),
  chapter: z.array(z.lazy(() => GetMediaMetaDataChapter$outboundSchema))
    .optional(),
  marker: z.array(z.lazy(() => GetMediaMetaDataMarker$outboundSchema))
    .optional(),
  extras: z.lazy(() => GetMediaMetaDataExtras$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    image: "Image",
    ultraBlurColors: "UltraBlurColors",
    guids: "Guid",
    media: "Media",
    genre: "Genre",
    country: "Country",
    director: "Director",
    writer: "Writer",
    producer: "Producer",
    role: "Role",
    ratings: "Rating",
    similar: "Similar",
    location: "Location",
    chapter: "Chapter",
    marker: "Marker",
    extras: "Extras",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataMetadata$ {
  /** @deprecated use `GetMediaMetaDataMetadata$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataMetadata$inboundSchema;
  /** @deprecated use `GetMediaMetaDataMetadata$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataMetadata$outboundSchema;
  /** @deprecated use `GetMediaMetaDataMetadata$Outbound` instead. */
  export type Outbound = GetMediaMetaDataMetadata$Outbound;
}

export function getMediaMetaDataMetadataToJSON(
  getMediaMetaDataMetadata: GetMediaMetaDataMetadata,
): string {
  return JSON.stringify(
    GetMediaMetaDataMetadata$outboundSchema.parse(getMediaMetaDataMetadata),
  );
}

export function getMediaMetaDataMetadataFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataMetadata' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataMediaContainer$inboundSchema: z.ZodType<
  GetMediaMetaDataMediaContainer,
  z.ZodTypeDef,
  unknown
> = z.object({
  size: z.number().int(),
  allowSync: z.boolean(),
  identifier: z.string(),
  librarySectionID: z.number().int().optional(),
  librarySectionTitle: z.string().optional(),
  librarySectionUUID: z.string().optional(),
  mediaTagPrefix: z.string(),
  mediaTagVersion: z.number().int(),
  Metadata: z.array(z.lazy(() => GetMediaMetaDataMetadata$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "Metadata": "metadata",
  });
});

/** @internal */
export type GetMediaMetaDataMediaContainer$Outbound = {
  size: number;
  allowSync: boolean;
  identifier: string;
  librarySectionID?: number | undefined;
  librarySectionTitle?: string | undefined;
  librarySectionUUID?: string | undefined;
  mediaTagPrefix: string;
  mediaTagVersion: number;
  Metadata: Array<GetMediaMetaDataMetadata$Outbound>;
};

/** @internal */
export const GetMediaMetaDataMediaContainer$outboundSchema: z.ZodType<
  GetMediaMetaDataMediaContainer$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataMediaContainer
> = z.object({
  size: z.number().int(),
  allowSync: z.boolean(),
  identifier: z.string(),
  librarySectionID: z.number().int().optional(),
  librarySectionTitle: z.string().optional(),
  librarySectionUUID: z.string().optional(),
  mediaTagPrefix: z.string(),
  mediaTagVersion: z.number().int(),
  metadata: z.array(z.lazy(() => GetMediaMetaDataMetadata$outboundSchema)),
}).transform((v) => {
  return remap$(v, {
    metadata: "Metadata",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataMediaContainer$ {
  /** @deprecated use `GetMediaMetaDataMediaContainer$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataMediaContainer$inboundSchema;
  /** @deprecated use `GetMediaMetaDataMediaContainer$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataMediaContainer$outboundSchema;
  /** @deprecated use `GetMediaMetaDataMediaContainer$Outbound` instead. */
  export type Outbound = GetMediaMetaDataMediaContainer$Outbound;
}

export function getMediaMetaDataMediaContainerToJSON(
  getMediaMetaDataMediaContainer: GetMediaMetaDataMediaContainer,
): string {
  return JSON.stringify(
    GetMediaMetaDataMediaContainer$outboundSchema.parse(
      getMediaMetaDataMediaContainer,
    ),
  );
}

export function getMediaMetaDataMediaContainerFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataMediaContainer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataMediaContainer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataMediaContainer' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataResponseBody$inboundSchema: z.ZodType<
  GetMediaMetaDataResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  MediaContainer: z.lazy(() => GetMediaMetaDataMediaContainer$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "MediaContainer": "mediaContainer",
  });
});

/** @internal */
export type GetMediaMetaDataResponseBody$Outbound = {
  MediaContainer?: GetMediaMetaDataMediaContainer$Outbound | undefined;
};

/** @internal */
export const GetMediaMetaDataResponseBody$outboundSchema: z.ZodType<
  GetMediaMetaDataResponseBody$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataResponseBody
> = z.object({
  mediaContainer: z.lazy(() => GetMediaMetaDataMediaContainer$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    mediaContainer: "MediaContainer",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataResponseBody$ {
  /** @deprecated use `GetMediaMetaDataResponseBody$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataResponseBody$inboundSchema;
  /** @deprecated use `GetMediaMetaDataResponseBody$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataResponseBody$outboundSchema;
  /** @deprecated use `GetMediaMetaDataResponseBody$Outbound` instead. */
  export type Outbound = GetMediaMetaDataResponseBody$Outbound;
}

export function getMediaMetaDataResponseBodyToJSON(
  getMediaMetaDataResponseBody: GetMediaMetaDataResponseBody,
): string {
  return JSON.stringify(
    GetMediaMetaDataResponseBody$outboundSchema.parse(
      getMediaMetaDataResponseBody,
    ),
  );
}

export function getMediaMetaDataResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataResponseBody' from JSON`,
  );
}

/** @internal */
export const GetMediaMetaDataResponse$inboundSchema: z.ZodType<
  GetMediaMetaDataResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  ContentType: z.string(),
  StatusCode: z.number().int(),
  RawResponse: z.instanceof(Response),
  object: z.lazy(() => GetMediaMetaDataResponseBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "ContentType": "contentType",
    "StatusCode": "statusCode",
    "RawResponse": "rawResponse",
  });
});

/** @internal */
export type GetMediaMetaDataResponse$Outbound = {
  ContentType: string;
  StatusCode: number;
  RawResponse: never;
  object?: GetMediaMetaDataResponseBody$Outbound | undefined;
};

/** @internal */
export const GetMediaMetaDataResponse$outboundSchema: z.ZodType<
  GetMediaMetaDataResponse$Outbound,
  z.ZodTypeDef,
  GetMediaMetaDataResponse
> = z.object({
  contentType: z.string(),
  statusCode: z.number().int(),
  rawResponse: z.instanceof(Response).transform(() => {
    throw new Error("Response cannot be serialized");
  }),
  object: z.lazy(() => GetMediaMetaDataResponseBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    contentType: "ContentType",
    statusCode: "StatusCode",
    rawResponse: "RawResponse",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetMediaMetaDataResponse$ {
  /** @deprecated use `GetMediaMetaDataResponse$inboundSchema` instead. */
  export const inboundSchema = GetMediaMetaDataResponse$inboundSchema;
  /** @deprecated use `GetMediaMetaDataResponse$outboundSchema` instead. */
  export const outboundSchema = GetMediaMetaDataResponse$outboundSchema;
  /** @deprecated use `GetMediaMetaDataResponse$Outbound` instead. */
  export type Outbound = GetMediaMetaDataResponse$Outbound;
}

export function getMediaMetaDataResponseToJSON(
  getMediaMetaDataResponse: GetMediaMetaDataResponse,
): string {
  return JSON.stringify(
    GetMediaMetaDataResponse$outboundSchema.parse(getMediaMetaDataResponse),
  );
}

export function getMediaMetaDataResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaMetaDataResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaMetaDataResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaMetaDataResponse' from JSON`,
  );
}
