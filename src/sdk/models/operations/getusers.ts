/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as shared from "../shared/index.js";

export const GetUsersServerList = [
  "https://plex.tv/api",
] as const;

export type GetUsersGlobals = {
  /**
   * Indicates the client accepts the indicated media types
   */
  accepts?: shared.Accepts | undefined;
  /**
   * An opaque identifier unique to the client
   */
  clientIdentifier?: string | undefined;
  /**
   * The name of the client product
   */
  product?: string | undefined;
  /**
   * The version of the client application
   */
  version?: string | undefined;
  /**
   * The platform of the client
   */
  platform?: string | undefined;
  /**
   * The version of the platform
   */
  platformVersion?: string | undefined;
  /**
   * A relatively friendly name for the client device
   */
  device?: string | undefined;
  /**
   * A potentially less friendly identifier for the device model
   */
  model?: string | undefined;
  /**
   * The device vendor
   */
  deviceVendor?: string | undefined;
  /**
   * A friendly name for the client
   */
  deviceName?: string | undefined;
  /**
   * The marketplace on which the client application is distributed
   */
  marketplace?: string | undefined;
};

export type GetUsersRequest = {
  /**
   * Indicates the client accepts the indicated media types
   */
  accepts?: shared.Accepts | undefined;
  /**
   * An opaque identifier unique to the client
   */
  clientIdentifier?: string | undefined;
  /**
   * The name of the client product
   */
  product?: string | undefined;
  /**
   * The version of the client application
   */
  version?: string | undefined;
  /**
   * The platform of the client
   */
  platform?: string | undefined;
  /**
   * The version of the platform
   */
  platformVersion?: string | undefined;
  /**
   * A relatively friendly name for the client device
   */
  device?: string | undefined;
  /**
   * A potentially less friendly identifier for the device model
   */
  model?: string | undefined;
  /**
   * The device vendor
   */
  deviceVendor?: string | undefined;
  /**
   * A friendly name for the client
   */
  deviceName?: string | undefined;
  /**
   * The marketplace on which the client application is distributed
   */
  marketplace?: string | undefined;
};

export type GetUsersUnauthorizedError = {
  code?: number | undefined;
  message?: string | undefined;
  status?: number | undefined;
};

export type GetUsersBadRequestError = {
  code?: number | undefined;
  message?: string | undefined;
  status?: number | undefined;
};

/**
 * Indicates whether the account is protected.
 */
export enum Protected {
  Disable = 0,
  Enable = 1,
}

/**
 * Indicates if the user is part of a home group.
 */
export enum Home {
  Disable = 0,
  Enable = 1,
}

/**
 * Indicates if the user is allowed to use tuners.
 */
export enum AllowTuners {
  Disable = 0,
  Enable = 1,
}

/**
 * Indicates if the user is allowed to sync media.
 */
export enum AllowSync {
  Disable = 0,
  Enable = 1,
}

/**
 * Indicates if the user is allowed to upload from a camera.
 */
export enum AllowCameraUpload {
  Disable = 0,
  Enable = 1,
}

/**
 * Indicates if the user has access to channels.
 */
export enum AllowChannels {
  Disable = 0,
  Enable = 1,
}

/**
 * Indicates if the user can manage subtitles.
 */
export enum AllowSubtitleAdmin {
  Disable = 0,
  Enable = 1,
}

/**
 * Indicates if the user has restricted access.
 */
export enum Restricted {
  Disable = 0,
  Enable = 1,
}

/**
 * Indicates if the user has access to all libraries.
 */
export enum AllLibraries {
  Disable = 0,
  Enable = 1,
}

/**
 * Indicates if the user owns the server.
 */
export enum Owned {
  Disable = 0,
  Enable = 1,
}

/**
 * Indicates if the server is pending approval.
 */
export enum Pending {
  Disable = 0,
  Enable = 1,
}

export type Server = {
  /**
   * Unique ID of the server of the connected user
   */
  id: number;
  /**
   * ID of the actual Plex server.
   */
  serverId: number;
  /**
   * Machine identifier of the Plex server.
   */
  machineIdentifier: string;
  /**
   * Name of the Plex server of the connected user.
   */
  name: string;
  /**
   * Unix epoch datetime in seconds
   */
  lastSeenAt: number;
  /**
   * Number of libraries in the server this user has access to.
   */
  numLibraries: number;
  allLibraries?: AllLibraries | undefined;
  owned?: Owned | undefined;
  pending?: Pending | undefined;
};

export type User = {
  /**
   * User's unique ID.
   */
  id: number;
  /**
   * User's display name.
   */
  title: string;
  /**
   * User's username.
   */
  username: string;
  /**
   * User's email address.
   */
  email: string;
  /**
   * ID of the user's recommendation playlist.
   */
  recommendationsPlaylistId?: string | null | undefined;
  /**
   * URL to the user's avatar image.
   */
  thumb: string;
  protected?: Protected | undefined;
  home?: Home | undefined;
  allowTuners?: AllowTuners | undefined;
  allowSync?: AllowSync | undefined;
  allowCameraUpload?: AllowCameraUpload | undefined;
  allowChannels?: AllowChannels | undefined;
  allowSubtitleAdmin?: AllowSubtitleAdmin | undefined;
  /**
   * Filters applied for all content.
   */
  filterAll?: string | null | undefined;
  /**
   * Filters applied for movies.
   */
  filterMovies?: string | null | undefined;
  /**
   * Filters applied for music.
   */
  filterMusic?: string | null | undefined;
  /**
   * Filters applied for photos.
   */
  filterPhotos?: string | null | undefined;
  /**
   * Filters applied for television.
   */
  filterTelevision?: string | undefined;
  restricted?: Restricted | undefined;
  /**
   * List of servers owned by the user.
   */
  server: Array<Server>;
};

/**
 * Container holding user and server details.
 */
export type GetUsersMediaContainer = {
  /**
   * The friendly name of the Plex instance.
   */
  friendlyName: string;
  identifier: string;
  /**
   * Unique Machine identifier of the Plex server.
   */
  machineIdentifier: string;
  /**
   * Total number of users.
   */
  totalSize: number;
  /**
   * Number of users in the current response.
   */
  size: number;
  /**
   * List of users with access to the Plex server.
   */
  user: Array<User>;
};

/**
 * Successful response with media container data in JSON
 */
export type GetUsersResponseBody = {
  /**
   * Container holding user and server details.
   */
  mediaContainer?: GetUsersMediaContainer | undefined;
};

export type GetUsersResponse = {
  /**
   * HTTP response content type for this operation
   */
  contentType: string;
  /**
   * HTTP response status code for this operation
   */
  statusCode: number;
  /**
   * Raw HTTP response; suitable for custom response parsing
   */
  rawResponse: Response;
  /**
   * Successful response with media container data in JSON
   */
  object?: GetUsersResponseBody | undefined;
};

/** @internal */
export type GetUsersRequest$Outbound = {
  accepts: string;
  "Client-Identifier"?: string | undefined;
  Product?: string | undefined;
  Version?: string | undefined;
  Platform?: string | undefined;
  "Platform-Version"?: string | undefined;
  Device?: string | undefined;
  Model?: string | undefined;
  "Device-Vendor"?: string | undefined;
  "Device-Name"?: string | undefined;
  Marketplace?: string | undefined;
};

/** @internal */
export const GetUsersRequest$outboundSchema: z.ZodType<
  GetUsersRequest$Outbound,
  z.ZodTypeDef,
  GetUsersRequest
> = z.object({
  accepts: shared.Accepts$outboundSchema.default(shared.Accepts.ApplicationXml),
  clientIdentifier: z.string().optional(),
  product: z.string().optional(),
  version: z.string().optional(),
  platform: z.string().optional(),
  platformVersion: z.string().optional(),
  device: z.string().optional(),
  model: z.string().optional(),
  deviceVendor: z.string().optional(),
  deviceName: z.string().optional(),
  marketplace: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    clientIdentifier: "Client-Identifier",
    product: "Product",
    version: "Version",
    platform: "Platform",
    platformVersion: "Platform-Version",
    device: "Device",
    model: "Model",
    deviceVendor: "Device-Vendor",
    deviceName: "Device-Name",
    marketplace: "Marketplace",
  });
});

export function getUsersRequestToJSON(
  getUsersRequest: GetUsersRequest,
): string {
  return JSON.stringify(GetUsersRequest$outboundSchema.parse(getUsersRequest));
}

/** @internal */
export const GetUsersUnauthorizedError$inboundSchema: z.ZodType<
  GetUsersUnauthorizedError,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.number().int().optional(),
  message: z.string().optional(),
  status: z.number().int().optional(),
});

export function getUsersUnauthorizedErrorFromJSON(
  jsonString: string,
): SafeParseResult<GetUsersUnauthorizedError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUsersUnauthorizedError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUsersUnauthorizedError' from JSON`,
  );
}

/** @internal */
export const GetUsersBadRequestError$inboundSchema: z.ZodType<
  GetUsersBadRequestError,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.number().int().optional(),
  message: z.string().optional(),
  status: z.number().int().optional(),
});

export function getUsersBadRequestErrorFromJSON(
  jsonString: string,
): SafeParseResult<GetUsersBadRequestError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUsersBadRequestError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUsersBadRequestError' from JSON`,
  );
}

/** @internal */
export const Protected$inboundSchema: z.ZodNativeEnum<typeof Protected> = z
  .nativeEnum(Protected);

/** @internal */
export const Home$inboundSchema: z.ZodNativeEnum<typeof Home> = z.nativeEnum(
  Home,
);

/** @internal */
export const AllowTuners$inboundSchema: z.ZodNativeEnum<typeof AllowTuners> = z
  .nativeEnum(AllowTuners);

/** @internal */
export const AllowSync$inboundSchema: z.ZodNativeEnum<typeof AllowSync> = z
  .nativeEnum(AllowSync);

/** @internal */
export const AllowCameraUpload$inboundSchema: z.ZodNativeEnum<
  typeof AllowCameraUpload
> = z.nativeEnum(AllowCameraUpload);

/** @internal */
export const AllowChannels$inboundSchema: z.ZodNativeEnum<
  typeof AllowChannels
> = z.nativeEnum(AllowChannels);

/** @internal */
export const AllowSubtitleAdmin$inboundSchema: z.ZodNativeEnum<
  typeof AllowSubtitleAdmin
> = z.nativeEnum(AllowSubtitleAdmin);

/** @internal */
export const Restricted$inboundSchema: z.ZodNativeEnum<typeof Restricted> = z
  .nativeEnum(Restricted);

/** @internal */
export const AllLibraries$inboundSchema: z.ZodNativeEnum<typeof AllLibraries> =
  z.nativeEnum(AllLibraries);

/** @internal */
export const Owned$inboundSchema: z.ZodNativeEnum<typeof Owned> = z.nativeEnum(
  Owned,
);

/** @internal */
export const Pending$inboundSchema: z.ZodNativeEnum<typeof Pending> = z
  .nativeEnum(Pending);

/** @internal */
export const Server$inboundSchema: z.ZodType<Server, z.ZodTypeDef, unknown> = z
  .object({
    id: z.number().int(),
    serverId: z.number().int(),
    machineIdentifier: z.string(),
    name: z.string(),
    lastSeenAt: z.number().int(),
    numLibraries: z.number().int(),
    allLibraries: AllLibraries$inboundSchema.default(AllLibraries.Disable),
    owned: Owned$inboundSchema.default(Owned.Disable),
    pending: Pending$inboundSchema.default(Pending.Disable),
  });

export function serverFromJSON(
  jsonString: string,
): SafeParseResult<Server, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Server$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Server' from JSON`,
  );
}

/** @internal */
export const User$inboundSchema: z.ZodType<User, z.ZodTypeDef, unknown> = z
  .object({
    id: z.number().int(),
    title: z.string(),
    username: z.string(),
    email: z.string(),
    recommendationsPlaylistId: z.nullable(z.string()).optional(),
    thumb: z.string(),
    protected: Protected$inboundSchema.default(Protected.Disable),
    home: Home$inboundSchema.default(Home.Disable),
    allowTuners: AllowTuners$inboundSchema.default(AllowTuners.Disable),
    allowSync: AllowSync$inboundSchema.default(AllowSync.Disable),
    allowCameraUpload: AllowCameraUpload$inboundSchema.default(
      AllowCameraUpload.Disable,
    ),
    allowChannels: AllowChannels$inboundSchema.default(AllowChannels.Disable),
    allowSubtitleAdmin: AllowSubtitleAdmin$inboundSchema.default(
      AllowSubtitleAdmin.Disable,
    ),
    filterAll: z.nullable(z.string()).optional(),
    filterMovies: z.nullable(z.string()).optional(),
    filterMusic: z.nullable(z.string()).optional(),
    filterPhotos: z.nullable(z.string()).optional(),
    filterTelevision: z.string().optional(),
    restricted: Restricted$inboundSchema.default(Restricted.Disable),
    Server: z.array(z.lazy(() => Server$inboundSchema)),
  }).transform((v) => {
    return remap$(v, {
      "Server": "server",
    });
  });

export function userFromJSON(
  jsonString: string,
): SafeParseResult<User, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => User$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'User' from JSON`,
  );
}

/** @internal */
export const GetUsersMediaContainer$inboundSchema: z.ZodType<
  GetUsersMediaContainer,
  z.ZodTypeDef,
  unknown
> = z.object({
  friendlyName: z.string(),
  identifier: z.string(),
  machineIdentifier: z.string(),
  totalSize: z.number().int(),
  size: z.number().int(),
  User: z.array(z.lazy(() => User$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "User": "user",
  });
});

export function getUsersMediaContainerFromJSON(
  jsonString: string,
): SafeParseResult<GetUsersMediaContainer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUsersMediaContainer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUsersMediaContainer' from JSON`,
  );
}

/** @internal */
export const GetUsersResponseBody$inboundSchema: z.ZodType<
  GetUsersResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  MediaContainer: z.lazy(() => GetUsersMediaContainer$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "MediaContainer": "mediaContainer",
  });
});

export function getUsersResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetUsersResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUsersResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUsersResponseBody' from JSON`,
  );
}

/** @internal */
export const GetUsersResponse$inboundSchema: z.ZodType<
  GetUsersResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  ContentType: z.string(),
  StatusCode: z.number().int(),
  RawResponse: z.instanceof(Response),
  object: z.lazy(() => GetUsersResponseBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "ContentType": "contentType",
    "StatusCode": "statusCode",
    "RawResponse": "rawResponse",
  });
});

export function getUsersResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetUsersResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetUsersResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetUsersResponse' from JSON`,
  );
}
