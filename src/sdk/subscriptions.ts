/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { subscriptionsCancelGrab } from "../funcs/subscriptionsCancelGrab.js";
import { subscriptionsCreateSubscription } from "../funcs/subscriptionsCreateSubscription.js";
import { subscriptionsDeleteSubscription } from "../funcs/subscriptionsDeleteSubscription.js";
import { subscriptionsEditSubscriptionPreferences } from "../funcs/subscriptionsEditSubscriptionPreferences.js";
import { subscriptionsGetAllSubscriptions } from "../funcs/subscriptionsGetAllSubscriptions.js";
import { subscriptionsGetScheduledRecordings } from "../funcs/subscriptionsGetScheduledRecordings.js";
import { subscriptionsGetSubscription } from "../funcs/subscriptionsGetSubscription.js";
import { subscriptionsGetTemplate } from "../funcs/subscriptionsGetTemplate.js";
import { subscriptionsProcessSubscriptions } from "../funcs/subscriptionsProcessSubscriptions.js";
import { subscriptionsReorderSubscription } from "../funcs/subscriptionsReorderSubscription.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import * as shared from "../models/shared/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Subscriptions extends ClientSDK {
  /**
   * Get all subscriptions
   *
   * @remarks
   * Get all subscriptions and potentially the grabs too
   */
  async getAllSubscriptions(
    request: operations.GetAllSubscriptionsRequest,
    options?: RequestOptions,
  ): Promise<operations.GetAllSubscriptionsResponse> {
    return unwrapAsync(subscriptionsGetAllSubscriptions(
      this,
      request,
      options,
    ));
  }

  /**
   * Create a subscription
   *
   * @remarks
   * Create a subscription. The query parameters should be mostly derived from the [template](#tag/Subscriptions/operation/mediaSubscriptionsGetTemplate)
   */
  async createSubscription(
    request: operations.CreateSubscriptionRequest,
    options?: RequestOptions,
  ): Promise<operations.CreateSubscriptionResponse> {
    return unwrapAsync(subscriptionsCreateSubscription(
      this,
      request,
      options,
    ));
  }

  /**
   * Process all subscriptions
   *
   * @remarks
   * Process all subscriptions asynchronously
   */
  async processSubscriptions(
    options?: RequestOptions,
  ): Promise<operations.ProcessSubscriptionsResponse | undefined> {
    return unwrapAsync(subscriptionsProcessSubscriptions(
      this,
      options,
    ));
  }

  /**
   * Get all scheduled recordings
   *
   * @remarks
   * Get all scheduled recordings across all subscriptions
   */
  async getScheduledRecordings(
    options?: RequestOptions,
  ): Promise<operations.GetScheduledRecordingsResponse> {
    return unwrapAsync(subscriptionsGetScheduledRecordings(
      this,
      options,
    ));
  }

  /**
   * Get the subscription template
   *
   * @remarks
   * Get the templates for a piece of media which could include fetching one airing, season, the whole show, etc.
   */
  async getTemplate(
    request: operations.GetTemplateRequest,
    options?: RequestOptions,
  ): Promise<operations.GetTemplateResponse> {
    return unwrapAsync(subscriptionsGetTemplate(
      this,
      request,
      options,
    ));
  }

  /**
   * Cancel an existing grab
   *
   * @remarks
   * Cancels an existing media grab (recording). It can be used to resolve a conflict which exists for a rolling subscription.
   * Note: This cancellation does not persist across a server restart, but neither does a rolling subscription itself.
   */
  async cancelGrab(
    request: operations.CancelGrabRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(subscriptionsCancelGrab(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a subscription
   *
   * @remarks
   * Delete a subscription, cancelling all of its grabs as well
   */
  async deleteSubscription(
    request: operations.DeleteSubscriptionRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(subscriptionsDeleteSubscription(
      this,
      request,
      options,
    ));
  }

  /**
   * Get a single subscription
   *
   * @remarks
   * Get a single subscription and potentially the grabs too
   */
  async getSubscription(
    request: operations.GetSubscriptionRequest,
    options?: RequestOptions,
  ): Promise<shared.MediaContainerWithSubscription> {
    return unwrapAsync(subscriptionsGetSubscription(
      this,
      request,
      options,
    ));
  }

  /**
   * Edit a subscription
   *
   * @remarks
   * Edit a subscription's preferences
   */
  async editSubscriptionPreferences(
    request: operations.EditSubscriptionPreferencesRequest,
    options?: RequestOptions,
  ): Promise<shared.MediaContainerWithSubscription> {
    return unwrapAsync(subscriptionsEditSubscriptionPreferences(
      this,
      request,
      options,
    ));
  }

  /**
   * Re-order a subscription
   *
   * @remarks
   * Re-order a subscription to change its priority
   */
  async reorderSubscription(
    request: operations.ReorderSubscriptionRequest,
    options?: RequestOptions,
  ): Promise<shared.MediaContainerWithSubscription> {
    return unwrapAsync(subscriptionsReorderSubscription(
      this,
      request,
      options,
    ));
  }
}
