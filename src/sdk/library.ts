/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeFormQuery as encodeFormQuery$,
    encodeSimple as encodeSimple$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";

export class Library extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * Get Hash Value
     *
     * @remarks
     * This resource returns hash values for local files
     */
    async getFileHash(
        url: string,
        type?: number | undefined,
        options?: RequestOptions
    ): Promise<models.GetFileHashResponse> {
        const input$: models.GetFileHashRequest = {
            url: url,
            type: type,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetFileHashRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/library/hashes")();

        const query$ = encodeFormQuery$({
            type: payload$.type,
            url: payload$.url,
        });

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "getFileHash",
            oAuth2Scopes: [],
            securitySource: this.options$.accessToken,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<models.GetFileHashResponse>()
            .void(200, models.GetFileHashResponse$)
            .fail([400, "4XX", "5XX"])
            .json(401, models.GetFileHashResponseBody$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Recently Added
     *
     * @remarks
     * This endpoint will return the recently added content.
     *
     */
    async getRecentlyAdded(options?: RequestOptions): Promise<models.GetRecentlyAddedResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/library/recentlyAdded")();

        const query$ = "";

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "getRecentlyAdded",
            oAuth2Scopes: [],
            securitySource: this.options$.accessToken,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<models.GetRecentlyAddedResponse>()
            .json(200, models.GetRecentlyAddedResponse$, { key: "object" })
            .fail([400, "4XX", "5XX"])
            .json(401, models.GetRecentlyAddedLibraryResponseBody$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get All Libraries
     *
     * @remarks
     * A library section (commonly referred to as just a library) is a collection of media.
     * Libraries are typed, and depending on their type provide either a flat or a hierarchical view of the media.
     * For example, a music library has an artist > albums > tracks structure, whereas a movie library is flat.
     *
     * Libraries have features beyond just being a collection of media; for starters, they include information about supported types, filters and sorts.
     * This allows a client to provide a rich interface around the media (e.g. allow sorting movies by release year).
     *
     */
    async getLibraries(options?: RequestOptions): Promise<models.GetLibrariesResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/library/sections")();

        const query$ = "";

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "getLibraries",
            oAuth2Scopes: [],
            securitySource: this.options$.accessToken,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<models.GetLibrariesResponse>()
            .json(200, models.GetLibrariesResponse$, { key: "object" })
            .fail([400, "4XX", "5XX"])
            .json(401, models.GetLibrariesLibraryResponseBody$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Library Details
     *
     * @remarks
     * ## Library Details Endpoint
     *
     * This endpoint provides comprehensive details about the library, focusing on organizational aspects rather than the content itself.
     *
     * The details include:
     *
     * ### Directories
     * Organized into three categories:
     *
     * - **Primary Directories**:
     *   - Used in some clients for quick access to media subsets (e.g., "All", "On Deck").
     *   - Most can be replicated via media queries.
     *   - Customizable by users.
     *
     * - **Secondary Directories**:
     *   - Marked with `secondary="1"`.
     *   - Used in older clients for structured navigation.
     *
     * - **Special Directories**:
     *   - Includes a "By Folder" entry for filesystem-based browsing.
     *   - Contains an obsolete `search="1"` entry for on-the-fly search dialog creation.
     *
     * ### Types
     * Each type in the library comes with a set of filters and sorts, aiding in building dynamic media controls:
     *
     * - **Type Object Attributes**:
     *   - `key`: Endpoint for the media list of this type.
     *   - `type`: Metadata type (if standard Plex type).
     *   - `title`: Title for this content type (e.g., "Movies").
     *
     * - **Filter Objects**:
     *   - Subset of the media query language.
     *   - Attributes include `filter` (name), `filterType` (data type), `key` (endpoint for value range), and `title`.
     *
     * - **Sort Objects**:
     *   - Description of sort fields.
     *   - Attributes include `defaultDirection` (asc/desc), `descKey` and `key` (sort parameters), and `title`.
     *
     * > **Note**: Filters and sorts are optional; without them, no filtering controls are rendered.
     *
     */
    async getLibrary(
        sectionId: number,
        includeDetails?: models.IncludeDetails | undefined,
        options?: RequestOptions
    ): Promise<models.GetLibraryResponse> {
        const input$: models.GetLibraryRequest = {
            sectionId: sectionId,
            includeDetails: includeDetails,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetLibraryRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            sectionId: encodeSimple$("sectionId", payload$.sectionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/library/sections/{sectionId}")(pathParams$);

        const query$ = encodeFormQuery$({
            includeDetails: payload$.includeDetails,
        });

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "getLibrary",
            oAuth2Scopes: [],
            securitySource: this.options$.accessToken,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<models.GetLibraryResponse>()
            .json(200, models.GetLibraryResponse$, { key: "object" })
            .fail([400, "4XX", "5XX"])
            .json(401, models.GetLibraryLibraryResponseBody$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Delete Library Section
     *
     * @remarks
     * Delate a library using a specific section
     */
    async deleteLibrary(
        sectionId: number,
        options?: RequestOptions
    ): Promise<models.DeleteLibraryResponse> {
        const input$: models.DeleteLibraryRequest = {
            sectionId: sectionId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.DeleteLibraryRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            sectionId: encodeSimple$("sectionId", payload$.sectionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/library/sections/{sectionId}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "deleteLibrary",
            oAuth2Scopes: [],
            securitySource: this.options$.accessToken,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<models.DeleteLibraryResponse>()
            .void(200, models.DeleteLibraryResponse$)
            .fail([400, "4XX", "5XX"])
            .json(401, models.DeleteLibraryResponseBody$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Library Items
     *
     * @remarks
     * Fetches details from a specific section of the library identified by a section key and a tag. The tag parameter accepts the following values:
     * - `all`: All items in the section.
     * - `unwatched`: Items that have not been played.
     * - `newest`: Items that are recently released.
     * - `recentlyAdded`: Items that are recently added to the library.
     * - `recentlyViewed`: Items that were recently viewed.
     * - `onDeck`: Items to continue watching.
     * - `collection`: Items categorized by collection.
     * - `edition`: Items categorized by edition.
     * - `genre`: Items categorized by genre.
     * - `year`: Items categorized by year of release.
     * - `decade`: Items categorized by decade.
     * - `director`: Items categorized by director.
     * - `actor`: Items categorized by starring actor.
     * - `country`: Items categorized by country of origin.
     * - `contentRating`: Items categorized by content rating.
     * - `rating`: Items categorized by rating.
     * - `resolution`: Items categorized by resolution.
     * - `firstCharacter`: Items categorized by the first letter.
     * - `folder`: Items categorized by folder.
     *
     */
    async getLibraryItems(
        sectionId: any,
        tag: models.Tag,
        includeGuids?: number | undefined,
        options?: RequestOptions
    ): Promise<models.GetLibraryItemsResponse> {
        const input$: models.GetLibraryItemsRequest = {
            sectionId: sectionId,
            tag: tag,
            includeGuids: includeGuids,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetLibraryItemsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            sectionId: encodeSimple$("sectionId", payload$.sectionId, {
                explode: false,
                charEncoding: "percent",
            }),
            tag: encodeSimple$("tag", payload$.tag, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/library/sections/{sectionId}/{tag}")(pathParams$);

        const query$ = encodeFormQuery$({
            includeGuids: payload$.includeGuids,
        });

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "getLibraryItems",
            oAuth2Scopes: [],
            securitySource: this.options$.accessToken,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<models.GetLibraryItemsResponse>()
            .json(200, models.GetLibraryItemsResponse$, { key: "object" })
            .fail([400, "4XX", "5XX"])
            .json(401, models.GetLibraryItemsLibraryResponseBody$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Refresh Library
     *
     * @remarks
     * This endpoint Refreshes the library.
     *
     */
    async refreshLibrary(
        sectionId: number,
        options?: RequestOptions
    ): Promise<models.RefreshLibraryResponse> {
        const input$: models.RefreshLibraryRequest = {
            sectionId: sectionId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.RefreshLibraryRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            sectionId: encodeSimple$("sectionId", payload$.sectionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/library/sections/{sectionId}/refresh")(
            pathParams$
        );

        const query$ = "";

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "refreshLibrary",
            oAuth2Scopes: [],
            securitySource: this.options$.accessToken,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<models.RefreshLibraryResponse>()
            .void(200, models.RefreshLibraryResponse$)
            .fail([400, "4XX", "5XX"])
            .json(401, models.RefreshLibraryResponseBody$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Search Library
     *
     * @remarks
     * Search for content within a specific section of the library.
     *
     * ### Types
     * Each type in the library comes with a set of filters and sorts, aiding in building dynamic media controls:
     *
     * - **Type Object Attributes**:
     *   - `type`: Metadata type (if standard Plex type).
     *   - `title`: Title for this content type (e.g., "Movies").
     *
     * - **Filter Objects**:
     *   - Subset of the media query language.
     *   - Attributes include `filter` (name), `filterType` (data type), `key` (endpoint for value range), and `title`.
     *
     * - **Sort Objects**:
     *   - Description of sort fields.
     *   - Attributes include `defaultDirection` (asc/desc), `descKey` and `key` (sort parameters), and `title`.
     *
     * > **Note**: Filters and sorts are optional; without them, no filtering controls are rendered.
     *
     */
    async searchLibrary(
        sectionId: number,
        type: models.Type,
        options?: RequestOptions
    ): Promise<models.SearchLibraryResponse> {
        const input$: models.SearchLibraryRequest = {
            sectionId: sectionId,
            type: type,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.SearchLibraryRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            sectionId: encodeSimple$("sectionId", payload$.sectionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/library/sections/{sectionId}/search")(
            pathParams$
        );

        const query$ = encodeFormQuery$({
            type: payload$.type,
        });

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "searchLibrary",
            oAuth2Scopes: [],
            securitySource: this.options$.accessToken,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<models.SearchLibraryResponse>()
            .json(200, models.SearchLibraryResponse$, { key: "object" })
            .fail([400, "4XX", "5XX"])
            .json(401, models.SearchLibraryLibraryResponseBody$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Items Metadata
     *
     * @remarks
     * This endpoint will return the metadata of a library item specified with the ratingKey.
     *
     */
    async getMetadata(
        ratingKey: number,
        options?: RequestOptions
    ): Promise<models.GetMetadataResponse> {
        const input$: models.GetMetadataRequest = {
            ratingKey: ratingKey,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetMetadataRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ratingKey: encodeSimple$("ratingKey", payload$.ratingKey, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/library/metadata/{ratingKey}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "getMetadata",
            oAuth2Scopes: [],
            securitySource: this.options$.accessToken,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<models.GetMetadataResponse>()
            .json(200, models.GetMetadataResponse$, { key: "object" })
            .fail([400, "4XX", "5XX"])
            .json(401, models.GetMetadataLibraryResponseBody$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Items Children
     *
     * @remarks
     * This endpoint will return the children of of a library item specified with the ratingKey.
     *
     */
    async getMetadataChildren(
        ratingKey: number,
        includeElements?: string | undefined,
        options?: RequestOptions
    ): Promise<models.GetMetadataChildrenResponse> {
        const input$: models.GetMetadataChildrenRequest = {
            ratingKey: ratingKey,
            includeElements: includeElements,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetMetadataChildrenRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            ratingKey: encodeSimple$("ratingKey", payload$.ratingKey, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/library/metadata/{ratingKey}/children")(
            pathParams$
        );

        const query$ = encodeFormQuery$({
            includeElements: payload$.includeElements,
        });

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "getMetadataChildren",
            oAuth2Scopes: [],
            securitySource: this.options$.accessToken,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<models.GetMetadataChildrenResponse>()
            .json(200, models.GetMetadataChildrenResponse$, { key: "object" })
            .fail([400, "4XX", "5XX"])
            .json(401, models.GetMetadataChildrenLibraryResponseBody$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get Top Watched Content
     *
     * @remarks
     * This endpoint will return the top watched content from libraries of a certain type
     *
     */
    async getTopWatchedContent(
        type: number,
        includeGuids?: number | undefined,
        options?: RequestOptions
    ): Promise<models.GetTopWatchedContentResponse> {
        const input$: models.GetTopWatchedContentRequest = {
            type: type,
            includeGuids: includeGuids,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => models.GetTopWatchedContentRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/library/all/top")();

        const query$ = encodeFormQuery$({
            includeGuids: payload$.includeGuids,
            type: payload$.type,
        });

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "getTopWatchedContent",
            oAuth2Scopes: [],
            securitySource: this.options$.accessToken,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<models.GetTopWatchedContentResponse>()
            .json(200, models.GetTopWatchedContentResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get On Deck
     *
     * @remarks
     * This endpoint will return the on deck content.
     *
     */
    async getOnDeck(options?: RequestOptions): Promise<models.GetOnDeckResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/library/onDeck")();

        const query$ = "";

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "getOnDeck",
            oAuth2Scopes: [],
            securitySource: this.options$.accessToken,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["400", "401", "4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<models.GetOnDeckResponse>()
            .json(200, models.GetOnDeckResponse$, { key: "object" })
            .fail([400, "4XX", "5XX"])
            .json(401, models.GetOnDeckLibraryResponseBody$, { err: true })
            .match(response, { extraFields: responseFields$ });

        return result$;
    }
}
