/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import * as errors from "../models/errors";
import * as operations from "../models/operations";

export class Library extends ClientSDK {
    private readonly options$: SDKOptions;

    constructor(options: SDKOptions = {}) {
        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
        });

        this.options$ = options;
        void this.options$;
    }
    /**
     * Get Hash Value
     *
     * @remarks
     * This resource returns hash values for local files
     */
    async getFileHash(
        url: string,
        type?: number | undefined,
        options?: RequestOptions
    ): Promise<operations.GetFileHashResponse> {
        const input$: operations.GetFileHashRequest = {
            url: url,
            type: type,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetFileHashRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/library/hashes")();

        const query$ = [
            enc$.encodeForm("type", payload$.type, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("url", payload$.url, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.GetFileHashResponseBody$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.GetFileHashResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Get Recently Added
     *
     * @remarks
     * This endpoint will return the recently added content.
     *
     */
    async getRecentlyAdded(options?: RequestOptions): Promise<operations.GetRecentlyAddedResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/library/recentlyAdded")();

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetRecentlyAddedResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.GetRecentlyAddedResponseBody$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get All Libraries
     *
     * @remarks
     * A library section (commonly referred to as just a library) is a collection of media.
     * Libraries are typed, and depending on their type provide either a flat or a hierarchical view of the media.
     * For example, a music library has an artist > albums > tracks structure, whereas a movie library is flat.
     *
     * Libraries have features beyond just being a collection of media; for starters, they include information about supported types, filters and sorts.
     * This allows a client to provide a rich interface around the media (e.g. allow sorting movies by release year).
     *
     */
    async getLibraries(options?: RequestOptions): Promise<operations.GetLibrariesResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/library/sections")();

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetLibrariesResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.GetLibrariesResponseBody$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get Library Details
     *
     * @remarks
     * ## Library Details Endpoint
     *
     * This endpoint provides comprehensive details about the library, focusing on organizational aspects rather than the content itself.
     *
     * The details include:
     *
     * ### Directories
     * Organized into three categories:
     *
     * - **Primary Directories**:
     *   - Used in some clients for quick access to media subsets (e.g., "All", "On Deck").
     *   - Most can be replicated via media queries.
     *   - Customizable by users.
     *
     * - **Secondary Directories**:
     *   - Marked with `secondary="1"`.
     *   - Used in older clients for structured navigation.
     *
     * - **Special Directories**:
     *   - Includes a "By Folder" entry for filesystem-based browsing.
     *   - Contains an obsolete `search="1"` entry for on-the-fly search dialog creation.
     *
     * ### Types
     * Each type in the library comes with a set of filters and sorts, aiding in building dynamic media controls:
     *
     * - **Type Object Attributes**:
     *   - `key`: Endpoint for the media list of this type.
     *   - `type`: Metadata type (if standard Plex type).
     *   - `title`: Title for this content type (e.g., "Movies").
     *
     * - **Filter Objects**:
     *   - Subset of the media query language.
     *   - Attributes include `filter` (name), `filterType` (data type), `key` (endpoint for value range), and `title`.
     *
     * - **Sort Objects**:
     *   - Description of sort fields.
     *   - Attributes include `defaultDirection` (asc/desc), `descKey` and `key` (sort parameters), and `title`.
     *
     * > **Note**: Filters and sorts are optional; without them, no filtering controls are rendered.
     *
     */
    async getLibrary(
        sectionId: number,
        includeDetails?: operations.IncludeDetails | undefined,
        options?: RequestOptions
    ): Promise<operations.GetLibraryResponse> {
        const input$: operations.GetLibraryRequest = {
            sectionId: sectionId,
            includeDetails: includeDetails,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetLibraryRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            sectionId: enc$.encodeSimple("sectionId", payload$.sectionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/library/sections/{sectionId}")(pathParams$);

        const query$ = [
            enc$.encodeForm("includeDetails", payload$.includeDetails, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetLibraryResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.GetLibraryResponseBody$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Delete Library Section
     *
     * @remarks
     * Delate a library using a specific section
     */
    async deleteLibrary(
        sectionId: number,
        options?: RequestOptions
    ): Promise<operations.DeleteLibraryResponse> {
        const input$: operations.DeleteLibraryRequest = {
            sectionId: sectionId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.DeleteLibraryRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            sectionId: enc$.encodeSimple("sectionId", payload$.sectionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/library/sections/{sectionId}")(pathParams$);

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.DeleteLibraryResponseBody$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DeleteLibraryResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Get Library Items
     *
     * @remarks
     * Fetches details from a specific section of the library identified by a section key and a tag. The tag parameter accepts the following values:
     * - `all`: All items in the section.
     * - `unwatched`: Items that have not been played.
     * - `newest`: Items that are recently released.
     * - `recentlyAdded`: Items that are recently added to the library.
     * - `recentlyViewed`: Items that were recently viewed.
     * - `onDeck`: Items to continue watching.
     * - `collection`: Items categorized by collection.
     * - `edition`: Items categorized by edition.
     * - `genre`: Items categorized by genre.
     * - `year`: Items categorized by year of release.
     * - `decade`: Items categorized by decade.
     * - `director`: Items categorized by director.
     * - `actor`: Items categorized by starring actor.
     * - `country`: Items categorized by country of origin.
     * - `contentRating`: Items categorized by content rating.
     * - `rating`: Items categorized by rating.
     * - `resolution`: Items categorized by resolution.
     * - `firstCharacter`: Items categorized by the first letter.
     * - `folder`: Items categorized by folder.
     * - `search?type=1`: Search functionality within the section.
     *
     */
    async getLibraryItems(
        sectionId: number,
        tag: operations.Tag,
        options?: RequestOptions
    ): Promise<operations.GetLibraryItemsResponse> {
        const input$: operations.GetLibraryItemsRequest = {
            sectionId: sectionId,
            tag: tag,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetLibraryItemsRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            sectionId: enc$.encodeSimple("sectionId", payload$.sectionId, {
                explode: false,
                charEncoding: "percent",
            }),
            tag: enc$.encodeSimple("tag", payload$.tag, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/library/sections/{sectionId}/{tag}")(pathParams$);

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetLibraryItemsResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Refresh Library
     *
     * @remarks
     * This endpoint Refreshes the library.
     *
     */
    async refreshLibrary(
        sectionId: number,
        options?: RequestOptions
    ): Promise<operations.RefreshLibraryResponse> {
        const input$: operations.RefreshLibraryRequest = {
            sectionId: sectionId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.RefreshLibraryRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            sectionId: enc$.encodeSimple("sectionId", payload$.sectionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/library/sections/{sectionId}/refresh")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.RefreshLibraryResponseBody$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.RefreshLibraryResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * Get Items Metadata
     *
     * @remarks
     * This endpoint will return the metadata of a library item specified with the ratingKey.
     *
     */
    async getMetadata(
        ratingKey: number,
        options?: RequestOptions
    ): Promise<operations.GetMetadataResponse> {
        const input$: operations.GetMetadataRequest = {
            ratingKey: ratingKey,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetMetadataRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            ratingKey: enc$.encodeSimple("ratingKey", payload$.ratingKey, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/library/metadata/{ratingKey}")(pathParams$);

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetMetadataResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.GetMetadataResponseBody$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get Items Children
     *
     * @remarks
     * This endpoint will return the children of of a library item specified with the ratingKey.
     *
     */
    async getMetadataChildren(
        ratingKey: number,
        options?: RequestOptions
    ): Promise<operations.GetMetadataChildrenResponse> {
        const input$: operations.GetMetadataChildrenRequest = {
            ratingKey: ratingKey,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetMetadataChildrenRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            ratingKey: enc$.encodeSimple("ratingKey", payload$.ratingKey, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/library/metadata/{ratingKey}/children")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetMetadataChildrenResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.GetMetadataChildrenResponseBody$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get On Deck
     *
     * @remarks
     * This endpoint will return the on deck content.
     *
     */
    async getOnDeck(options?: RequestOptions): Promise<operations.GetOnDeckResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/library/onDeck")();

        let security$;
        if (typeof this.options$.accessToken === "function") {
            security$ = { accessToken: await this.options$.accessToken() };
        } else if (this.options$.accessToken) {
            security$ = { accessToken: this.options$.accessToken };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetOnDeckResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else if (this.matchResponse(response, 401, "application/json")) {
            const responseBody = await response.json();
            const result = errors.GetOnDeckResponseBody$.inboundSchema.parse({
                ...responseFields$,
                ...responseBody,
            });
            throw result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }
}
