/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { libraryAddExtras } from "../funcs/libraryAddExtras.js";
import { libraryAddSection } from "../funcs/libraryAddSection.js";
import { libraryAddSubtitles } from "../funcs/libraryAddSubtitles.js";
import { libraryAnalyzeMetadata } from "../funcs/libraryAnalyzeMetadata.js";
import { libraryAutocomplete } from "../funcs/libraryAutocomplete.js";
import { libraryCancelRefresh } from "../funcs/libraryCancelRefresh.js";
import { libraryCleanBundles } from "../funcs/libraryCleanBundles.js";
import { libraryCreateMarker } from "../funcs/libraryCreateMarker.js";
import { libraryDeleteCaches } from "../funcs/libraryDeleteCaches.js";
import { libraryDeleteCollection } from "../funcs/libraryDeleteCollection.js";
import { libraryDeleteIndexes } from "../funcs/libraryDeleteIndexes.js";
import { libraryDeleteIntros } from "../funcs/libraryDeleteIntros.js";
import { libraryDeleteLibrarySection } from "../funcs/libraryDeleteLibrarySection.js";
import { libraryDeleteMarker } from "../funcs/libraryDeleteMarker.js";
import { libraryDeleteMediaItem } from "../funcs/libraryDeleteMediaItem.js";
import { libraryDeleteMetadataItem } from "../funcs/libraryDeleteMetadataItem.js";
import { libraryDeleteStream } from "../funcs/libraryDeleteStream.js";
import { libraryDetectAds } from "../funcs/libraryDetectAds.js";
import { libraryDetectCredits } from "../funcs/libraryDetectCredits.js";
import { libraryDetectIntros } from "../funcs/libraryDetectIntros.js";
import { libraryDetectVoiceActivity } from "../funcs/libraryDetectVoiceActivity.js";
import { libraryEditMarker } from "../funcs/libraryEditMarker.js";
import { libraryEditMetadataItem } from "../funcs/libraryEditMetadataItem.js";
import { libraryEditSection } from "../funcs/libraryEditSection.js";
import { libraryEmptyTrash } from "../funcs/libraryEmptyTrash.js";
import { libraryGenerateThumbs } from "../funcs/libraryGenerateThumbs.js";
import { libraryGetAllItemLeaves } from "../funcs/libraryGetAllItemLeaves.js";
import { libraryGetAugmentationStatus } from "../funcs/libraryGetAugmentationStatus.js";
import { libraryGetAvailableSorts } from "../funcs/libraryGetAvailableSorts.js";
import { libraryGetChapterImage } from "../funcs/libraryGetChapterImage.js";
import { libraryGetCollections } from "../funcs/libraryGetCollections.js";
import { libraryGetCommon } from "../funcs/libraryGetCommon.js";
import { libraryGetExtras } from "../funcs/libraryGetExtras.js";
import { GetFileAcceptEnum, libraryGetFile } from "../funcs/libraryGetFile.js";
import { libraryGetFirstCharacters } from "../funcs/libraryGetFirstCharacters.js";
import { libraryGetImageFromBif } from "../funcs/libraryGetImageFromBif.js";
import {
  GetItemArtworkAcceptEnum,
  libraryGetItemArtwork,
} from "../funcs/libraryGetItemArtwork.js";
import { libraryGetItemTree } from "../funcs/libraryGetItemTree.js";
import { libraryGetLibraryDetails } from "../funcs/libraryGetLibraryDetails.js";
import { libraryGetLibraryItems } from "../funcs/libraryGetLibraryItems.js";
import { libraryGetLibraryMatches } from "../funcs/libraryGetLibraryMatches.js";
import { libraryGetMediaPart } from "../funcs/libraryGetMediaPart.js";
import { libraryGetPartIndex } from "../funcs/libraryGetPartIndex.js";
import { libraryGetPerson } from "../funcs/libraryGetPerson.js";
import { libraryGetRandomArtwork } from "../funcs/libraryGetRandomArtwork.js";
import { libraryGetRelatedItems } from "../funcs/libraryGetRelatedItems.js";
import { libraryGetSectionFilters } from "../funcs/libraryGetSectionFilters.js";
import { libraryGetSectionImage } from "../funcs/libraryGetSectionImage.js";
import { libraryGetSectionPreferences } from "../funcs/libraryGetSectionPreferences.js";
import { libraryGetSections } from "../funcs/libraryGetSections.js";
import { libraryGetSectionsPrefs } from "../funcs/libraryGetSectionsPrefs.js";
import { libraryGetStream } from "../funcs/libraryGetStream.js";
import { libraryGetStreamLevels } from "../funcs/libraryGetStreamLevels.js";
import { libraryGetStreamLoudness } from "../funcs/libraryGetStreamLoudness.js";
import { libraryGetTags } from "../funcs/libraryGetTags.js";
import { libraryIngestTransientItem } from "../funcs/libraryIngestTransientItem.js";
import { libraryListMatches } from "../funcs/libraryListMatches.js";
import { libraryListPersonMedia } from "../funcs/libraryListPersonMedia.js";
import { libraryListSimilar } from "../funcs/libraryListSimilar.js";
import { libraryListSonicallySimilar } from "../funcs/libraryListSonicallySimilar.js";
import { libraryListTopUsers } from "../funcs/libraryListTopUsers.js";
import { libraryMatchItem } from "../funcs/libraryMatchItem.js";
import { libraryMergeItems } from "../funcs/libraryMergeItems.js";
import { libraryOptimizeDatabase } from "../funcs/libraryOptimizeDatabase.js";
import { libraryRefreshItemsMetadata } from "../funcs/libraryRefreshItemsMetadata.js";
import { libraryRefreshSection } from "../funcs/libraryRefreshSection.js";
import { libraryRefreshSectionsMetadata } from "../funcs/libraryRefreshSectionsMetadata.js";
import { librarySetItemArtwork } from "../funcs/librarySetItemArtwork.js";
import { librarySetItemPreferences } from "../funcs/librarySetItemPreferences.js";
import { librarySetSectionPreferences } from "../funcs/librarySetSectionPreferences.js";
import { librarySetStreamOffset } from "../funcs/librarySetStreamOffset.js";
import { librarySetStreamSelection } from "../funcs/librarySetStreamSelection.js";
import { librarySplitItem } from "../funcs/librarySplitItem.js";
import { libraryStartAnalysis } from "../funcs/libraryStartAnalysis.js";
import { libraryStartBifGeneration } from "../funcs/libraryStartBifGeneration.js";
import { libraryStopAllRefreshes } from "../funcs/libraryStopAllRefreshes.js";
import { libraryUnmatch } from "../funcs/libraryUnmatch.js";
import { libraryUpdateItemArtwork } from "../funcs/libraryUpdateItemArtwork.js";
import { libraryUpdateItems } from "../funcs/libraryUpdateItems.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import * as shared from "../models/shared/index.js";
import { unwrapAsync } from "../types/fp.js";

export { GetFileAcceptEnum } from "../funcs/libraryGetFile.js";

export { GetItemArtworkAcceptEnum } from "../funcs/libraryGetItemArtwork.js";

export class Library extends ClientSDK {
  /**
   * Get all items in library
   *
   * @remarks
   * Request all metadata items according to a query.
   */
  async getLibraryItems(
    request: operations.GetLibraryItemsRequest,
    options?: RequestOptions,
  ): Promise<operations.GetLibraryItemsResponse> {
    return unwrapAsync(libraryGetLibraryItems(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete library caches
   *
   * @remarks
   * Delete the hub caches so they are recomputed on next request
   */
  async deleteCaches(
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDeleteCaches(
      this,
      options,
    ));
  }

  /**
   * Clean bundles
   *
   * @remarks
   * Clean out any now unused bundles. Bundles can become unused when media is deleted
   */
  async cleanBundles(
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryCleanBundles(
      this,
      options,
    ));
  }

  /**
   * Ingest a transient item
   *
   * @remarks
   * This endpoint takes a file path specified in the `url` parameter, matches it using the scanner's match mechanism, downloads rich metadata, and then ingests the item as a transient item (without a library section). In the case where the file represents an episode, the entire tree (show, season, and episode) is added as transient items. At this time, movies and episodes are the only supported types, which are gleaned automatically from the file path.
   * Note that any of the parameters passed to the metadata details endpoint (e.g. `includeExtras=1`) work here.
   */
  async ingestTransientItem(
    request: operations.IngestTransientItemRequest,
    options?: RequestOptions,
  ): Promise<operations.IngestTransientItemResponse> {
    return unwrapAsync(libraryIngestTransientItem(
      this,
      request,
      options,
    ));
  }

  /**
   * Get library matches
   *
   * @remarks
   * The matches endpoint is used to match content external to the library with content inside the library. This is done by passing a series of semantic "hints" about the content (its type, name, or release year). Each type (e.g. movie) has a canonical set of minimal required hints.
   * This ability to match content is useful in a variety of scenarios. For example, in the DVR, the EPG uses the endpoint to match recording rules against airing content. And in the cloud, the UMP uses the endpoint to match up a piece of media with rich metadata.
   * The endpoint response can including multiple matches, if there is ambiguity, each one containing a `score` from 0 to 100. For somewhat historical reasons, anything over 85 is considered a positive match (we prefer false negatives over false positives in general for matching).
   * The `guid` hint is somewhat special, in that it generally represents a unique identity for a piece of media (e.g. the IMDB `ttXXX`) identifier, in contrast with other hints which can be much more ambiguous (e.g. a title of `Jane Eyre`, which could refer to the 1943 or the 2011 version).
   * Episodes require either a season/episode pair, or an air date (or both). Either the path must be sent, or the show title
   */
  async getLibraryMatches(
    request: operations.GetLibraryMatchesRequest,
    options?: RequestOptions,
  ): Promise<operations.GetLibraryMatchesResponse> {
    return unwrapAsync(libraryGetLibraryMatches(
      this,
      request,
      options,
    ));
  }

  /**
   * Optimize the Database
   *
   * @remarks
   * Initiate optimize on the database.
   */
  async optimizeDatabase(
    request: operations.OptimizeDatabaseRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryOptimizeDatabase(
      this,
      request,
      options,
    ));
  }

  /**
   * Get random artwork
   *
   * @remarks
   * Get random artwork across sections.  This is commonly used for a screensaver.
   *
   * This retrieves 100 random artwork paths in the specified sections and returns them.  Restrictions are put in place to not return artwork for items the user is not allowed to access.  Artwork will be for Movies, Shows, and Artists only.
   */
  async getRandomArtwork(
    request: operations.GetRandomArtworkRequest,
    options?: RequestOptions,
  ): Promise<shared.MediaContainerWithArtwork> {
    return unwrapAsync(libraryGetRandomArtwork(
      this,
      request,
      options,
    ));
  }

  /**
   * Get library sections (main Media Provider Only)
   *
   * @remarks
   * A library section (commonly referred to as just a library) is a collection of media. Libraries are typed, and depending on their type provide either a flat or a hierarchical view of the media. For example, a music library has an artist > albums > tracks structure, whereas a movie library is flat.
   * Libraries have features beyond just being a collection of media; for starters, they include information about supported types, filters and sorts. This allows a client to provide a rich interface around the media (e.g. allow sorting movies by release year).
   */
  async getSections(
    options?: RequestOptions,
  ): Promise<operations.GetSectionsResponse> {
    return unwrapAsync(libraryGetSections(
      this,
      options,
    ));
  }

  /**
   * Add a library section
   *
   * @remarks
   * Add a new library section to the server
   */
  async addSection(
    request: operations.AddSectionRequest,
    options?: RequestOptions,
  ): Promise<shared.SlashGetResponses200> {
    return unwrapAsync(libraryAddSection(
      this,
      request,
      options,
    ));
  }

  /**
   * Stop refresh
   *
   * @remarks
   * Stop all refreshes across all sections
   */
  async stopAllRefreshes(
    options?: RequestOptions,
  ): Promise<shared.LibrarySections> {
    return unwrapAsync(libraryStopAllRefreshes(
      this,
      options,
    ));
  }

  /**
   * Get section prefs
   *
   * @remarks
   * Get a section's preferences for a metadata type
   */
  async getSectionsPrefs(
    request: operations.GetSectionsPrefsRequest,
    options?: RequestOptions,
  ): Promise<shared.LibrarySections> {
    return unwrapAsync(libraryGetSectionsPrefs(
      this,
      request,
      options,
    ));
  }

  /**
   * Refresh all sections
   *
   * @remarks
   * Tell PMS to refresh all section metadata
   */
  async refreshSectionsMetadata(
    request: operations.RefreshSectionsMetadataRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryRefreshSectionsMetadata(
      this,
      request,
      options,
    ));
  }

  /**
   * Get all library tags of a type
   *
   * @remarks
   * Get all library tags of a type
   */
  async getTags(
    request: operations.GetTagsRequest,
    options?: RequestOptions,
  ): Promise<operations.GetTagsResponse> {
    return unwrapAsync(libraryGetTags(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a metadata item
   *
   * @remarks
   * Delete a single metadata item from the library, deleting media as well
   */
  async deleteMetadataItem(
    request: operations.DeleteMetadataItemRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDeleteMetadataItem(
      this,
      request,
      options,
    ));
  }

  /**
   * Edit a metadata item
   *
   * @remarks
   * Edit metadata items setting fields
   */
  async editMetadataItem(
    request: operations.EditMetadataItemRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryEditMetadataItem(
      this,
      request,
      options,
    ));
  }

  /**
   * Ad-detect an item
   *
   * @remarks
   * Start the detection of ads in a metadata item
   */
  async detectAds(
    request: operations.DetectAdsRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDetectAds(
      this,
      request,
      options,
    ));
  }

  /**
   * Get the leaves of an item
   *
   * @remarks
   * Get the leaves for a metadata item such as the episodes in a show
   */
  async getAllItemLeaves(
    request: operations.GetAllItemLeavesRequest,
    options?: RequestOptions,
  ): Promise<operations.GetAllItemLeavesResponse> {
    return unwrapAsync(libraryGetAllItemLeaves(
      this,
      request,
      options,
    ));
  }

  /**
   * Analyze an item
   *
   * @remarks
   * Start the analysis of a metadata item
   */
  async analyzeMetadata(
    request: operations.AnalyzeMetadataRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryAnalyzeMetadata(
      this,
      request,
      options,
    ));
  }

  /**
   * Generate thumbs of chapters for an item
   *
   * @remarks
   * Start the chapter thumb generation for an item
   */
  async generateThumbs(
    request: operations.GenerateThumbsRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryGenerateThumbs(
      this,
      request,
      options,
    ));
  }

  /**
   * Credit detect a metadata item
   *
   * @remarks
   * Start credit detection on a metadata item
   */
  async detectCredits(
    request: operations.DetectCreditsRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDetectCredits(
      this,
      request,
      options,
    ));
  }

  /**
   * Get an item's extras
   *
   * @remarks
   * Get the extras for a metadata item
   */
  async getExtras(
    request: operations.GetExtrasRequest,
    options?: RequestOptions,
  ): Promise<operations.GetExtrasResponse> {
    return unwrapAsync(libraryGetExtras(
      this,
      request,
      options,
    ));
  }

  /**
   * Add to an item's extras
   *
   * @remarks
   * Add an extra to a metadata item
   */
  async addExtras(
    request: operations.AddExtrasRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryAddExtras(
      this,
      request,
      options,
    ));
  }

  /**
   * Get a file from a metadata or media bundle
   *
   * @remarks
   * Get a bundle file for a metadata or media item.  This is either an image or a mp3 (for a show's theme)
   */
  async getFile(
    request: operations.GetFileRequest,
    options?: RequestOptions & { acceptHeaderOverride?: GetFileAcceptEnum },
  ): Promise<operations.GetFileResponse> {
    return unwrapAsync(libraryGetFile(
      this,
      request,
      options,
    ));
  }

  /**
   * Start BIF generation of an item
   *
   * @remarks
   * Start the indexing (BIF generation) of an item
   */
  async startBifGeneration(
    request: operations.StartBifGenerationRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryStartBifGeneration(
      this,
      request,
      options,
    ));
  }

  /**
   * Intro detect an item
   *
   * @remarks
   * Start the detection of intros in a metadata item
   */
  async detectIntros(
    request: operations.DetectIntrosRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDetectIntros(
      this,
      request,
      options,
    ));
  }

  /**
   * Create a marker
   *
   * @remarks
   * Create a marker for this user on the metadata item
   */
  async createMarker(
    request: operations.CreateMarkerRequest,
    options?: RequestOptions,
  ): Promise<operations.CreateMarkerResponse> {
    return unwrapAsync(libraryCreateMarker(
      this,
      request,
      options,
    ));
  }

  /**
   * Match a metadata item
   *
   * @remarks
   * Match a metadata item to a guid
   */
  async matchItem(
    request: operations.MatchItemRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryMatchItem(
      this,
      request,
      options,
    ));
  }

  /**
   * Get metadata matches for an item
   *
   * @remarks
   * Get the list of metadata matches for a metadata item
   */
  async listMatches(
    request: operations.ListMatchesRequest,
    options?: RequestOptions,
  ): Promise<shared.MediaContainerWithMetadata> {
    return unwrapAsync(libraryListMatches(
      this,
      request,
      options,
    ));
  }

  /**
   * Merge a metadata item
   *
   * @remarks
   * Merge a metadata item with other items
   */
  async mergeItems(
    request: operations.MergeItemsRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryMergeItems(
      this,
      request,
      options,
    ));
  }

  /**
   * Get nearest tracks to metadata item
   *
   * @remarks
   * Get the nearest tracks, sonically, to the provided track
   */
  async listSonicallySimilar(
    request: operations.ListSonicallySimilarRequest,
    options?: RequestOptions,
  ): Promise<shared.MediaContainerWithMetadata> {
    return unwrapAsync(libraryListSonicallySimilar(
      this,
      request,
      options,
    ));
  }

  /**
   * Set metadata preferences
   *
   * @remarks
   * Set the preferences on a metadata item
   */
  async setItemPreferences(
    request: operations.SetItemPreferencesRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(librarySetItemPreferences(
      this,
      request,
      options,
    ));
  }

  /**
   * Refresh a metadata item
   *
   * @remarks
   * Refresh a metadata item from the agent
   */
  async refreshItemsMetadata(
    request: operations.RefreshItemsMetadataRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryRefreshItemsMetadata(
      this,
      request,
      options,
    ));
  }

  /**
   * Get related items
   *
   * @remarks
   * Get a hub of related items to a metadata item
   */
  async getRelatedItems(
    request: operations.GetRelatedItemsRequest,
    options?: RequestOptions,
  ): Promise<operations.GetRelatedItemsResponse> {
    return unwrapAsync(libraryGetRelatedItems(
      this,
      request,
      options,
    ));
  }

  /**
   * Get similar items
   *
   * @remarks
   * Get a list of similar items to a metadata item
   */
  async listSimilar(
    request: operations.ListSimilarRequest,
    options?: RequestOptions,
  ): Promise<shared.MediaContainerWithMetadata> {
    return unwrapAsync(libraryListSimilar(
      this,
      request,
      options,
    ));
  }

  /**
   * Split a metadata item
   *
   * @remarks
   * Split a metadata item into multiple items
   */
  async splitItem(
    request: operations.SplitItemRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(librarySplitItem(
      this,
      request,
      options,
    ));
  }

  /**
   * Add subtitles
   *
   * @remarks
   * Add a subtitle to a metadata item
   */
  async addSubtitles(
    request: operations.AddSubtitlesRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryAddSubtitles(
      this,
      request,
      options,
    ));
  }

  /**
   * Get metadata items as a tree
   *
   * @remarks
   * Get a tree of metadata items, such as the seasons/episodes of a show
   */
  async getItemTree(
    request: operations.GetItemTreeRequest,
    options?: RequestOptions,
  ): Promise<shared.MediaContainerWithNestedMetadata> {
    return unwrapAsync(libraryGetItemTree(
      this,
      request,
      options,
    ));
  }

  /**
   * Unmatch a metadata item
   *
   * @remarks
   * Unmatch a metadata item to info fetched from the agent
   */
  async unmatch(
    request: operations.UnmatchRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryUnmatch(
      this,
      request,
      options,
    ));
  }

  /**
   * Get metadata top users
   *
   * @remarks
   * Get the list of users which have played this item starting with the most
   */
  async listTopUsers(
    request: operations.ListTopUsersRequest,
    options?: RequestOptions,
  ): Promise<operations.ListTopUsersResponse> {
    return unwrapAsync(libraryListTopUsers(
      this,
      request,
      options,
    ));
  }

  /**
   * Detect voice activity
   *
   * @remarks
   * Start the detection of voice in a metadata item
   */
  async detectVoiceActivity(
    request: operations.DetectVoiceActivityRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDetectVoiceActivity(
      this,
      request,
      options,
    ));
  }

  /**
   * Get augmentation status
   *
   * @remarks
   * Get augmentation status and potentially wait for completion
   */
  async getAugmentationStatus(
    request: operations.GetAugmentationStatusRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryGetAugmentationStatus(
      this,
      request,
      options,
    ));
  }

  /**
   * Set stream selection
   *
   * @remarks
   * Set which streams (audio/subtitle) are selected by this user
   */
  async setStreamSelection(
    request: operations.SetStreamSelectionRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(librarySetStreamSelection(
      this,
      request,
      options,
    ));
  }

  /**
   * Get person details
   *
   * @remarks
   * Get details for a single actor.
   */
  async getPerson(
    request: operations.GetPersonRequest,
    options?: RequestOptions,
  ): Promise<operations.GetPersonResponse> {
    return unwrapAsync(libraryGetPerson(
      this,
      request,
      options,
    ));
  }

  /**
   * Get media for a person
   *
   * @remarks
   * Get all the media for a single actor.
   */
  async listPersonMedia(
    request: operations.ListPersonMediaRequest,
    options?: RequestOptions,
  ): Promise<shared.MediaContainerWithMetadata> {
    return unwrapAsync(libraryListPersonMedia(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a library section
   *
   * @remarks
   * Delete a library section by id
   */
  async deleteLibrarySection(
    request: operations.DeleteLibrarySectionRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDeleteLibrarySection(
      this,
      request,
      options,
    ));
  }

  /**
   * Get a library section by id
   *
   * @remarks
   * Returns details for the library. This can be thought of as an interstitial endpoint because it contains information about the library, rather than content itself. It often contains a list of `Directory` metadata objects: These used to be used by clients to build a menuing system.
   */
  async getLibraryDetails(
    request: operations.GetLibraryDetailsRequest,
    options?: RequestOptions,
  ): Promise<operations.GetLibraryDetailsResponse> {
    return unwrapAsync(libraryGetLibraryDetails(
      this,
      request,
      options,
    ));
  }

  /**
   * Edit a library section
   *
   * @remarks
   * Edit a library section by id setting parameters
   */
  async editSection(
    request: operations.EditSectionRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryEditSection(
      this,
      request,
      options,
    ));
  }

  /**
   * Set the fields of the filtered items
   *
   * @remarks
   * This endpoint takes an large possible set of values.  Here are some examples.
   * - **Parameters, extra documentation**
   *   - artist.title.value
   *       - When used with track, both artist.title.value and album.title.value need to be specified
   *   - title.value usage
   *       - Summary
   *           - Tracks always rename and never merge
   *           - Albums and Artists
   *               - if single item and item without title does not exist, it is renamed.
   *               - if single item and item with title does exist they are merged.
   *               - if multiple they are always merged.
   *       - Tracks
   *           - Works as expected will update the track's title
   *           - Single track:    `/library/sections/{id}/all?type=10&id=42&title.value=NewName`
   *           - Multiple tracks: `/library/sections/{id}/all?type=10&id=42,43,44&title.value=NewName`
   *           - All tracks:      `/library/sections/{id}/all?type=10&title.value=NewName`
   *       - Albums
   *           - Functionality changes depending on the existence of an album with the same title
   *           - Album exists
   *               - Single album: `/library/sections/{id}/all?type=9&id=42&title.value=Album 2`
   *                   - Album with id 42 is merged into album titled "Album 2"
   *               - Multiple/All albums: `/library/sections/{id}/all?type=9&title.value=Moo Album`
   *                   - All albums are merged into the existing album titled "Moo Album"
   *           - Album does not exist
   *               - Single album: `/library/sections/{id}/all?type=9&id=42&title.value=NewAlbumTitle`
   *                   - Album with id 42 has title modified to "NewAlbumTitle"
   *               - Multiple/All albums: `/library/sections/{id}/all?type=9&title.value=NewAlbumTitle`
   *                   - All albums are merged into a new album with title="NewAlbumTitle"
   *       - Artists
   *           - Functionaly changes depending on the existence of an artist with the same title.
   *           - Artist exists
   *               - Single artist: `/library/sections/{id}/all?type=8&id=42&title.value=Artist 2`
   *                   - Artist with id 42 is merged into existing artist titled "Artist 2"
   *               - Multiple/All artists: `/library/sections/{id}/all?type=8&title.value=Artist 3`
   *                   - All artists are merged into the existing artist titled "Artist 3"
   *           - Artist does not exist
   *               - Single artist: `/library/sections/{id}/all?type=8&id=42&title.value=NewArtistTitle`
   *                   - Artist with id 42 has title modified to "NewArtistTitle"
   *               - Multiple/All artists: `/library/sections/{id}/all?type=8&title.value=NewArtistTitle`
   *                   - All artists are merged into a new artist with title="NewArtistTitle"
   *
   * - **Notes**
   *     - Technically square brackets are not allowed in an URI except the Internet Protocol Literal Address
   *     - RFC3513: A host identified by an Internet Protocol literal address, version 6 [RFC3513] or later, is distinguished by enclosing the IP literal within square brackets ("[" and "]"). This is the only place where square bracket characters are allowed in the URI syntax.
   *     - Escaped square brackets are allowed, but don't render well
   */
  async updateItems(
    request: operations.UpdateItemsRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryUpdateItems(
      this,
      request,
      options,
    ));
  }

  /**
   * Analyze a section
   *
   * @remarks
   * Start analysis of all items in a section.  If BIF generation is enabled, this will also be started on this section
   */
  async startAnalysis(
    request: operations.StartAnalysisRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryStartAnalysis(
      this,
      request,
      options,
    ));
  }

  /**
   * Get autocompletions for search
   *
   * @remarks
   * The field to autocomplete on is specified by the `{field}.query` parameter. For example `genre.query` or `title.query`.
   * Returns a set of items from the filtered items whose `{field}` starts with `{field}.query`.  In the results, a `{field}.queryRange` will be present to express the range of the match
   */
  async autocomplete(
    request: operations.AutocompleteRequest,
    options?: RequestOptions,
  ): Promise<operations.AutocompleteResponse> {
    return unwrapAsync(libraryAutocomplete(
      this,
      request,
      options,
    ));
  }

  /**
   * Get collections in a section
   *
   * @remarks
   * Get all collections in a section
   */
  async getCollections(
    request: operations.GetCollectionsRequest,
    options?: RequestOptions,
  ): Promise<operations.GetCollectionsResponse> {
    return unwrapAsync(libraryGetCollections(
      this,
      request,
      options,
    ));
  }

  /**
   * Get common fields for items
   *
   * @remarks
   * Represents a "Common" item. It contains only the common attributes of the items selected by the provided filter
   * Fields which are not common will be expressed in the `mixedFields` field
   */
  async getCommon(
    request: operations.GetCommonRequest,
    options?: RequestOptions,
  ): Promise<operations.GetCommonResponse> {
    return unwrapAsync(libraryGetCommon(
      this,
      request,
      options,
    ));
  }

  /**
   * Empty section trash
   *
   * @remarks
   * Empty trash in the section, permanently deleting media/metadata for missing media
   */
  async emptyTrash(
    request: operations.EmptyTrashRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryEmptyTrash(
      this,
      request,
      options,
    ));
  }

  /**
   * Get section filters
   *
   * @remarks
   * Get common filters on a section
   */
  async getSectionFilters(
    request: operations.GetSectionFiltersRequest,
    options?: RequestOptions,
  ): Promise<operations.GetSectionFiltersResponse> {
    return unwrapAsync(libraryGetSectionFilters(
      this,
      request,
      options,
    ));
  }

  /**
   * Get list of first characters
   *
   * @remarks
   * Get list of first characters in this section
   */
  async getFirstCharacters(
    request: operations.GetFirstCharactersRequest,
    options?: RequestOptions,
  ): Promise<operations.GetFirstCharactersResponse> {
    return unwrapAsync(libraryGetFirstCharacters(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete section indexes
   *
   * @remarks
   * Delete all the indexes in a section
   */
  async deleteIndexes(
    request: operations.DeleteIndexesRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDeleteIndexes(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete section intro markers
   *
   * @remarks
   * Delete all the intro markers in a section
   */
  async deleteIntros(
    request: operations.DeleteIntrosRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDeleteIntros(
      this,
      request,
      options,
    ));
  }

  /**
   * Get section prefs
   *
   * @remarks
   * Get the prefs for a section by id and potentially overriding the agent
   */
  async getSectionPreferences(
    request: operations.GetSectionPreferencesRequest,
    options?: RequestOptions,
  ): Promise<shared.MediaContainerWithSettings> {
    return unwrapAsync(libraryGetSectionPreferences(
      this,
      request,
      options,
    ));
  }

  /**
   * Set section prefs
   *
   * @remarks
   * Set the prefs for a section by id
   */
  async setSectionPreferences(
    request: operations.SetSectionPreferencesRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(librarySetSectionPreferences(
      this,
      request,
      options,
    ));
  }

  /**
   * Cancel section refresh
   *
   * @remarks
   * Cancel the refresh of a section
   */
  async cancelRefresh(
    request: operations.CancelRefreshRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryCancelRefresh(
      this,
      request,
      options,
    ));
  }

  /**
   * Refresh section
   *
   * @remarks
   * Start a refresh of this section
   */
  async refreshSection(
    request: operations.RefreshSectionRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryRefreshSection(
      this,
      request,
      options,
    ));
  }

  /**
   * Get a section sorts
   *
   * @remarks
   * Get the sort mechanisms available in a section
   */
  async getAvailableSorts(
    request: operations.GetAvailableSortsRequest,
    options?: RequestOptions,
  ): Promise<operations.GetAvailableSortsResponse> {
    return unwrapAsync(libraryGetAvailableSorts(
      this,
      request,
      options,
    ));
  }

  /**
   * Get loudness about a stream in json
   *
   * @remarks
   * The the loudness of a stream in db, one entry per 100ms
   */
  async getStreamLevels(
    request: operations.GetStreamLevelsRequest,
    options?: RequestOptions,
  ): Promise<operations.GetStreamLevelsResponse> {
    return unwrapAsync(libraryGetStreamLevels(
      this,
      request,
      options,
    ));
  }

  /**
   * Get loudness about a stream
   *
   * @remarks
   * The the loudness of a stream in db, one number per line, one entry per 100ms
   */
  async getStreamLoudness(
    request: operations.GetStreamLoudnessRequest,
    options?: RequestOptions,
  ): Promise<string> {
    return unwrapAsync(libraryGetStreamLoudness(
      this,
      request,
      options,
    ));
  }

  /**
   * Get a chapter image
   *
   * @remarks
   * Get a single chapter image for a piece of media
   */
  async getChapterImage(
    request: operations.GetChapterImageRequest,
    options?: RequestOptions,
  ): Promise<ReadableStream<Uint8Array>> {
    return unwrapAsync(libraryGetChapterImage(
      this,
      request,
      options,
    ));
  }

  /**
   * Set an item's artwork, theme, etc
   *
   * @remarks
   * Set the artwork, thumb, element for a metadata item
   * Generally only the admin can perform this action.  The exception is if the metadata is a playlist created by the user
   */
  async setItemArtwork(
    request: operations.SetItemArtworkRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(librarySetItemArtwork(
      this,
      request,
      options,
    ));
  }

  /**
   * Set an item's artwork, theme, etc
   *
   * @remarks
   * Set the artwork, thumb, element for a metadata item
   * Generally only the admin can perform this action.  The exception is if the metadata is a playlist created by the user
   */
  async updateItemArtwork(
    request: operations.UpdateItemArtworkRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryUpdateItemArtwork(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a marker
   *
   * @remarks
   * Delete a marker for this user on the metadata item
   */
  async deleteMarker(
    request: operations.DeleteMarkerRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDeleteMarker(
      this,
      request,
      options,
    ));
  }

  /**
   * Edit a marker
   *
   * @remarks
   * Edit a marker for this user on the metadata item
   */
  async editMarker(
    request: operations.EditMarkerRequest,
    options?: RequestOptions,
  ): Promise<shared.PostResponses200> {
    return unwrapAsync(libraryEditMarker(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a media item
   *
   * @remarks
   * Delete a single media from a metadata item in the library
   */
  async deleteMediaItem(
    request: operations.DeleteMediaItemRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDeleteMediaItem(
      this,
      request,
      options,
    ));
  }

  /**
   * Get BIF index for a part
   *
   * @remarks
   * Get BIF index for a part by index type
   */
  async getPartIndex(
    request: operations.GetPartIndexRequest,
    options?: RequestOptions,
  ): Promise<ReadableStream<Uint8Array>> {
    return unwrapAsync(libraryGetPartIndex(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a collection
   *
   * @remarks
   * Delete a library collection from the PMS
   */
  async deleteCollection(
    request: operations.DeleteCollectionRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDeleteCollection(
      this,
      request,
      options,
    ));
  }

  /**
   * Get a section composite image
   *
   * @remarks
   * Get a composite image of images in this section
   */
  async getSectionImage(
    request: operations.GetSectionImageRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryGetSectionImage(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete a stream
   *
   * @remarks
   * Delete a stream.  Only applies to downloaded subtitle streams or a sidecar subtitle when media deletion is enabled.
   */
  async deleteStream(
    request: operations.DeleteStreamRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryDeleteStream(
      this,
      request,
      options,
    ));
  }

  /**
   * Get a stream
   *
   * @remarks
   * Get a stream (such as a sidecar subtitle stream)
   */
  async getStream(
    request: operations.GetStreamRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(libraryGetStream(
      this,
      request,
      options,
    ));
  }

  /**
   * Set a stream offset
   *
   * @remarks
   * Set a stream offset in ms.  This may not be respected by all clients
   */
  async setStreamOffset(
    request: operations.SetStreamOffsetRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(librarySetStreamOffset(
      this,
      request,
      options,
    ));
  }

  /**
   * Get an item's artwork, theme, etc
   *
   * @remarks
   * Get the artwork, thumb, element for a metadata item
   */
  async getItemArtwork(
    request: operations.GetItemArtworkRequest,
    options?: RequestOptions & {
      acceptHeaderOverride?: GetItemArtworkAcceptEnum;
    },
  ): Promise<operations.GetItemArtworkResponse> {
    return unwrapAsync(libraryGetItemArtwork(
      this,
      request,
      options,
    ));
  }

  /**
   * Get a media part
   *
   * @remarks
   * Get a media part for streaming or download.
   *   - streaming: This is the default scenario.  Bandwidth usage on this endpoint will be guaranteed (on the server's end) to be at least the bandwidth reservation given in the decision.  If no decision exists, an ad-hoc decision will be created if sufficient bandwidth exists.  Clients should not rely on ad-hoc decisions being made as this may be removed in the future.
   *   - download: Indicated if the query parameter indicates this is a download.  Bandwidth will be prioritized behind playbacks and will get a fair share of what remains.
   */
  async getMediaPart(
    request: operations.GetMediaPartRequest,
    options?: RequestOptions,
  ): Promise<operations.GetMediaPartResponse | undefined> {
    return unwrapAsync(libraryGetMediaPart(
      this,
      request,
      options,
    ));
  }

  /**
   * Get an image from part BIF
   *
   * @remarks
   * Extract an image from the BIF for a part at a particular offset
   */
  async getImageFromBif(
    request: operations.GetImageFromBifRequest,
    options?: RequestOptions,
  ): Promise<ReadableStream<Uint8Array>> {
    return unwrapAsync(libraryGetImageFromBif(
      this,
      request,
      options,
    ));
  }
}
