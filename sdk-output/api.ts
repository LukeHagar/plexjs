/* tslint:disable */
/* eslint-disable */
/**
 * Plex-API
 * An Open API Spec for interacting with Plex.tv and Plex Servers
 *
 * The version of the OpenAPI document: 0.0.3
 * Contact: Lukeslakemail@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from '../configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ServerActivities200Response
 */
export interface ServerActivities200Response {
    /**
     * 
     * @type {ServerActivities200ResponseMediaContainer}
     * @memberof ServerActivities200Response
     */
    'MediaContainer'?: ServerActivities200ResponseMediaContainer;
}
/**
 * 
 * @export
 * @interface ServerActivities200ResponseMediaContainer
 */
export interface ServerActivities200ResponseMediaContainer {
    /**
     * 
     * @type {any}
     * @memberof ServerActivities200ResponseMediaContainer
     */
    'size'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerActivities200ResponseMediaContainer
     */
    'Activity'?: any;
}
/**
 * 
 * @export
 * @interface ServerCapabilities200Response
 */
export interface ServerCapabilities200Response {
    /**
     * 
     * @type {ServerCapabilities200ResponseMediaContainer}
     * @memberof ServerCapabilities200Response
     */
    'MediaContainer'?: ServerCapabilities200ResponseMediaContainer;
}
/**
 * 
 * @export
 * @interface ServerCapabilities200ResponseMediaContainer
 */
export interface ServerCapabilities200ResponseMediaContainer {
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'size'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'allowCameraUpload'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'allowChannelAccess'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'allowMediaDeletion'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'allowSharing'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'allowSync'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'allowTuners'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'backgroundProcessing'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'certificate'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'companionProxy'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'countryCode'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'diagnostics'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'eventStream'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'friendlyName'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'hubSearch'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'itemClusters'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'livetv'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'machineIdentifier'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'mediaProviders'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'multiuser'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'musicAnalysis'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'myPlex'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'myPlexMappingState'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'myPlexSigninState'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'myPlexSubscription'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'myPlexUsername'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'offlineTranscode'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'ownerFeatures'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'photoAutoTag'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'platform'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'platformVersion'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'pluginHost'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'pushNotifications'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'readOnlyLibraries'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'streamingBrainABRVersion'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'streamingBrainVersion'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'sync'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderActiveVideoSessions'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderAudio'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderLyrics'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderPhoto'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderSubtitles'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderVideo'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderVideoBitrates'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderVideoQualities'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'transcoderVideoResolutions'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'updatedAt'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'updater'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'version'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'voiceSearch'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerCapabilities200ResponseMediaContainer
     */
    'Directory'?: any;
}

/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
export const ActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel Server Activities
         * @summary Cancel Server Activities
         * @param {any} activityUUID The UUID of the activity to cancel.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelServerActivities: async (activityUUID: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityUUID' is not null or undefined
            assertParamExists('cancelServerActivities', 'activityUUID', activityUUID)
            const localVarPath = `/activities/{activityUUID}`
                .replace(`{${"activityUUID"}}`, encodeURIComponent(String(activityUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Server Activities
         * @summary Server Activities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        serverActivities: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel Server Activities
         * @summary Cancel Server Activities
         * @param {any} activityUUID The UUID of the activity to cancel.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async cancelServerActivities(activityUUID: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelServerActivities(activityUUID, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Server Activities
         * @summary Server Activities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async serverActivities(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerActivities200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serverActivities(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivitiesApiFp(configuration)
    return {
        /**
         * Cancel Server Activities
         * @summary Cancel Server Activities
         * @param {any} activityUUID The UUID of the activity to cancel.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        cancelServerActivities(activityUUID: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.cancelServerActivities(activityUUID, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Server Activities
         * @summary Server Activities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        serverActivities(axiosOptions?: any): AxiosPromise<ServerActivities200Response> {
            return localVarFp.serverActivities(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelServerActivities operation in ActivitiesApi.
 * @export
 * @interface ActivitiesApiCancelServerActivitiesRequest
 */
export interface ActivitiesApiCancelServerActivitiesRequest {
    /**
     * The UUID of the activity to cancel.
     * @type {any}
     * @memberof ActivitiesApiCancelServerActivities
     */
    readonly activityUUID: any
}

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * Cancel Server Activities
     * @summary Cancel Server Activities
     * @param {ActivitiesApiCancelServerActivitiesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public cancelServerActivities(requestParameters: ActivitiesApiCancelServerActivitiesRequest, axiosOptions?: AxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).cancelServerActivities(requestParameters.activityUUID, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Server Activities
     * @summary Server Activities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public serverActivities(axiosOptions?: AxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).serverActivities(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ButlerApi - axios parameter creator
 * @export
 */
export const ButlerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
         * @summary Start a single Butler task
         * @param {any} taskName the name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAButlerTasks: async (taskName: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskName' is not null or undefined
            assertParamExists('startAButlerTasks', 'taskName', taskName)
            const localVarPath = `/butler/{taskName}`
                .replace(`{${"taskName"}}`, encodeURIComponent(String(taskName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
         * @summary Start all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAllButlerTasks: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/butler`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint. 
         * @summary Stop a single Butler task
         * @param {any} taskName The name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAButlerTasks: async (taskName: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskName' is not null or undefined
            assertParamExists('stopAButlerTasks', 'taskName', taskName)
            const localVarPath = `/butler/{taskName}`
                .replace(`{${"taskName"}}`, encodeURIComponent(String(taskName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue. 
         * @summary Stop all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAllButlerTasks: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/butler`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ButlerApi - functional programming interface
 * @export
 */
export const ButlerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ButlerApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
         * @summary Start a single Butler task
         * @param {any} taskName the name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startAButlerTasks(taskName: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startAButlerTasks(taskName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
         * @summary Start all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async startAllButlerTasks(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startAllButlerTasks(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint. 
         * @summary Stop a single Butler task
         * @param {any} taskName The name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async stopAButlerTasks(taskName: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopAButlerTasks(taskName, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue. 
         * @summary Stop all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async stopAllButlerTasks(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopAllButlerTasks(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ButlerApi - factory interface
 * @export
 */
export const ButlerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ButlerApiFp(configuration)
    return {
        /**
         * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
         * @summary Start a single Butler task
         * @param {any} taskName the name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAButlerTasks(taskName: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.startAButlerTasks(taskName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
         * @summary Start all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        startAllButlerTasks(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.startAllButlerTasks(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint. 
         * @summary Stop a single Butler task
         * @param {any} taskName The name of the task to be started.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAButlerTasks(taskName: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.stopAButlerTasks(taskName, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue. 
         * @summary Stop all Butler tasks
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        stopAllButlerTasks(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.stopAllButlerTasks(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for startAButlerTasks operation in ButlerApi.
 * @export
 * @interface ButlerApiStartAButlerTasksRequest
 */
export interface ButlerApiStartAButlerTasksRequest {
    /**
     * the name of the task to be started.
     * @type {any}
     * @memberof ButlerApiStartAButlerTasks
     */
    readonly taskName: any
}

/**
 * Request parameters for stopAButlerTasks operation in ButlerApi.
 * @export
 * @interface ButlerApiStopAButlerTasksRequest
 */
export interface ButlerApiStopAButlerTasksRequest {
    /**
     * The name of the task to be started.
     * @type {any}
     * @memberof ButlerApiStopAButlerTasks
     */
    readonly taskName: any
}

/**
 * ButlerApi - object-oriented interface
 * @export
 * @class ButlerApi
 * @extends {BaseAPI}
 */
export class ButlerApi extends BaseAPI {
    /**
     * This endpoint will attempt to start a single Butler task that is enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
     * @summary Start a single Butler task
     * @param {ButlerApiStartAButlerTasksRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    public startAButlerTasks(requestParameters: ButlerApiStartAButlerTasksRequest, axiosOptions?: AxiosRequestConfig) {
        return ButlerApiFp(this.configuration).startAButlerTasks(requestParameters.taskName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will attempt to start all Butler tasks that are enabled in the settings. Butler tasks normally run automatically during a time window configured on the server\'s Settings page but can be manually started using this endpoint. Tasks will run with the following criteria: 1. Any tasks not scheduled to run on the current day will be skipped. 2. If a task is configured to run at a random time during the configured window and we are outside that window, the task will start immediately. 3. If a task is configured to run at a random time during the configured window and we are within that window, the task will be scheduled at a random time within the window. 4. If we are outside the configured window, the task will start immediately. 
     * @summary Start all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    public startAllButlerTasks(axiosOptions?: AxiosRequestConfig) {
        return ButlerApiFp(this.configuration).startAllButlerTasks(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will stop a currently running task by name, or remove it from the list of scheduled tasks if it exists. See the section above for a list of task names for this endpoint. 
     * @summary Stop a single Butler task
     * @param {ButlerApiStopAButlerTasksRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    public stopAButlerTasks(requestParameters: ButlerApiStopAButlerTasksRequest, axiosOptions?: AxiosRequestConfig) {
        return ButlerApiFp(this.configuration).stopAButlerTasks(requestParameters.taskName, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will stop all currently running tasks and remove any scheduled tasks from the queue. 
     * @summary Stop all Butler tasks
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ButlerApi
     */
    public stopAllButlerTasks(axiosOptions?: AxiosRequestConfig) {
        return ButlerApiFp(this.configuration).stopAllButlerTasks(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LibraryApi - axios parameter creator
 * @export
 */
export const LibraryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint will return a list of libraries 
         * @summary Get All Libraries
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraries: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/library/sections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will return a list of library items filtered by the filter and type provided 
         * @summary Get Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} category the category to retrieve from the library
         * @param {any} [type] item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItems: async (sectionId: any, category: any, type?: any, filter?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('getLibraryItems', 'sectionId', sectionId)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('getLibraryItems', 'category', category)
            const localVarPath = `/library/sections/{sectionId}/{category}`
                .replace(`{${"sectionId"}}`, encodeURIComponent(String(sectionId)))
                .replace(`{${"category"}}`, encodeURIComponent(String(category)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryApi - functional programming interface
 * @export
 */
export const LibraryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LibraryApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint will return a list of libraries 
         * @summary Get All Libraries
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraries(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraries(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will return a list of library items filtered by the filter and type provided 
         * @summary Get Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} category the category to retrieve from the library
         * @param {any} [type] item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryItems(sectionId: any, category: any, type?: any, filter?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryItems(sectionId, category, type, filter, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LibraryApi - factory interface
 * @export
 */
export const LibraryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LibraryApiFp(configuration)
    return {
        /**
         * This endpoint will return a list of libraries 
         * @summary Get All Libraries
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraries(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getLibraries(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return a list of library items filtered by the filter and type provided 
         * @summary Get Library Items
         * @param {any} sectionId the Id of the library to query
         * @param {any} category the category to retrieve from the library
         * @param {any} [type] item type
         * @param {any} [filter] the filter parameter
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItems(sectionId: any, category: any, type?: any, filter?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getLibraryItems(sectionId, category, type, filter, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLibraryItems operation in LibraryApi.
 * @export
 * @interface LibraryApiGetLibraryItemsRequest
 */
export interface LibraryApiGetLibraryItemsRequest {
    /**
     * the Id of the library to query
     * @type {any}
     * @memberof LibraryApiGetLibraryItems
     */
    readonly sectionId: any

    /**
     * the category to retrieve from the library
     * @type {any}
     * @memberof LibraryApiGetLibraryItems
     */
    readonly category: any

    /**
     * item type
     * @type {any}
     * @memberof LibraryApiGetLibraryItems
     */
    readonly type?: any

    /**
     * the filter parameter
     * @type {any}
     * @memberof LibraryApiGetLibraryItems
     */
    readonly filter?: any
}

/**
 * LibraryApi - object-oriented interface
 * @export
 * @class LibraryApi
 * @extends {BaseAPI}
 */
export class LibraryApi extends BaseAPI {
    /**
     * This endpoint will return a list of libraries 
     * @summary Get All Libraries
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraries(axiosOptions?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getLibraries(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will return a list of library items filtered by the filter and type provided 
     * @summary Get Library Items
     * @param {LibraryApiGetLibraryItemsRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraryItems(requestParameters: LibraryApiGetLibraryItemsRequest, axiosOptions?: AxiosRequestConfig) {
        return LibraryApiFp(this.configuration).getLibraryItems(requestParameters.sectionId, requestParameters.category, requestParameters.type, requestParameters.filter, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LogApi - axios parameter creator
 * @export
 */
export const LogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time. 
         * @summary Enabling Papertrail
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enablePaperTrail: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log/networked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above. 
         * @summary Logging a multi-line message
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logMultipleLines: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log. 
         * @summary Logging a single line message.
         * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose 
         * @param {any} message The text of the message to write to the log.
         * @param {any} source a string indicating the source of the message.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logaLine: async (level: any, message: any, source: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'level' is not null or undefined
            assertParamExists('logaLine', 'level', level)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('logaLine', 'message', message)
            // verify required parameter 'source' is not null or undefined
            assertParamExists('logaLine', 'source', source)
            const localVarPath = `/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogApi - functional programming interface
 * @export
 */
export const LogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time. 
         * @summary Enabling Papertrail
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async enablePaperTrail(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enablePaperTrail(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above. 
         * @summary Logging a multi-line message
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async logMultipleLines(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logMultipleLines(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log. 
         * @summary Logging a single line message.
         * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose 
         * @param {any} message The text of the message to write to the log.
         * @param {any} source a string indicating the source of the message.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async logaLine(level: any, message: any, source: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logaLine(level, message, source, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LogApi - factory interface
 * @export
 */
export const LogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogApiFp(configuration)
    return {
        /**
         * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time. 
         * @summary Enabling Papertrail
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        enablePaperTrail(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.enablePaperTrail(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above. 
         * @summary Logging a multi-line message
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logMultipleLines(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.logMultipleLines(axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log. 
         * @summary Logging a single line message.
         * @param {any} level An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose 
         * @param {any} message The text of the message to write to the log.
         * @param {any} source a string indicating the source of the message.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        logaLine(level: any, message: any, source: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.logaLine(level, message, source, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for logaLine operation in LogApi.
 * @export
 * @interface LogApiLogaLineRequest
 */
export interface LogApiLogaLineRequest {
    /**
     * An integer log level to write to the PMS log with.   0: Error   1: Warning   2: Info  3: Debug   4: Verbose 
     * @type {any}
     * @memberof LogApiLogaLine
     */
    readonly level: any

    /**
     * The text of the message to write to the log.
     * @type {any}
     * @memberof LogApiLogaLine
     */
    readonly message: any

    /**
     * a string indicating the source of the message.
     * @type {any}
     * @memberof LogApiLogaLine
     */
    readonly source: any
}

/**
 * LogApi - object-oriented interface
 * @export
 * @class LogApi
 * @extends {BaseAPI}
 */
export class LogApi extends BaseAPI {
    /**
     * This endpoint will enable all Plex Media Serverlogs to be sent to the Papertrail networked logging site for a period of time. 
     * @summary Enabling Papertrail
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public enablePaperTrail(axiosOptions?: AxiosRequestConfig) {
        return LogApiFp(this.configuration).enablePaperTrail(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will write multiple lines to the main Plex Media Server log in a single request. It takes a set of query strings as would normally sent to the above GET endpoint as a linefeed-separated block of POST data. The parameters for each query string match as above. 
     * @summary Logging a multi-line message
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logMultipleLines(axiosOptions?: AxiosRequestConfig) {
        return LogApiFp(this.configuration).logMultipleLines(axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will write a single-line log message, including a level and source to the main Plex Media Server log. 
     * @summary Logging a single line message.
     * @param {LogApiLogaLineRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logaLine(requestParameters: LogApiLogaLineRequest, axiosOptions?: AxiosRequestConfig) {
        return LogApiFp(this.configuration).logaLine(requestParameters.level, requestParameters.message, requestParameters.source, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4. 
         * @summary Get Source Connection Information
         * @param {any} source The source identifier with an included prefix.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionInformation: async (source: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            assertParamExists('getConnectionInformation', 'source', source)
            const localVarPath = `/security/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted. 
         * @summary Get a Transient Token.
         * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
         * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransientToken: async (type: any, scope: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTransientToken', 'type', type)
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('getTransientToken', 'scope', scope)
            const localVarPath = `/security/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration)
    return {
        /**
         * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4. 
         * @summary Get Source Connection Information
         * @param {any} source The source identifier with an included prefix.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionInformation(source: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectionInformation(source, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted. 
         * @summary Get a Transient Token.
         * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
         * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async getTransientToken(type: any, scope: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransientToken(type, scope, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityApiFp(configuration)
    return {
        /**
         * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4. 
         * @summary Get Source Connection Information
         * @param {any} source The source identifier with an included prefix.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionInformation(source: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getConnectionInformation(source, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted. 
         * @summary Get a Transient Token.
         * @param {any} type &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
         * @param {any} scope &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        getTransientToken(type: any, scope: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.getTransientToken(type, scope, axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getConnectionInformation operation in SecurityApi.
 * @export
 * @interface SecurityApiGetConnectionInformationRequest
 */
export interface SecurityApiGetConnectionInformationRequest {
    /**
     * The source identifier with an included prefix.
     * @type {any}
     * @memberof SecurityApiGetConnectionInformation
     */
    readonly source: any
}

/**
 * Request parameters for getTransientToken operation in SecurityApi.
 * @export
 * @interface SecurityApiGetTransientTokenRequest
 */
export interface SecurityApiGetTransientTokenRequest {
    /**
     * &#x60;delegation&#x60; - This is the only supported &#x60;type&#x60; parameter.
     * @type {any}
     * @memberof SecurityApiGetTransientToken
     */
    readonly type: any

    /**
     * &#x60;all&#x60; - This is the only supported &#x60;scope&#x60; parameter.
     * @type {any}
     * @memberof SecurityApiGetTransientToken
     */
    readonly scope: any
}

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * If a caller requires connection details and a transient token for a source that is known to the server, for example a cloud media provider or shared PMS, then this endpoint can be called. This endpoint is only accessible with either an admin token or a valid transient token generated from an admin token. Note: requires Plex Media Server >= 1.15.4. 
     * @summary Get Source Connection Information
     * @param {SecurityApiGetConnectionInformationRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getConnectionInformation(requestParameters: SecurityApiGetConnectionInformationRequest, axiosOptions?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).getConnectionInformation(requestParameters.source, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint provides the caller with a temporary token with the same access level as the caller\'s token. These tokens are valid for up to 48 hours and are destroyed if the server instance is restarted. 
     * @summary Get a Transient Token.
     * @param {SecurityApiGetTransientTokenRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getTransientToken(requestParameters: SecurityApiGetTransientTokenRequest, axiosOptions?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).getTransientToken(requestParameters.type, requestParameters.scope, axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Server Capabilities
         * @summary Server Capabilities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        serverCapabilities: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration)
    return {
        /**
         * Server Capabilities
         * @summary Server Capabilities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async serverCapabilities(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerCapabilities200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serverCapabilities(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerApiFp(configuration)
    return {
        /**
         * Server Capabilities
         * @summary Server Capabilities
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        serverCapabilities(axiosOptions?: any): AxiosPromise<ServerCapabilities200Response> {
            return localVarFp.serverCapabilities(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * Server Capabilities
     * @summary Server Capabilities
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverCapabilities(axiosOptions?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).serverCapabilities(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdaterApi - axios parameter creator
 * @export
 */
export const UpdaterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed 
         * @summary Applying updates
         * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
         * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        applyingUpdates: async (tonight?: any, skip?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/updater/apply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tonight !== undefined) {
                localVarQueryParameter['tonight'] = tonight;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Checking for updates
         * @summary Checking for updates
         * @param {any} [download] Indicate that you want to start download any updates found.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        checkingforUpdates: async (download?: any, axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/updater/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
        /**
         * Querying status of updates
         * @summary Querying status of updates
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryingUpdateStatus: async (axiosOptions: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/updater/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...axiosOptions};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...axiosOptions.headers};

            return {
                url: toPathString(localVarUrlObj),
                axiosOptions: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdaterApi - functional programming interface
 * @export
 */
export const UpdaterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdaterApiAxiosParamCreator(configuration)
    return {
        /**
         * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed 
         * @summary Applying updates
         * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
         * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async applyingUpdates(tonight?: any, skip?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyingUpdates(tonight, skip, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Checking for updates
         * @summary Checking for updates
         * @param {any} [download] Indicate that you want to start download any updates found.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async checkingforUpdates(download?: any, axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkingforUpdates(download, axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Querying status of updates
         * @summary Querying status of updates
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        async queryingUpdateStatus(axiosOptions?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryingUpdateStatus(axiosOptions);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdaterApi - factory interface
 * @export
 */
export const UpdaterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdaterApiFp(configuration)
    return {
        /**
         * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed 
         * @summary Applying updates
         * @param {any} [tonight] Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
         * @param {any} [skip] Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        applyingUpdates(tonight?: any, skip?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.applyingUpdates(tonight, skip, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Checking for updates
         * @summary Checking for updates
         * @param {any} [download] Indicate that you want to start download any updates found.
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        checkingforUpdates(download?: any, axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.checkingforUpdates(download, axiosOptions).then((request) => request(axios, basePath));
        },
        /**
         * Querying status of updates
         * @summary Querying status of updates
         * @param {*} [axiosOptions] Override http request option.
         * @throws {RequiredError}
         */
        queryingUpdateStatus(axiosOptions?: any): AxiosPromise<void> {
            return localVarFp.queryingUpdateStatus(axiosOptions).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for applyingUpdates operation in UpdaterApi.
 * @export
 * @interface UpdaterApiApplyingUpdatesRequest
 */
export interface UpdaterApiApplyingUpdatesRequest {
    /**
     * Indicate that you want the update to run during the next Butler execution. Omitting this or setting it to false indicates that the update should install
     * @type {any}
     * @memberof UpdaterApiApplyingUpdates
     */
    readonly tonight?: any

    /**
     * Indicate that the latest version should be marked as skipped. The &lt;Release&gt; entry for this version will have the &#x60;state&#x60; set to &#x60;skipped&#x60;.
     * @type {any}
     * @memberof UpdaterApiApplyingUpdates
     */
    readonly skip?: any
}

/**
 * Request parameters for checkingforUpdates operation in UpdaterApi.
 * @export
 * @interface UpdaterApiCheckingforUpdatesRequest
 */
export interface UpdaterApiCheckingforUpdatesRequest {
    /**
     * Indicate that you want to start download any updates found.
     * @type {any}
     * @memberof UpdaterApiCheckingforUpdates
     */
    readonly download?: any
}

/**
 * UpdaterApi - object-oriented interface
 * @export
 * @class UpdaterApi
 * @extends {BaseAPI}
 */
export class UpdaterApi extends BaseAPI {
    /**
     * Note that these two parameters are effectively mutually exclusive. The `tonight` parameter takes precedence and `skip` will be ignored if `tonight` is also passed 
     * @summary Applying updates
     * @param {UpdaterApiApplyingUpdatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    public applyingUpdates(requestParameters: UpdaterApiApplyingUpdatesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return UpdaterApiFp(this.configuration).applyingUpdates(requestParameters.tonight, requestParameters.skip, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checking for updates
     * @summary Checking for updates
     * @param {UpdaterApiCheckingforUpdatesRequest} requestParameters Request parameters.
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    public checkingforUpdates(requestParameters: UpdaterApiCheckingforUpdatesRequest = {}, axiosOptions?: AxiosRequestConfig) {
        return UpdaterApiFp(this.configuration).checkingforUpdates(requestParameters.download, axiosOptions).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Querying status of updates
     * @summary Querying status of updates
     * @param {*} [axiosOptions] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdaterApi
     */
    public queryingUpdateStatus(axiosOptions?: AxiosRequestConfig) {
        return UpdaterApiFp(this.configuration).queryingUpdateStatus(axiosOptions).then((request) => request(this.axios, this.basePath));
    }
}


